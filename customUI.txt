--[[
    NebulaUI Library - PHASE 1
    A comprehensive UI Library for Roblox combining features from Orion, Rayfield, and Drowned
    
    Author: Generated by Claude
    Version: 1.0.0
]]

-- ========================== CORE MODULES ==========================

-- ========================== Core/Init.lua ==========================
--[[
    Core initialization module that bootstraps the library and handles dependencies
]]
local Init = {}
Init.__index = Init

-- Services
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local TextService = game:GetService("TextService")

-- Constants
Init.IS_STUDIO = RunService:IsStudio()
Init.LOCAL_PLAYER = Players.LocalPlayer
Init.SCREEN_GUI_PARENT = (RunService:IsStudio() and Players.LocalPlayer:WaitForChild("PlayerGui")) or CoreGui

-- Module paths
Init.Modules = {
    Signal = script.Parent.Signal,
    Utils = script.Parent.Utils,
    ThemeManager = script.Parent.ThemeManager,
    Drag = script.Parent.Drag,
    Config = script.Parent.Config,
    
    -- Components
    Button = script.Parent.Parent.Components.Button,
    Toggle = script.Parent.Parent.Components.Toggle,
    Slider = script.Parent.Parent.Components.Slider,
    Dropdown = script.Parent.Parent.Components.Dropdown,
    Keybind = script.Parent.Parent.Components.Keybind,
    ColorPicker = script.Parent.Parent.Components.ColorPicker,
    
    -- Layout
    Window = script.Parent.Parent.Layout.Window,
    TabManager = script.Parent.Parent.Layout.TabManager,
    Section = script.Parent.Parent.Layout.Section,
    Scrolling = script.Parent.Parent.Layout.Scrolling,
    
    -- Extra
    Notification = script.Parent.Parent.Extra.Notification,
    SaveSystem = script.Parent.Parent.Extra.SaveSystem,
    Prompt = script.Parent.Parent.Extra.Prompt
}

-- Cache for loaded modules
Init.LoadedModules = {}

-- Version info
Init.Version = {
    Major = 1,
    Minor = 0,
    Patch = 0,
    String = "1.0.0"
}

-- Require a module and cache it
function Init:GetModule(name)
    if self.LoadedModules[name] then
        return self.LoadedModules[name]
    end
    
    local modulePath = self.Modules[name]
    if not modulePath then
        error("Module not found: " .. name)
    end
    
    local moduleInstance = require(modulePath)
    self.LoadedModules[name] = moduleInstance
    return moduleInstance
end

-- Initialize the library
function Init:Initialize()
    -- Load core dependencies
    self.Signal = self:GetModule("Signal")
    self.Utils = self:GetModule("Utils")
    self.ThemeManager = self:GetModule("ThemeManager")
    self.Config = self:GetModule("Config")
    
    -- Initialize Theme Manager
    self.ThemeManager:Initialize()
    
    -- Create events
    self.Events = {
        WindowCreated = self.Signal.new(),
        WindowDestroyed = self.Signal.new(),
        ThemeChanged = self.Signal.new(),
        LibraryDestroyed = self.Signal.new()
    }
    
    return self
end

-- Clean up the library
function Init:Destroy()
    -- Trigger library destroyed event
    self.Events.LibraryDestroyed:Fire()
    
    -- Clean up events
    for _, event in pairs(self.Events) do
        event:Destroy()
    end
    
    -- Clear module cache
    table.clear(self.LoadedModules)
end

return Init

-- ========================== Core/Signal.lua ==========================
--[[
    Signal implementation for custom events
    Based on Roblox's BindableEvent but with more functionality
]]
local Signal = {}
Signal.__index = Signal

-- Create a new signal
function Signal.new()
    local self = setmetatable({}, Signal)
    
    self._connections = {}
    self._destroyed = false
    
    return self
end

-- Connect a function to the signal
function Signal:Connect(fn)
    assert(typeof(fn) == "function", "Connection must be a function")
    assert(not self._destroyed, "Cannot connect to a destroyed signal")
    
    local connection = {
        Connected = true,
        _callback = fn,
        _signal = self
    }
    
    -- Define connection methods
    function connection:Disconnect()
        if not self.Connected then return end
        
        self.Connected = false
        
        -- Find and remove the connection
        for i, conn in ipairs(self._signal._connections) do
            if conn == self then
                table.remove(self._signal._connections, i)
                break
            end
        end
    end
    
    -- Add connection to the list
    table.insert(self._connections, connection)
    
    return connection
end

-- Fire the signal with the given arguments
function Signal:Fire(...)
    assert(not self._destroyed, "Cannot fire a destroyed signal")
    
    -- Create a copy of connections to avoid issues if connections are added/removed during firing
    local connections = table.clone(self._connections)
    
    -- Call all connected functions
    for _, connection in ipairs(connections) do
        if connection.Connected then
            task.spawn(connection._callback, ...)
        end
    end
end

-- Wait for the signal to fire and return the arguments
function Signal:Wait()
    assert(not self._destroyed, "Cannot wait on a destroyed signal")
    
    -- Create a thread that will resume when the signal fires
    local thread = coroutine.running()
    local connection
    
    -- Create a connection that will resume the thread
    connection = self:Connect(function(...)
        connection:Disconnect()
        task.spawn(thread, ...)
    end)
    
    -- Yield the thread until resumed
    return coroutine.yield()
end

-- Disconnect all connections and clean up
function Signal:Destroy()
    if self._destroyed then return end
    
    -- Disconnect all connections
    for _, connection in ipairs(self._connections) do
        connection.Connected = false
    end
    
    -- Clear connections and mark as destroyed
    table.clear(self._connections)
    self._destroyed = true
end

return Signal

-- ========================== Core/Utils.lua ==========================
--[[
    Utility functions used throughout the library
]]
local Utils = {}

-- Services
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")

-- Tween a property of an instance
function Utils.Tween(instance, properties, duration, easingStyle, easingDirection, repeatCount, reverses, delayTime)
    -- Default values
    easingStyle = easingStyle or Enum.EasingStyle.Quad
    easingDirection = easingDirection or Enum.EasingDirection.Out
    repeatCount = repeatCount or 0
    reverses = reverses or false
    delayTime = delayTime or 0
    
    -- Create tween info
    local tweenInfo = TweenInfo.new(
        duration,
        easingStyle,
        easingDirection,
        repeatCount,
        reverses,
        delayTime
    )
    
    -- Create and play the tween
    local tween = TweenService:Create(instance, tweenInfo, properties)
    tween:Play()
    
    return tween
end

-- Get text bounds for a given text and text properties
function Utils.GetTextBounds(text, textProperties)
    return TextService:GetTextSize(
        text,
        textProperties.TextSize,
        textProperties.Font,
        Vector2.new(math.huge, math.huge)
    )
end

-- Create a unique identifier
function Utils.GenerateUID(length)
    length = length or 10
    local template = string.rep("x", length)
    
    return string.gsub(template, "x", function()
        local rand = math.random(0, 35)
        return string.format("%s", rand < 10 and rand or string.char(rand + 87))
    end)
end

-- Generate a GUID using HttpService
function Utils.GenerateGUID()
    return HttpService:GenerateGUID(false)
end

-- Deep copy a table
function Utils.DeepCopy(original)
    local copy = {}
    
    for k, v in pairs(original) do
        if type(v) == "table" then
            copy[k] = Utils.DeepCopy(v)
        else
            copy[k] = v
        end
    end
    
    return copy
end

-- Merge two tables
function Utils.MergeTables(target, source)
    for k, v in pairs(source) do
        if type(v) == "table" and type(target[k]) == "table" then
            Utils.MergeTables(target[k], v)
        else
            target[k] = v
        end
    end
    
    return target
end

-- Check if mouse is over a UI element
function Utils.IsMouseOverObject(object)
    local mouse = game:GetService("Players").LocalPlayer:GetMouse()
    local objectPosition = object.AbsolutePosition
    local objectSize = object.AbsoluteSize
    
    return (
        mouse.X >= objectPosition.X and
        mouse.X <= objectPosition.X + objectSize.X and
        mouse.Y >= objectPosition.Y and
        mouse.Y <= objectPosition.Y + objectSize.Y
    )
end

-- Format numbers with commas
function Utils.FormatNumber(number)
    local formatted = tostring(number)
    local k
    
    while true do
        formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
        if k == 0 then break end
    end
    
    return formatted
end

-- Clamp a value between min and max
function Utils.Clamp(value, min, max)
    return math.min(math.max(value, min), max)
end

-- Lerp between two values
function Utils.Lerp(a, b, t)
    return a + (b - a) * t
end

-- Color3 to hex string
function Utils.ColorToHex(color)
    return string.format(
        "#%02X%02X%02X",
        math.floor(color.R * 255 + 0.5),
        math.floor(color.G * 255 + 0.5),
        math.floor(color.B * 255 + 0.5)
    )
end

-- Hex string to Color3
function Utils.HexToColor(hex)
    hex = hex:gsub("#", "")
    
    return Color3.fromRGB(
        tonumber("0x" .. hex:sub(1, 2)),
        tonumber("0x" .. hex:sub(3, 4)),
        tonumber("0x" .. hex:sub(5, 6))
    )
end

-- Create a ripple effect for UI elements
function Utils.CreateRipple(parent)
    -- Create the ripple circle
    local ripple = Instance.new("Frame")
    ripple.Name = "Ripple"
    ripple.AnchorPoint = Vector2.new(0.5, 0.5)
    ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ripple.BackgroundTransparency = 0.8
    ripple.Position = UDim2.fromScale(0.5, 0.5)
    ripple.Size = UDim2.fromScale(0, 0)
    ripple.SizeConstraint = Enum.SizeConstraint.RelativeXY
    ripple.ZIndex = parent.ZIndex + 1
    
    -- Create corner to make it round
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = ripple
    
    ripple.Parent = parent
    
    -- Animate the ripple
    local targetSize = UDim2.fromScale(1.5, 1.5)
    Utils.Tween(ripple, {Size = targetSize, BackgroundTransparency = 1}, 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    
    -- Clean up after animation
    task.delay(0.5, function()
        ripple:Destroy()
    end)
    
    return ripple
end

-- Round corners of UI elements
function Utils.RoundCorners(instance, radius)
    radius = radius or UDim.new(0, 4)
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = radius
    corner.Parent = instance
    
    return corner
end

-- Add a stroke to UI elements
function Utils.AddStroke(instance, color, thickness, transparency)
    color = color or Color3.fromRGB(0, 0, 0)
    thickness = thickness or 1
    transparency = transparency or 0
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = color
    stroke.Thickness = thickness
    stroke.Transparency = transparency
    stroke.Parent = instance
    
    return stroke
end

-- Add padding to UI elements
function Utils.AddPadding(instance, padding)
    local uiPadding = Instance.new("UIPadding")
    
    if type(padding) == "number" then
        uiPadding.PaddingTop = UDim.new(0, padding)
        uiPadding.PaddingBottom = UDim.new(0, padding)
        uiPadding.PaddingLeft = UDim.new(0, padding)
        uiPadding.PaddingRight = UDim.new(0, padding)
    elseif type(padding) == "table" then
        uiPadding.PaddingTop = UDim.new(0, padding.Top or 0)
        uiPadding.PaddingBottom = UDim.new(0, padding.Bottom or 0)
        uiPadding.PaddingLeft = UDim.new(0, padding.Left or 0)
        uiPadding.PaddingRight = UDim.new(0, padding.Right or 0)
    end
    
    uiPadding.Parent = instance
    
    return uiPadding
end

-- Add list layout to UI elements
function Utils.AddListLayout(instance, padding, fillDirection, horizontalAlignment, verticalAlignment)
    padding = padding or 5
    fillDirection = fillDirection or Enum.FillDirection.Vertical
    horizontalAlignment = horizontalAlignment or Enum.HorizontalAlignment.Left
    verticalAlignment = verticalAlignment or Enum.VerticalAlignment.Top
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, padding)
    listLayout.FillDirection = fillDirection
    listLayout.HorizontalAlignment = horizontalAlignment
    listLayout.VerticalAlignment = verticalAlignment
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Parent = instance
    
    return listLayout
end

-- Create a shadow effect for UI elements
function Utils.CreateShadow(parent, shadowSize, transparency)
    shadowSize = shadowSize or 4
    transparency = transparency or 0.5
    
    local shadow = Instance.new("Frame")
    shadow.Name = "Shadow"
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    shadow.BackgroundTransparency = transparency
    shadow.BorderSizePixel = 0
    shadow.Position = UDim2.fromScale(0.5, 0.5)
    shadow.Size = UDim2.fromScale(1, 1) + UDim2.fromOffset(shadowSize, shadowSize)
    shadow.ZIndex = parent.ZIndex - 1
    
    -- Create corner to match parent
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = shadow
    
    shadow.Parent = parent
    
    return shadow
end

return Utils

-- ========================== Core/ThemeManager.lua ==========================
--[[
    Manages UI themes and allows for custom themes
]]
local ThemeManager = {}
ThemeManager.__index = ThemeManager

-- Built-in themes
ThemeManager.BuiltInThemes = {
    -- Dark theme (default)
    Dark = {
        Name = "Dark",
        -- Window
        Window = {
            Background = Color3.fromRGB(25, 25, 30),
            TopBar = Color3.fromRGB(35, 35, 40),
            AccentColor = Color3.fromRGB(90, 100, 240),
            TextColor = Color3.fromRGB(240, 240, 240),
            BorderColor = Color3.fromRGB(50, 50, 55),
            ShadowColor = Color3.fromRGB(0, 0, 0)
        },
        -- Tabs
        Tab = {
            Background = Color3.fromRGB(30, 30, 35),
            BackgroundSelected = Color3.fromRGB(40, 40, 45),
            TextColor = Color3.fromRGB(220, 220, 220),
            TextColorSelected = Color3.fromRGB(255, 255, 255)
        },
        -- Sections
        Section = {
            Background = Color3.fromRGB(35, 35, 40),
            TextColor = Color3.fromRGB(230, 230, 230),
            BorderColor = Color3.fromRGB(50, 50, 55)
        },
        -- Elements
        Element = {
            -- Button
            Button = {
                Background = Color3.fromRGB(45, 45, 50),
                BackgroundHover = Color3.fromRGB(55, 55, 60),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(60, 60, 65)
            },
            -- Toggle
            Toggle = {
                Background = Color3.fromRGB(45, 45, 50),
                BackgroundEnabled = Color3.fromRGB(90, 100, 240),
                TextColor = Color3.fromRGB(230, 230, 230),
                OuterBorderColor = Color3.fromRGB(60, 60, 65),
                InnerBorderColor = Color3.fromRGB(100, 100, 100),
                ToggleColor = Color3.fromRGB(255, 255, 255)
            },
            -- Slider
            Slider = {
                Background = Color3.fromRGB(45, 45, 50),
                BackgroundActive = Color3.fromRGB(90, 100, 240),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(60, 60, 65),
                SliderColor = Color3.fromRGB(255, 255, 255)
            },
            -- Dropdown
            Dropdown = {
                Background = Color3.fromRGB(45, 45, 50),
                BackgroundHover = Color3.fromRGB(55, 55, 60),
                SelectedBackground = Color3.fromRGB(60, 65, 75),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(60, 60, 65),
                DropdownIconColor = Color3.fromRGB(230, 230, 230)
            },
            -- Input
            Input = {
                Background = Color3.fromRGB(45, 45, 50),
                BackgroundFocused = Color3.fromRGB(55, 55, 60),
                TextColor = Color3.fromRGB(230, 230, 230),
                PlaceholderColor = Color3.fromRGB(180, 180, 180),
                BorderColor = Color3.fromRGB(60, 60, 65),
                BorderColorFocused = Color3.fromRGB(90, 100, 240)
            },
            -- Keybind
            Keybind = {
                Background = Color3.fromRGB(45, 45, 50),
                BackgroundActive = Color3.fromRGB(55, 55, 60),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(60, 60, 65),
                KeyTextColor = Color3.fromRGB(230, 230, 230)
            },
            -- ColorPicker
            ColorPicker = {
                Background = Color3.fromRGB(45, 45, 50),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(60, 60, 65),
                DropperColor = Color3.fromRGB(230, 230, 230)
            }
        },
        -- Extras
        Extra = {
            -- Notification
            Notification = {
                Background = Color3.fromRGB(35, 35, 40),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(50, 50, 55),
                AccentDefault = Color3.fromRGB(90, 100, 240),
                AccentSuccess = Color3.fromRGB(100, 200, 100),
                AccentError = Color3.fromRGB(220, 80, 80),
                AccentWarning = Color3.fromRGB(250, 180, 70),
                AccentInfo = Color3.fromRGB(90, 160, 255)
            },
            -- Prompt
            Prompt = {
                Background = Color3.fromRGB(35, 35, 40),
                TextColor = Color3.fromRGB(230, 230, 230),
                BorderColor = Color3.fromRGB(50, 50, 55),
                ButtonBackground = Color3.fromRGB(45, 45, 50),
                ButtonBackgroundHover = Color3.fromRGB(55, 55, 60),
                ButtonTextColor = Color3.fromRGB(230, 230, 230)
            }
        }
    },
    
    -- Light theme
    Light = {
        Name = "Light",
        -- Window
        Window = {
            Background = Color3.fromRGB(240, 240, 245),
            TopBar = Color3.fromRGB(225, 225, 230),
            AccentColor = Color3.fromRGB(70, 80, 220),
            TextColor = Color3.fromRGB(30, 30, 30),
            BorderColor = Color3.fromRGB(200, 200, 205),
            ShadowColor = Color3.fromRGB(180, 180, 180)
        },
        -- Tabs
        Tab = {
            Background = Color3.fromRGB(235, 235, 240),
            BackgroundSelected = Color3.fromRGB(225, 225, 230),
            TextColor = Color3.fromRGB(40, 40, 40),
            TextColorSelected = Color3.fromRGB(10, 10, 10)
        },
        -- Sections
        Section = {
            Background = Color3.fromRGB(230, 230, 235),
            TextColor = Color3.fromRGB(30, 30, 30),
            BorderColor = Color3.fromRGB(200, 200, 205)
        },
        -- Elements
        Element = {
            -- Button
            Button = {
                Background = Color3.fromRGB(220, 220, 225),
                BackgroundHover = Color3.fromRGB(210, 210, 215),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(190, 190, 195)
            },
            -- Toggle
            Toggle = {
                Background = Color3.fromRGB(220, 220, 225),
                BackgroundEnabled = Color3.fromRGB(70, 80, 220),
                TextColor = Color3.fromRGB(30, 30, 30),
                OuterBorderColor = Color3.fromRGB(190, 190, 195),
                InnerBorderColor = Color3.fromRGB(150, 150, 150),
                ToggleColor = Color3.fromRGB(255, 255, 255)
            },
            -- Slider
            Slider = {
                Background = Color3.fromRGB(220, 220, 225),
                BackgroundActive = Color3.fromRGB(70, 80, 220),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(190, 190, 195),
                SliderColor = Color3.fromRGB(255, 255, 255)
            },
            -- Dropdown
            Dropdown = {
                Background = Color3.fromRGB(220, 220, 225),
                BackgroundHover = Color3.fromRGB(210, 210, 215),
                SelectedBackground = Color3.fromRGB(200, 205, 215),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(190, 190, 195),
                DropdownIconColor = Color3.fromRGB(30, 30, 30)
            },
            -- Input
            Input = {
                Background = Color3.fromRGB(220, 220, 225),
                BackgroundFocused = Color3.fromRGB(210, 210, 215),
                TextColor = Color3.fromRGB(30, 30, 30),
                PlaceholderColor = Color3.fromRGB(100, 100, 100),
                BorderColor = Color3.fromRGB(190, 190, 195),
                BorderColorFocused = Color3.fromRGB(70, 80, 220)
            },
            -- Keybind
            Keybind = {
                Background = Color3.fromRGB(220, 220, 225),
                BackgroundActive = Color3.fromRGB(210, 210, 215),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(190, 190, 195),
                KeyTextColor = Color3.fromRGB(30, 30, 30)
            },
            -- ColorPicker
            ColorPicker = {
                Background = Color3.fromRGB(220, 220, 225),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(190, 190, 195),
                DropperColor = Color3.fromRGB(30, 30, 30)
            }
        },
        -- Extras
        Extra = {
            -- Notification
            Notification = {
                Background = Color3.fromRGB(230, 230, 235),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(200, 200, 205),
                AccentDefault = Color3.fromRGB(70, 80, 220),
                AccentSuccess = Color3.fromRGB(80, 180, 80),
                AccentError = Color3.fromRGB(200, 60, 60),
                AccentWarning = Color3.fromRGB(230, 160, 50),
                AccentInfo = Color3.fromRGB(70, 140, 235)
            },
            -- Prompt
            Prompt = {
                Background = Color3.fromRGB(230, 230, 235),
                TextColor = Color3.fromRGB(30, 30, 30),
                BorderColor = Color3.fromRGB(200, 200, 205),
                ButtonBackground = Color3.fromRGB(220, 220, 225),
                ButtonBackgroundHover = Color3.fromRGB(210, 210, 215),
                ButtonTextColor = Color3.fromRGB(30, 30, 30)
            }
        }
    },
    
    -- Nebula theme (custom theme)
    Nebula = {
        Name = "Nebula",
        -- Window
        Window = {
            Background = Color3.fromRGB(20, 20, 30),
            TopBar = Color3.fromRGB(30, 30, 45),
            AccentColor = Color3.fromRGB(110, 70, 235),
            TextColor = Color3.fromRGB(240, 240, 250),
            BorderColor = Color3.fromRGB(40, 40, 60),
            ShadowColor = Color3.fromRGB(0, 0, 10)
        },
        -- Tabs
        Tab = {
            Background = Color3.fromRGB(25, 25, 35),
            BackgroundSelected = Color3.fromRGB(35, 35, 50),
            TextColor = Color3.fromRGB(220, 220, 230),
            TextColorSelected = Color3.fromRGB(255, 255, 255)
        },
        -- Sections
        Section = {
            Background = Color3.fromRGB(30, 30, 45),
            TextColor = Color3.fromRGB(230, 230, 240),
            BorderColor = Color3.fromRGB(45, 45, 65)
        },
        -- Elements
        Element = {
            -- Button
            Button = {
                Background = Color3.fromRGB(40, 40, 60),
                BackgroundHover = Color3.fromRGB(50, 50, 70),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(55, 55, 75)
            },
            -- Toggle
            Toggle = {
                Background = Color3.fromRGB(40, 40, 60),
                BackgroundEnabled = Color3.fromRGB(110, 70, 235),
                TextColor = Color3.fromRGB(230, 230, 240),
                OuterBorderColor = Color3.fromRGB(55, 55, 75),
                InnerBorderColor = Color3.fromRGB(90, 90, 110),
                ToggleColor = Color3.fromRGB(255, 255, 255)
            },
            -- Slider
            Slider = {
                Background = Color3.fromRGB(40, 40, 60),
                BackgroundActive = Color3.fromRGB(110, 70, 235),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(55, 55, 75),
                SliderColor = Color3.fromRGB(255, 255, 255)
            },
            -- Dropdown
            Dropdown = {
                Background = Color3.fromRGB(40, 40, 60),
                BackgroundHover = Color3.fromRGB(50, 50, 70),
                SelectedBackground = Color3.fromRGB(55, 55, 80),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(55, 55, 75),
                DropdownIconColor = Color3.fromRGB(230, 230, 240)
            },
            -- Input
            Input = {
                Background = Color3.fromRGB(40, 40, 60),
                BackgroundFocused = Color3.fromRGB(50, 50, 70),
                TextColor = Color3.fromRGB(230, 230, 240),
                PlaceholderColor = Color3.fromRGB(170, 170, 190),
                BorderColor = Color3.fromRGB(55, 55, 75),
                BorderColorFocused = Color3.fromRGB(110, 70, 235)
            },
            -- Keybind
            Keybind = {
                Background = Color3.fromRGB(40, 40, 60),
                BackgroundActive = Color3.fromRGB(50, 50, 70),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(55, 55, 75),
                KeyTextColor = Color3.fromRGB(230, 230, 240)
            },
            -- ColorPicker
            ColorPicker = {
                Background = Color3.fromRGB(40, 40, 60),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(55, 55, 75),
                DropperColor = Color3.fromRGB(230, 230, 240)
            }
        },
        -- Extras
        Extra = {
            -- Notification
            Notification = {
                Background = Color3.fromRGB(30, 30, 45),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(45, 45, 65),
                AccentDefault = Color3.fromRGB(110, 70, 235),
                AccentSuccess = Color3.fromRGB(90, 210, 90),
                AccentError = Color3.fromRGB(230, 70, 70),
                AccentWarning = Color3.fromRGB(240, 170, 60),
                AccentInfo = Color3.fromRGB(80, 150, 250)
            },
            -- Prompt
            Prompt = {
                Background = Color3.fromRGB(30, 30, 45),
                TextColor = Color3.fromRGB(230, 230, 240),
                BorderColor = Color3.fromRGB(45, 45, 65),
                ButtonBackground = Color3.fromRGB(40, 40, 60),
                ButtonBackgroundHover = Color3.fromRGB(50, 50, 70),
                ButtonTextColor = Color3.fromRGB(230, 230, 240)
            }
        }
    }
}

-- Current theme
ThemeManager.CurrentTheme = nil

-- Custom themes added by the user
ThemeManager.CustomThemes = {}

-- Initialize the theme manager
function ThemeManager:Initialize()
    -- Default to dark theme
    self.CurrentTheme = self.BuiltInThemes.Dark
    
    -- Create a signal for theme changes
    self.ThemeChanged = require(script.Parent.Signal).new()
    
    return self
end

-- Get the current theme
function ThemeManager:GetTheme()
    return self.CurrentTheme
end

-- Set the current theme
function ThemeManager:SetTheme(themeName)
    local theme = self:FindTheme(themeName)
    
    if theme then
        self.CurrentTheme = theme
        self.ThemeChanged:Fire(theme)
        return true
    end
    
    return false
end

-- Find a theme by name
function ThemeManager:FindTheme(themeName)
    -- Check built-in themes
    for _, theme in pairs(self.BuiltInThemes) do
        if theme.Name:lower() == themeName:lower() then
            return theme
        end
    end
    
    -- Check custom themes
    for _, theme in pairs(self.CustomThemes) do
        if theme.Name:lower() == themeName:lower() then
            return theme
        end
    end
    
    return nil
end

-- Create a custom theme
function ThemeManager:CreateTheme(name, baseTheme)
    -- Check if theme already exists
    if self:FindTheme(name) then
        error("Theme with name '" .. name .. "' already exists")
    end
    
    -- Use dark theme as base if none provided
    baseTheme = baseTheme or "Dark"
    
    -- Get the base theme
    local base = self:FindTheme(baseTheme)
    if not base then
        error("Base theme '" .. baseTheme .. "' does not exist")
    end
    
    -- Create a deep copy of the base theme
    local theme = require(script.Parent.Utils).DeepCopy(base)
    theme.Name = name
    
    -- Add to custom themes
    self.CustomThemes[name] = theme
    
    return theme
end

-- Delete a custom theme
function ThemeManager:DeleteTheme(name)
    -- Check if theme exists
    local theme = self:FindTheme(name)
    if not theme then
        return false
    end
    
    -- Check if it's a built-in theme
    for _, builtInTheme in pairs(self.BuiltInThemes) do
        if builtInTheme.Name == name then
            error("Cannot delete built-in theme '" .. name .. "'")
        end
    end
    
    -- Remove from custom themes
    self.CustomThemes[name] = nil
    
    -- Switch to dark theme if current theme was deleted
    if self.CurrentTheme.Name == name then
        self:SetTheme("Dark")
    end
    
    return true
end

-- Modify a theme property
function ThemeManager:ModifyTheme(themeName, propertyPath, value)
    local theme = self:FindTheme(themeName)
    if not theme then
        error("Theme '" .. themeName .. "' does not exist")
    end
    
    -- Parse property path
    local pathParts = string.split(propertyPath, ".")
    local current = theme
    
    -- Navigate to the parent object
    for i = 1, #pathParts - 1 do
        local part = pathParts[i]
        if current[part] == nil then
            error("Invalid property path: " .. propertyPath)
        end
        current = current[part]
    end
    
    -- Set the property
    local lastPart = pathParts[#pathParts]
    current[lastPart] = value
    
    -- Fire theme changed event if this is the current theme
    if theme.Name == self.CurrentTheme.Name then
        self.ThemeChanged:Fire(theme)
    end
    
    return true
end

-- Export a theme to JSON
function ThemeManager:ExportTheme(themeName)
    local theme = self:FindTheme(themeName)
    if not theme then
        error("Theme '" .. themeName .. "' does not exist")
    end
    
    return game:GetService("HttpService"):JSONEncode(theme)
end

-- Import a theme from JSON
function ThemeManager:ImportTheme(themeJson)
    local success, theme = pcall(function()
        return game:GetService("HttpService"):JSONDecode(themeJson)
    end)
    
    if not success or not theme.Name then
        error("Invalid theme JSON")
    end
    
    -- Check if theme already exists
    if self:FindTheme(theme.Name) then
        error("Theme with name '" .. theme.Name .. "' already exists")
    end
    
    -- Add to custom themes
    self.CustomThemes[theme.Name] = theme
    
    return theme
end

return ThemeManager

-- ========================== Core/Drag.lua ==========================
--[[
    Handles dragging functionality for UI elements
]]
local Drag = {}
Drag.__index = Drag

-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Constants
local DRAG_SPEED = 0.1
local DRAG_SENSITIVITY = 0.5

-- Create a new draggable instance
function Drag.new(frame, handle)
    local self = setmetatable({}, Drag)
    
    -- Store references
    self.Frame = frame
    self.Handle = handle or frame
    
    -- State
    self.Dragging = false
    self.DragInput = nil
    self.DragStart = nil
    self.StartPosition = nil
    self.Connections = {}
    
    -- Set up connections
    self:SetupConnections()
    
    -- Return the object
    return self
end

-- Set up input connections
function Drag:SetupConnections()
    -- Input began connection
    table.insert(self.Connections, self.Handle.InputBegan:Connect(function(input)
        self:OnInputBegan(input)
    end))
    
    -- Input changed connection
    table.insert(self.Connections, UserInputService.InputChanged:Connect(function(input)
        self:OnInputChanged(input)
    end))
    
    -- Input ended connection
    table.insert(self.Connections, UserInputService.InputEnded:Connect(function(input)
        self:OnInputEnded(input)
    end))
end

-- Handle input began event
function Drag:OnInputBegan(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        -- Start dragging
        self.Dragging = true
        self.DragStart = input.Position
        self.StartPosition = self.Frame.Position
        
        -- Consume input
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                self.Dragging = false
            end
        end)
    end
end

-- Handle input changed event
function Drag:OnInputChanged(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        self.DragInput = input
    end
end

-- Handle input ended event
function Drag:OnInputEnded(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        -- Stop dragging
        self.Dragging = false
        self.DragInput = nil
        self.DragStart = nil
    end
end

-- Update the dragging position
function Drag:Update()
    if self.Dragging and self.DragInput and self.DragStart then
        -- Calculate new position
        local delta = self.DragInput.Position - self.DragStart
        
        -- Apply drag sensitivity
        delta = delta * DRAG_SENSITIVITY
        
        -- Create tween to new position
        local position = UDim2.new(
            self.StartPosition.X.Scale,
            self.StartPosition.X.Offset + delta.X,
            self.StartPosition.Y.Scale,
            self.StartPosition.Y.Offset + delta.Y
        )
        
        -- Tween to new position for smooth dragging
        local tweenInfo = TweenInfo.new(DRAG_SPEED, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        TweenService:Create(self.Frame, tweenInfo, {Position = position}):Play()
    end
end

-- Enable dragging
function Drag:Enable()
    -- Set up connections if they're not already set up
    if #self.Connections == 0 then
        self:SetupConnections()
    end
    
    -- Set up update loop
    self.UpdateConnection = RunService.RenderStepped:Connect(function()
        self:Update()
    end)
end

-- Disable dragging
function Drag:Disable()
    -- Disconnect connections
    for _, connection in ipairs(self.Connections) do
        connection:Disconnect()
    end
    
    -- Clear connections
    table.clear(self.Connections)
    
    -- Disconnect update loop
    if self.UpdateConnection then
        self.UpdateConnection:Disconnect()
        self.UpdateConnection = nil
    end
    
    -- Reset state
    self.Dragging = false
    self.DragInput = nil
    self.DragStart = nil
    self.StartPosition = nil
end

-- Clean up and destroy
function Drag:Destroy()
    self:Disable()
end

-- Set up a draggable frame
function Drag.Enable(frame, handle)
    local dragger = Drag.new(frame, handle)
    dragger:Enable()
    return dragger
end

return Drag

-- ========================== Core/Config.lua ==========================
--[[
    Configuration settings for the UI library
]]
local Config = {
    -- Library name
    LibraryName = "NebulaUI",
    
    -- Library version
    Version = "1.0.0",
    
    -- Default theme
    DefaultTheme = "Nebula",
    
    -- Window settings
    Window = {
        -- Minimum size constraints
        MinSize = Vector2.new(400, 300),
        
        -- Default size
        DefaultSize = Vector2.new(550, 400),
        
        -- Padding
        Padding = 8,
        
        -- Corner radius
        CornerRadius = UDim.new(0, 6),
        
        -- Title bar height
        TitleBarHeight = 28,
        
        -- Shadow size and transparency
        ShadowSize = 6,
        ShadowTransparency = 0.5,
        
        -- Animation durations
        AnimationDuration = 0.2,
        
        -- Border width
        BorderWidth = 1,
        
        -- Title font
        TitleFont = Enum.Font.GothamBold,
        TitleTextSize = 14,
        
        -- Tab button size
        TabButtonHeight = 30,
        TabButtonTextSize = 12,
        TabButtonFont = Enum.Font.Gotham,
        
        -- Resize handle size
        ResizeHandleSize = 12
    },
    
    -- Section settings
    Section = {
        -- Default size
        DefaultHeight = 36,
        
        -- Corner radius
        CornerRadius = UDim.new(0, 4),
        
        -- Padding
        Padding = 6,
        
        -- Header height
        HeaderHeight = 24,
        
        -- Header font
        HeaderFont = Enum.Font.GothamSemibold,
        HeaderTextSize = 12,
        
        -- Border width
        BorderWidth = 1,
        
        -- Animation duration
        AnimationDuration = 0.2
    },
    
    -- Element settings
    Element = {
        -- Common element settings
        Height = 32,
        CornerRadius = UDim.new(0, 4),
        Padding = 8,
        TextSize = 12,
        Font = Enum.Font.Gotham,
        BorderWidth = 1,
        AnimationDuration = 0.15,
        
        -- Button
        Button = {
            HoverTransparency = 0.9
        },
        
        -- Toggle
        Toggle = {
            BoxSize = 16,
            BoxCornerRadius = UDim.new(0, 3),
            InnerBoxPadding = 2,
            ToggleAnimationDuration = 0.1
        },
        
        -- Slider
        Slider = {
            SliderHeight = 6,
            KnobSize = 12,
            KnobCornerRadius = UDim.new(0, 6),
            ValueTextSize = 10,
            DecimalPrecision = 1
        },
        
        -- Dropdown
        Dropdown = {
            MaxVisibleItems = 8,
            ItemHeight = 28,
            DropdownAnimationDuration = 0.2,
            ScrollBarWidth = 4
        },
        
        -- Keybind
        Keybind = {
            KeyTextSize = 10,
            ListenText = "..."
        },
        
        -- ColorPicker
        ColorPicker = {
            SwatchSize = 18,
            SwatchCornerRadius = UDim.new(0, 3),
            PickerWidth = 200,
            PickerHeight = 150,
            HueSliderWidth = 12,
            AlphaSliderHeight = 12,
            PreviewSwatchSize = 24
        }
    },
    
    -- Extra settings
    Extra = {
        -- Notification
        Notification = {
            Width = 260,
            MinHeight = 60,
            CornerRadius = UDim.new(0, 5),
            BorderWidth = 1,
            Padding = 10,
            IconSize = 20,
            TitleTextSize = 12,
            TitleFont = Enum.Font.GothamBold,
            TextSize = 11,
            TextFont = Enum.Font.Gotham,
            Duration = 3,
            AnimationDuration = 0.2,
            Position = UDim2.new(1, -20, 1, -20),
            StackSpacing = 10
        },
        
        -- Prompt
        Prompt = {
            Width = 300,
            MinHeight = 100,
            CornerRadius = UDim.new(0, 6),
            BorderWidth = 1,
            Padding = 12,
            TitleTextSize = 14,
            TitleFont = Enum.Font.GothamBold,
            TextSize = 12,
            TextFont = Enum.Font.Gotham,
            ButtonHeight = 32,
            ButtonCornerRadius = UDim.new(0, 4),
            ButtonTextSize = 12,
            ButtonFont = Enum.Font.GothamSemibold,
            AnimationDuration = 0.2
        },
        
        -- Save System
        SaveSystem = {
            AutoSaveInterval = 30,
            ConfigFolder = "NebulaUI",
            DefaultConfigName = "Default",
            UseDataStoreService = false
        }
    }
}

return Config

-- ========================== Components/Button.lua ==========================
--[[
    Button component for the UI library
]]
local Button = {}
Button.__index = Button

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Dependencies
local RunService = game:GetService("RunService")
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config

-- Create a new button instance
function Button.new(parent, options)
    -- Load dependencies when first created
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
    end
    
    local self = setmetatable({}, Button)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "Button"
    self.Callback = options.Callback or function() end
    self.Text = options.Text or "Button"
    self.ToolTip = options.ToolTip
    self.TextXAlignment = options.TextXAlignment or Enum.TextXAlignment.Center
    self.Disabled = options.Disabled or false
    self.CustomTheme = options.CustomTheme
    
    -- Create button UI
    self:Create(parent)
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Initialize states
    self:UpdateState()
    
    return self
end

-- Create button UI elements
function Button:Create(parent)
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_Button"
    self.Container.BackgroundTransparency = 1
    self.Container.Size = UDim2.new(1, 0, 0, Config.Element.Height)
    self.Container.Parent = parent
    
    -- Button frame
    self.ButtonFrame = Instance.new("Frame")
    self.ButtonFrame.Name = "ButtonFrame"
    self.ButtonFrame.Size = UDim2.new(1, 0, 1, 0)
    self.ButtonFrame.BackgroundColor3 = self:GetTheme().Button.Background
    self.ButtonFrame.Parent = self.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.ButtonFrame, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.ButtonFrame,
        self:GetTheme().Button.BorderColor,
        Config.Element.BorderWidth
    )
    
    -- Button text
    self.TextLabel = Instance.new("TextLabel")
    self.TextLabel.Name = "ButtonText"
    self.TextLabel.BackgroundTransparency = 1
    self.TextLabel.Size = UDim2.new(1, -Config.Element.Padding * 2, 1, 0)
    self.TextLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    self.TextLabel.Font = Config.Element.Font
    self.TextLabel.TextSize = Config.Element.TextSize
    self.TextLabel.TextColor3 = self:GetTheme().Button.TextColor
    self.TextLabel.Text = self.Text
    self.TextLabel.TextXAlignment = self.TextXAlignment
    self.TextLabel.Parent = self.ButtonFrame
    
    -- Hover overlay
    self.HoverOverlay = Instance.new("Frame")
    self.HoverOverlay.Name = "HoverOverlay"
    self.HoverOverlay.Size = UDim2.fromScale(1, 1)
    self.HoverOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HoverOverlay.BackgroundTransparency = 1
    self.HoverOverlay.ZIndex = 2
    self.HoverOverlay.Parent = self.ButtonFrame
    
    -- Add corner to overlay
    Utils.RoundCorners(self.HoverOverlay, UDim.new(0, Config.Element.CornerRadius.Offset))
end

-- Set up event connections
function Button:SetupConnections()
    -- Mouse enter
    self.MouseEnterConnection = self.ButtonFrame.MouseEnter:Connect(function()
        if not self.Disabled then
            self:OnMouseEnter()
        end
    end)
    
    -- Mouse leave
    self.MouseLeaveConnection = self.ButtonFrame.MouseLeave:Connect(function()
        if not self.Disabled then
            self:OnMouseLeave()
        end
    end)
    
    -- Mouse button 1 down
    self.MouseDownConnection = self.ButtonFrame.MouseButton1Down:Connect(function()
        if not self.Disabled then
            self:OnMouseDown()
        end
    end)
    
    -- Mouse button 1 up
    self.MouseUpConnection = self.ButtonFrame.MouseButton1Up:Connect(function()
        if not self.Disabled then
            self:OnMouseUp()
        end
    end)
    
    -- Mouse button 1 click
    self.MouseClickConnection = self.ButtonFrame.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:OnClick()
        end
    end)
    
    -- Theme changed
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Get current theme
function Button:GetTheme()
    return self.CustomTheme or ThemeManager:GetTheme().Element
end

-- Update button theme
function Button:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors based on theme
    self.ButtonFrame.BackgroundColor3 = self:GetTheme().Button.Background
    self.TextLabel.TextColor3 = self:GetTheme().Button.TextColor
    self.Stroke.Color = self:GetTheme().Button.BorderColor
    
    -- Update state
    self:UpdateState()
end

-- Handle mouse enter
function Button:OnMouseEnter()
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 0.9},
        Config.Element.AnimationDuration
    )
    
    -- Tween background
    Utils.Tween(
        self.ButtonFrame,
        {BackgroundColor3 = self:GetTheme().Button.BackgroundHover},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse leave
function Button:OnMouseLeave()
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 1},
        Config.Element.AnimationDuration
    )
    
    -- Tween background
    Utils.Tween(
        self.ButtonFrame,
        {BackgroundColor3 = self:GetTheme().Button.Background},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse down
function Button:OnMouseDown()
    -- Tween button down effect
    Utils.Tween(
        self.ButtonFrame,
        {Size = UDim2.new(0.98, 0, 0.95, 0)},
        Config.Element.AnimationDuration * 0.5,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    
    Utils.Tween(
        self.ButtonFrame,
        {Position = UDim2.new(0.01, 0, 0.025, 0)},
        Config.Element.AnimationDuration * 0.5,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    
    -- Create ripple effect
    Utils.CreateRipple(self.ButtonFrame)
end

-- Handle mouse up
function Button:OnMouseUp()
    -- Tween button up effect
    Utils.Tween(
        self.ButtonFrame,
        {Size = UDim2.fromScale(1, 1)},
        Config.Element.AnimationDuration * 0.5,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    
    Utils.Tween(
        self.ButtonFrame,
        {Position = UDim2.fromScale(0, 0)},
        Config.Element.AnimationDuration * 0.5,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
end

-- Handle click
function Button:OnClick()
    -- Call the callback
    task.spawn(self.Callback)
end

-- Set button text
function Button:SetText(text)
    self.Text = text
    self.TextLabel.Text = text
end

-- Set button disabled state
function Button:SetDisabled(disabled)
    self.Disabled = disabled
    self:UpdateState()
end

-- Update visual state based on disabled property
function Button:UpdateState()
    if self.Disabled then
        -- Disabled state
        self.ButtonFrame.BackgroundColor3 = self:GetTheme().Button.Background
        self.TextLabel.TextColor3 = self:GetTheme().Button.TextColor
        self.TextLabel.TextTransparency = 0.5
        self.ButtonFrame.BackgroundTransparency = 0.5
        self.Stroke.Transparency = 0.5
    else
        -- Enabled state
        self.ButtonFrame.BackgroundColor3 = self:GetTheme().Button.Background
        self.TextLabel.TextColor3 = self:GetTheme().Button.TextColor
        self.TextLabel.TextTransparency = 0
        self.ButtonFrame.BackgroundTransparency = 0
        self.Stroke.Transparency = 0
    end
end

-- Clean up
function Button:Destroy()
    -- Disconnect event connections
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.MouseDownConnection then
        self.MouseDownConnection:Disconnect()
    end
    
    if self.MouseUpConnection then
        self.MouseUpConnection:Disconnect()
    end
    
    if self.MouseClickConnection then
        self.MouseClickConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return Button

-- ========================== Components/Toggle.lua ==========================
--[[
    Toggle component for the UI library
]]
local Toggle = {}
Toggle.__index = Toggle

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal

-- Create a new toggle instance
function Toggle.new(parent, options)
    -- Load dependencies when first created
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
    end
    
    local self = setmetatable({}, Toggle)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "Toggle"
    self.Text = options.Text or "Toggle"
    self.Default = options.Default or false
    self.Callback = options.Callback or function() end
    self.ToolTip = options.ToolTip
    self.Disabled = options.Disabled or false
    self.CustomTheme = options.CustomTheme
    
    -- Internal state
    self.Enabled = self.Default
    self.Hovering = false
    
    -- Events
    self.OnChanged = Signal.new()
    
    -- Create toggle UI
    self:Create(parent)
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Initialize states
    self:UpdateState()
    
    return self
end

-- Create toggle UI elements
function Toggle:Create(parent)
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_Toggle"
    self.Container.BackgroundTransparency = 1
    self.Container.Size = UDim2.new(1, 0, 0, Config.Element.Height)
    self.Container.Parent = parent
    
    -- Toggle frame
    self.ToggleFrame = Instance.new("Frame")
    self.ToggleFrame.Name = "ToggleFrame"
    self.ToggleFrame.Size = UDim2.new(1, 0, 1, 0)
    self.ToggleFrame.BackgroundColor3 = self:GetTheme().Toggle.Background
    self.ToggleFrame.BackgroundTransparency = 0
    self.ToggleFrame.Parent = self.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.ToggleFrame, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.ToggleFrame,
        self:GetTheme().Toggle.OuterBorderColor,
        Config.Element.BorderWidth
    )
    
    -- Label
    self.TextLabel = Instance.new("TextLabel")
    self.TextLabel.Name = "ToggleText"
    self.TextLabel.BackgroundTransparency = 1
    self.TextLabel.Size = UDim2.new(1, -(Config.Element.Toggle.BoxSize + Config.Element.Padding * 3), 1, 0)
    self.TextLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    self.TextLabel.Font = Config.Element.Font
    self.TextLabel.TextSize = Config.Element.TextSize
    self.TextLabel.TextColor3 = self:GetTheme().Toggle.TextColor
    self.TextLabel.Text = self.Text
    self.TextLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TextLabel.Parent = self.ToggleFrame
    
    -- Toggle box outer
    self.ToggleBox = Instance.new("Frame")
    self.ToggleBox.Name = "ToggleBox"
    self.ToggleBox.Size = UDim2.fromOffset(Config.Element.Toggle.BoxSize, Config.Element.Toggle.BoxSize)
    self.ToggleBox.Position = UDim2.new(1, -Config.Element.Toggle.BoxSize - Config.Element.Padding, 0.5, -Config.Element.Toggle.BoxSize / 2)
    self.ToggleBox.BackgroundColor3 = self:GetTheme().Toggle.Background
    self.ToggleBox.BackgroundTransparency = 0
    self.ToggleBox.Parent = self.ToggleFrame
    
    -- Add corner to toggle box
    self.ToggleBoxCorner = Utils.RoundCorners(self.ToggleBox, Config.Element.Toggle.BoxCornerRadius)
    
    -- Add stroke to toggle box
    self.ToggleBoxStroke = Utils.AddStroke(
        self.ToggleBox,
        self:GetTheme().Toggle.InnerBorderColor,
        Config.Element.BorderWidth
    )
    
    -- Toggle box inner (fill)
    self.ToggleFill = Instance.new("Frame")
    self.ToggleFill.Name = "ToggleFill"
    local fillSize = Config.Element.Toggle.BoxSize - (Config.Element.Toggle.InnerBoxPadding * 2)
    self.ToggleFill.Size = UDim2.fromOffset(fillSize, fillSize)
    self.ToggleFill.Position = UDim2.fromOffset(Config.Element.Toggle.InnerBoxPadding, Config.Element.Toggle.InnerBoxPadding)
    self.ToggleFill.BackgroundColor3 = self:GetTheme().Toggle.BackgroundEnabled
    self.ToggleFill.BackgroundTransparency = 1
    self.ToggleFill.Parent = self.ToggleBox
    
    -- Add corner to toggle fill
    self.ToggleFillCorner = Utils.RoundCorners(self.ToggleFill, Config.Element.Toggle.BoxCornerRadius)
    
    -- Hover overlay
    self.HoverOverlay = Instance.new("Frame")
    self.HoverOverlay.Name = "HoverOverlay"
    self.HoverOverlay.Size = UDim2.fromScale(1, 1)
    self.HoverOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HoverOverlay.BackgroundTransparency = 1
    self.HoverOverlay.ZIndex = 2
    self.HoverOverlay.Parent = self.ToggleFrame
    
    -- Add corner to overlay
    Utils.RoundCorners(self.HoverOverlay, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Create detection button
    self.Button = Instance.new("TextButton")
    self.Button.Name = "ToggleButton"
    self.Button.Size = UDim2.fromScale(1, 1)
    self.Button.BackgroundTransparency = 1
    self.Button.Text = ""
    self.Button.ZIndex = 3
    self.Button.Parent = self.ToggleFrame
end

-- Set up event connections
function Toggle:SetupConnections()
    -- Mouse enter
    self.MouseEnterConnection = self.ToggleFrame.MouseEnter:Connect(function()
        if not self.Disabled then
            self:OnMouseEnter()
        end
    end)
    
    -- Mouse leave
    self.MouseLeaveConnection = self.ToggleFrame.MouseLeave:Connect(function()
        if not self.Disabled then
            self:OnMouseLeave()
        end
    end)
    
    -- Button pressed
    self.ButtonPressedConnection = self.Button.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:Toggle()
        end
    end)
    
    -- Theme changed
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Get current theme
function Toggle:GetTheme()
    return self.CustomTheme or ThemeManager:GetTheme().Element
end

-- Update toggle theme
function Toggle:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors based on theme
    self.ToggleFrame.BackgroundColor3 = self:GetTheme().Toggle.Background
    self.TextLabel.TextColor3 = self:GetTheme().Toggle.TextColor
    self.Stroke.Color = self:GetTheme().Toggle.OuterBorderColor
    self.ToggleBox.BackgroundColor3 = self:GetTheme().Toggle.Background
    self.ToggleBoxStroke.Color = self:GetTheme().Toggle.InnerBorderColor
    self.ToggleFill.BackgroundColor3 = self:GetTheme().Toggle.BackgroundEnabled
    
    -- Update state
    self:UpdateState()
end

-- Handle mouse enter
function Toggle:OnMouseEnter()
    self.Hovering = true
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 0.9},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse leave
function Toggle:OnMouseLeave()
    self.Hovering = false
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 1},
        Config.Element.AnimationDuration
    )
end

-- Toggle the state
function Toggle:Toggle()
    self.Enabled = not self.Enabled
    self:UpdateState()
    
    -- Create ripple effect
    Utils.CreateRipple(self.ToggleFrame)
    
    -- Call callback
    task.spawn(function()
        self.Callback(self.Enabled)
    end)
    
    -- Fire change event
    self.OnChanged:Fire(self.Enabled)
end

-- Set value directly
function Toggle:SetValue(value)
    if self.Enabled ~= value then
        self.Enabled = value
        self:UpdateState()
        
        -- Fire change event
        self.OnChanged:Fire(self.Enabled)
    end
end

-- Set toggle disabled state
function Toggle:SetDisabled(disabled)
    self.Disabled = disabled
    self:UpdateState()
end

-- Set toggle text
function Toggle:SetText(text)
    self.Text = text
    self.TextLabel.Text = text
end

-- Update visual state based on properties
function Toggle:UpdateState()
    if self.Disabled then
        -- Disabled state
        self.ToggleFrame.BackgroundColor3 = self:GetTheme().Toggle.Background
        self.TextLabel.TextColor3 = self:GetTheme().Toggle.TextColor
        self.TextLabel.TextTransparency = 0.5
        self.ToggleFrame.BackgroundTransparency = 0.5
        self.Stroke.Transparency = 0.5
        self.ToggleBox.BackgroundTransparency = 0.5
        self.ToggleBoxStroke.Transparency = 0.5
        
        -- Toggle fill state when disabled
        if self.Enabled then
            self.ToggleFill.BackgroundTransparency = 0.5
        else
            self.ToggleFill.BackgroundTransparency = 1
        end
    else
        -- Enabled state
        self.ToggleFrame.BackgroundColor3 = self:GetTheme().Toggle.Background
        self.TextLabel.TextColor3 = self:GetTheme().Toggle.TextColor
        self.TextLabel.TextTransparency = 0
        self.ToggleFrame.BackgroundTransparency = 0
        self.Stroke.Transparency = 0
        self.ToggleBox.BackgroundTransparency = 0
        self.ToggleBoxStroke.Transparency = 0
        
        -- Toggle fill state
        if self.Enabled then
            self.ToggleFill.BackgroundTransparency = 0
        else
            self.ToggleFill.BackgroundTransparency = 1
        end
    end
end

-- Clean up
function Toggle:Destroy()
    -- Disconnect event connections
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.ButtonPressedConnection then
        self.ButtonPressedConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Clean up events
    self.OnChanged:Destroy()
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return Toggle

-- ========================== Components/Slider.lua ==========================
--[[
    Slider component for the UI library
]]
local Slider = {}
Slider.__index = Slider

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal

-- Create a new slider instance
function Slider.new(parent, options)
    -- Load dependencies when first created
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
    end
    
    local self = setmetatable({}, Slider)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "Slider"
    self.Text = options.Text or "Slider"
    self.Min = options.Min or 0
    self.Max = options.Max or 100
    self.Default = options.Default or self.Min
    self.Increment = options.Increment or 1
    self.ValueSuffix = options.ValueSuffix or ""
    self.ValuePrefix = options.ValuePrefix or ""
    self.Callback = options.Callback or function() end
    self.ToolTip = options.ToolTip
    self.Disabled = options.Disabled or false
    self.CustomTheme = options.CustomTheme
    
    -- Validate min/max
    if self.Min > self.Max then
        local temp = self.Min
        self.Min = self.Max
        self.Max = temp
    end
    
    -- Validate default value
    self.Value = math.clamp(self.Default, self.Min, self.Max)
    
    -- Internal state
    self.Dragging = false
    self.Hovering = false
    
    -- Events
    self.OnChanged = Signal.new()
    
    -- Create slider UI
    self:Create(parent)
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Initialize states
    self:UpdateState()
    
    return self
end

-- Create slider UI elements
function Slider:Create(parent)
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_Slider"
    self.Container.BackgroundTransparency = 1
    self.Container.Size = UDim2.new(1, 0, 0, Config.Element.Height)
    self.Container.Parent = parent
    
    -- Slider frame
    self.SliderFrame = Instance.new("Frame")
    self.SliderFrame.Name = "SliderFrame"
    self.SliderFrame.Size = UDim2.new(1, 0, 1, 0)
    self.SliderFrame.BackgroundColor3 = self:GetTheme().Slider.Background
    self.SliderFrame.BackgroundTransparency = 0
    self.SliderFrame.Parent = self.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.SliderFrame, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.SliderFrame,
        self:GetTheme().Slider.BorderColor,
        Config.Element.BorderWidth
    )
    
    -- Title label
    self.TextLabel = Instance.new("TextLabel")
    self.TextLabel.Name = "SliderText"
    self.TextLabel.BackgroundTransparency = 1
    self.TextLabel.Size = UDim2.new(0.5, -Config.Element.Padding, 1, -Config.Element.Slider.SliderHeight - Config.Element.Padding)
    self.TextLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    self.TextLabel.Font = Config.Element.Font
    self.TextLabel.TextSize = Config.Element.TextSize
    self.TextLabel.TextColor3 = self:GetTheme().Slider.TextColor
    self.TextLabel.Text = self.Text
    self.TextLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TextLabel.Parent = self.SliderFrame
    
    -- Value label
    self.ValueLabel = Instance.new("TextLabel")
    self.ValueLabel.Name = "ValueLabel"
    self.ValueLabel.BackgroundTransparency = 1
    self.ValueLabel.Size = UDim2.new(0.5, -Config.Element.Padding, 1, -Config.Element.Slider.SliderHeight - Config.Element.Padding)
    self.ValueLabel.Position = UDim2.new(0.5, 0, 0, 0)
    self.ValueLabel.Font = Config.Element.Font
    self.ValueLabel.TextSize = Config.Element.Slider.ValueTextSize
    self.ValueLabel.TextColor3 = self:GetTheme().Slider.TextColor
    self.ValueLabel.TextXAlignment = Enum.TextXAlignment.Right
    self.ValueLabel.Parent = self.SliderFrame
    
    -- Slider background
    self.SliderBackground = Instance.new("Frame")
    self.SliderBackground.Name = "SliderBackground"
    self.SliderBackground.Size = UDim2.new(1, -Config.Element.Padding * 2, 0, Config.Element.Slider.SliderHeight)
    self.SliderBackground.Position = UDim2.new(0, Config.Element.Padding, 1, -Config.Element.Slider.SliderHeight - Config.Element.Padding)
    self.SliderBackground.BackgroundColor3 = self:GetTheme().Slider.Background
    self.SliderBackground.BackgroundTransparency = 0.5
    self.SliderBackground.Parent = self.SliderFrame
    
    -- Add corner to slider background
    Utils.RoundCorners(self.SliderBackground, UDim.new(0, Config.Element.Slider.SliderHeight / 2))
    
    -- Add stroke to slider background
    Utils.AddStroke(
        self.SliderBackground,
        self:GetTheme().Slider.BorderColor,
        1
    )
    
    -- Slider fill
    self.SliderFill = Instance.new("Frame")
    self.SliderFill.Name = "SliderFill"
    self.SliderFill.Size = UDim2.new(0, 0, 1, 0)
    self.SliderFill.BackgroundColor3 = self:GetTheme().Slider.BackgroundActive
    self.SliderFill.Parent = self.SliderBackground
    
    -- Add corner to slider fill
    Utils.RoundCorners(self.SliderFill, UDim.new(0, Config.Element.Slider.SliderHeight / 2))
    
    -- Slider knob
    self.SliderKnob = Instance.new("Frame")
    self.SliderKnob.Name = "SliderKnob"
    self.SliderKnob.Size = UDim2.fromOffset(Config.Element.Slider.KnobSize, Config.Element.Slider.KnobSize)
    self.SliderKnob.AnchorPoint = Vector2.new(0.5, 0.5)
    self.SliderKnob.Position = UDim2.new(0, 0, 0.5, 0)
    self.SliderKnob.BackgroundColor3 = self:GetTheme().Slider.SliderColor
    self.SliderKnob.Parent = self.SliderFill
    
    -- Add corner to slider knob
    Utils.RoundCorners(self.SliderKnob, Config.Element.Slider.KnobCornerRadius)
    
    -- Add stroke to slider knob
    Utils.AddStroke(
        self.SliderKnob,
        self:GetTheme().Slider.BorderColor,
        1
    )
    
    -- Hover overlay
    self.HoverOverlay = Instance.new("Frame")
    self.HoverOverlay.Name = "HoverOverlay"
    self.HoverOverlay.Size = UDim2.fromScale(1, 1)
    self.HoverOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HoverOverlay.BackgroundTransparency = 1
    self.HoverOverlay.ZIndex = 2
    self.HoverOverlay.Parent = self.SliderFrame
    
    -- Add corner to overlay
    Utils.RoundCorners(self.HoverOverlay, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Update the value display
    self:UpdateValueLabel()
end

-- Set up event connections
function Slider:SetupConnections()
    -- Mouse enter
    self.MouseEnterConnection = self.SliderFrame.MouseEnter:Connect(function()
        if not self.Disabled then
            self:OnMouseEnter()
        end
    end)
    
    -- Mouse leave
    self.MouseLeaveConnection = self.SliderFrame.MouseLeave:Connect(function()
        if not self.Disabled then
            self:OnMouseLeave()
        end
    end)
    
    -- Mouse button 1 down
    self.MouseDownConnection = self.SliderBackground.MouseButton1Down:Connect(function()
        if not self.Disabled then
            self:OnMouseDown()
        end
    end)
    
    -- Input ended
    self.InputEndedConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if self.Dragging then
                self:OnMouseUp()
            end
        end
    end)
    
    -- Mouse movement
    self.MouseMoveConnection = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            if self.Dragging and not self.Disabled then
                self:OnMouseMove(input)
            end
        end
    end)
    
    -- Theme changed
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Get current theme
function Slider:GetTheme()
    return self.CustomTheme or ThemeManager:GetTheme().Element
end

-- Update slider theme
function Slider:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors based on theme
    self.SliderFrame.BackgroundColor3 = self:GetTheme().Slider.Background
    self.TextLabel.TextColor3 = self:GetTheme().Slider.TextColor
    self.ValueLabel.TextColor3 = self:GetTheme().Slider.TextColor
    self.Stroke.Color = self:GetTheme().Slider.BorderColor
    self.SliderBackground.BackgroundColor3 = self:GetTheme().Slider.Background
    self.SliderFill.BackgroundColor3 = self:GetTheme().Slider.BackgroundActive
    self.SliderKnob.BackgroundColor3 = self:GetTheme().Slider.SliderColor
    
    -- Update state
    self:UpdateState()
end

-- Handle mouse enter
function Slider:OnMouseEnter()
    self.Hovering = true
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 0.9},
        Config.Element.AnimationDuration
    )
    
    -- Tween knob size increase
    Utils.Tween(
        self.SliderKnob,
        {Size = UDim2.fromOffset(Config.Element.Slider.KnobSize * 1.2, Config.Element.Slider.KnobSize * 1.2)},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse leave
function Slider:OnMouseLeave()
    self.Hovering = false
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 1},
        Config.Element.AnimationDuration
    )
    
    -- Tween knob size back to normal
    if not self.Dragging then
        Utils.Tween(
            self.SliderKnob,
            {Size = UDim2.fromOffset(Config.Element.Slider.KnobSize, Config.Element.Slider.KnobSize)},
            Config.Element.AnimationDuration
        )
    end
end

-- Handle mouse down
function Slider:OnMouseDown()
    self.Dragging = true
    
    -- Create ripple effect
    Utils.CreateRipple(self.SliderBackground)
    
    -- Update value based on mouse position
    local inputPosition = UserInputService:GetMouseLocation()
    self:UpdateValueFromMousePosition(inputPosition)
end

-- Handle mouse move
function Slider:OnMouseMove(input)
    self:UpdateValueFromMousePosition(input.Position)
end

-- Handle mouse up
function Slider:OnMouseUp()
    self.Dragging = false
    
    -- If not hovering, shrink knob back to normal size
    if not self.Hovering then
        Utils.Tween(
            self.SliderKnob,
            {Size = UDim2.fromOffset(Config.Element.Slider.KnobSize, Config.Element.Slider.KnobSize)},
            Config.Element.AnimationDuration
        )
    end
end

-- Update value from mouse position
function Slider:UpdateValueFromMousePosition(mousePosition)
    -- Convert screen position to offset in slider
    local sliderPosition = self.SliderBackground.AbsolutePosition
    local sliderSize = self.SliderBackground.AbsoluteSize
    
    -- Calculate relative position (0-1)
    local relativeX = math.clamp((mousePosition.X - sliderPosition.X) / sliderSize.X, 0, 1)
    
    -- Calculate new value
    local newValue = self.Min + ((self.Max - self.Min) * relativeX)
    
    -- Apply increment if specified
    if self.Increment > 0 then
        newValue = math.floor(newValue / self.Increment + 0.5) * self.Increment
    end
    
    -- Clamp and set the value
    newValue = math.clamp(newValue, self.Min, self.Max)
    self:SetValue(newValue)
end

-- Update the fill and knob position based on current value
function Slider:UpdateSliderVisuals()
    -- Calculate the percentage filled
    local fillPercent = (self.Value - self.Min) / (self.Max - self.Min)
    
    -- Update fill size
    local fillSize = UDim2.new(fillPercent, 0, 1, 0)
    
    -- Tween the fill frame
    Utils.Tween(
        self.SliderFill,
        {Size = fillSize},
        Config.Element.AnimationDuration * 0.5
    )
end

-- Update the value label text
function Slider:UpdateValueLabel()
    -- Format the value based on precision
    local formattedValue
    
    if math.floor(self.Value) == self.Value then
        -- Integer value
        formattedValue = tostring(math.floor(self.Value))
    else
        -- Decimal value, format to specified precision
        local precision = Config.Element.Slider.DecimalPrecision
        local formatString = "%." .. precision .. "f"
        formattedValue = string.format(formatString, self.Value)
    end
    
    -- Update the label with prefix and suffix
    self.ValueLabel.Text = self.ValuePrefix .. formattedValue .. self.ValueSuffix
end

-- Set value directly
function Slider:SetValue(value, skipCallback)
    -- Clamp the value
    value = math.clamp(value, self.Min, self.Max)
    
    -- Check if value has changed
    if value ~= self.Value then
        self.Value = value
        
        -- Update visuals
        self:UpdateSliderVisuals()
        self:UpdateValueLabel()
        
        -- Call callback unless specified to skip
        if not skipCallback then
            task.spawn(function()
                self.Callback(self.Value)
            end)
            
            -- Fire change event
            self.OnChanged:Fire(self.Value)
        end
    end
end

-- Set slider disabled state
function Slider:SetDisabled(disabled)
    self.Disabled = disabled
    self:UpdateState()
end

-- Set slider text
function Slider:SetText(text)
    self.Text = text
    self.TextLabel.Text = text
end

-- Update min/max range
function Slider:SetRange(min, max)
    -- Validate min/max
    if min > max then
        local temp = min
        min = max
        max = temp
    end
    
    self.Min = min
    self.Max = max
    
    -- Clamp current value to new range
    self:SetValue(math.clamp(self.Value, self.Min, self.Max))
end

-- Update visual state based on properties
function Slider:UpdateState()
    if self.Disabled then
        -- Disabled state
        self.SliderFrame.BackgroundColor3 = self:GetTheme().Slider.Background
        self.TextLabel.TextColor3 = self:GetTheme().Slider.TextColor
        self.ValueLabel.TextColor3 = self:GetTheme().Slider.TextColor
        self.SliderBackground.BackgroundColor3 = self:GetTheme().Slider.Background
        self.SliderFill.BackgroundColor3 = self:GetTheme().Slider.BackgroundActive
        self.SliderKnob.BackgroundColor3 = self:GetTheme().Slider.SliderColor
        
        -- Set transparency
        self.TextLabel.TextTransparency = 0.5
        self.ValueLabel.TextTransparency = 0.5
        self.SliderFrame.BackgroundTransparency = 0.5
        self.Stroke.Transparency = 0.5
        self.SliderBackground.BackgroundTransparency = 0.75
        self.SliderFill.BackgroundTransparency = 0.5
        self.SliderKnob.BackgroundTransparency = 0.5
    else
        -- Enabled state
        self.SliderFrame.BackgroundColor3 = self:GetTheme().Slider.Background
        self.TextLabel.TextColor3 = self:GetTheme().Slider.TextColor
        self.ValueLabel.TextColor3 = self:GetTheme().Slider.TextColor
        self.SliderBackground.BackgroundColor3 = self:GetTheme().Slider.Background
        self.SliderFill.BackgroundColor3 = self:GetTheme().Slider.BackgroundActive
        self.SliderKnob.BackgroundColor3 = self:GetTheme().Slider.SliderColor
        
        -- Reset transparency
        self.TextLabel.TextTransparency = 0
        self.ValueLabel.TextTransparency = 0
        self.SliderFrame.BackgroundTransparency = 0
        self.Stroke.Transparency = 0
        self.SliderBackground.Back
        self.SliderBackground.BackgroundTransparency = 0.5
        self.SliderFill.BackgroundTransparency = 0
        self.SliderKnob.BackgroundTransparency = 0
    end
    
    -- Update the slider visuals
    self:UpdateSliderVisuals()
end

-- Clean up
function Slider:Destroy()
    -- Disconnect event connections
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.MouseDownConnection then
        self.MouseDownConnection:Disconnect()
    end
    
    if self.InputEndedConnection then
        self.InputEndedConnection:Disconnect()
    end
    
    if self.MouseMoveConnection then
        self.MouseMoveConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Clean up events
    self.OnChanged:Destroy()
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return Slider

-- ========================== Components/Dropdown.lua ==========================
--[[
    Dropdown component for the UI library
]]
local Dropdown = {}
Dropdown.__index = Dropdown

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal

-- Create a new dropdown instance
function Dropdown.new(parent, options)
    -- Load dependencies when first created
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
    end
    
    local self = setmetatable({}, Dropdown)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "Dropdown"
    self.Text = options.Text or "Dropdown"
    self.Items = options.Items or {}
    self.Default = options.Default
    self.MultiSelect = options.MultiSelect or false
    self.MaxVisibleItems = options.MaxVisibleItems or Config.Element.Dropdown.MaxVisibleItems
    self.Callback = options.Callback or function() end
    self.ToolTip = options.ToolTip
    self.Disabled = options.Disabled or false
    self.CustomTheme = options.CustomTheme
    
    -- Internal state
    self.Expanded = false
    self.Hovering = false
    self.Selected = {}
    self.DisplayText = ""
    
    -- Handle default selection
    if self.Default then
        if self.MultiSelect and type(self.Default) == "table" then
            -- Multi-select default
            for _, item in ipairs(self.Default) do
                self.Selected[item] = true
            end
        elseif not self.MultiSelect and type(self.Default) == "string" then
            -- Single-select default
            self.Selected[self.Default] = true
        end
    end
    
    -- Update display text
    self:UpdateDisplayText()
    
    -- Events
    self.OnSelectionChanged = Signal.new()
    
    -- Create dropdown UI
    self:Create(parent)
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Initialize states
    self:UpdateState()
    
    return self
end

-- Create dropdown UI elements
function Dropdown:Create(parent)
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_Dropdown"
    self.Container.BackgroundTransparency = 1
    self.Container.Size = UDim2.new(1, 0, 0, Config.Element.Height)
    self.Container.ClipsDescendants = false
    self.Container.Parent = parent
    
    -- Dropdown frame
    self.DropdownFrame = Instance.new("Frame")
    self.DropdownFrame.Name = "DropdownFrame"
    self.DropdownFrame.Size = UDim2.new(1, 0, 1, 0)
    self.DropdownFrame.BackgroundColor3 = self:GetTheme().Dropdown.Background
    self.DropdownFrame.BackgroundTransparency = 0
    self.DropdownFrame.Parent = self.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.DropdownFrame, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.DropdownFrame,
        self:GetTheme().Dropdown.BorderColor,
        Config.Element.BorderWidth
    )
    
    -- Label
    self.TextLabel = Instance.new("TextLabel")
    self.TextLabel.Name = "DropdownText"
    self.TextLabel.BackgroundTransparency = 1
    self.TextLabel.Size = UDim2.new(1, -(20 + Config.Element.Padding * 2), 1, 0)
    self.TextLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    self.TextLabel.Font = Config.Element.Font
    self.TextLabel.TextSize = Config.Element.TextSize
    self.TextLabel.TextColor3 = self:GetTheme().Dropdown.TextColor
    self.TextLabel.Text = self.Text .. ": " .. self.DisplayText
    self.TextLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TextLabel.TextTruncate = Enum.TextTruncate.AtEnd
    self.TextLabel.Parent = self.DropdownFrame
    
    -- Dropdown icon
    self.DropdownIcon = Instance.new("ImageLabel")
    self.DropdownIcon.Name = "DropdownIcon"
    self.DropdownIcon.Size = UDim2.fromOffset(12, 12)
    self.DropdownIcon.Position = UDim2.new(1, -18, 0.5, -6)
    self.DropdownIcon.BackgroundTransparency = 1
    self.DropdownIcon.Image = "rbxassetid://6031091004" -- Down arrow icon
    self.DropdownIcon.ImageColor3 = self:GetTheme().Dropdown.DropdownIconColor
    self.DropdownIcon.Parent = self.DropdownFrame
    
    -- Hover overlay
    self.HoverOverlay = Instance.new("Frame")
    self.HoverOverlay.Name = "HoverOverlay"
    self.HoverOverlay.Size = UDim2.fromScale(1, 1)
    self.HoverOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HoverOverlay.BackgroundTransparency = 1
    self.HoverOverlay.ZIndex = 2
    self.HoverOverlay.Parent = self.DropdownFrame
    
    -- Add corner to overlay
    Utils.RoundCorners(self.HoverOverlay, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Create detection button
    self.Button = Instance.new("TextButton")
    self.Button.Name = "DropdownButton"
    self.Button.Size = UDim2.fromScale(1, 1)
    self.Button.BackgroundTransparency = 1
    self.Button.Text = ""
    self.Button.ZIndex = 3
    self.Button.Parent = self.DropdownFrame
    
    -- Create dropdown menu (initially hidden)
    self:CreateDropdownMenu()
end

-- Create the dropdown menu
function Dropdown:CreateDropdownMenu()
    -- Dropdown menu container
    self.DropdownMenu = Instance.new("Frame")
    self.DropdownMenu.Name = "DropdownMenu"
    self.DropdownMenu.Size = UDim2.new(1, 0, 0, 0) -- Will be sized when opened
    self.DropdownMenu.Position = UDim2.new(0, 0, 1, 4)
    self.DropdownMenu.BackgroundColor3 = self:GetTheme().Dropdown.Background
    self.DropdownMenu.BackgroundTransparency = 0
    self.DropdownMenu.Visible = false
    self.DropdownMenu.ClipsDescendants = true
    self.DropdownMenu.ZIndex = 10
    self.DropdownMenu.Parent = self.DropdownFrame
    
    -- Add corner
    Utils.RoundCorners(self.DropdownMenu, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    Utils.AddStroke(
        self.DropdownMenu,
        self:GetTheme().Dropdown.BorderColor,
        Config.Element.BorderWidth
    )
    
    -- Scrolling frame for items
    self.ScrollingFrame = Instance.new("ScrollingFrame")
    self.ScrollingFrame.Name = "ScrollingFrame"
    self.ScrollingFrame.Size = UDim2.fromScale(1, 1)
    self.ScrollingFrame.BackgroundTransparency = 1
    self.ScrollingFrame.BorderSizePixel = 0
    self.ScrollingFrame.ScrollBarThickness = Config.Element.Dropdown.ScrollBarWidth
    self.ScrollingFrame.ScrollBarImageColor3 = self:GetTheme().Dropdown.BorderColor
    self.ScrollingFrame.ScrollingDirection = Enum.ScrollingDirection.Y
    self.ScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    self.ScrollingFrame.CanvasSize = UDim2.fromScale(0, 0)
    self.ScrollingFrame.ZIndex = 11
    self.ScrollingFrame.Parent = self.DropdownMenu
    
    -- Add padding to scrolling frame
    Utils.AddPadding(self.ScrollingFrame, Config.Element.Padding / 2)
    
    -- Add list layout
    self.ListLayout = Utils.AddListLayout(
        self.ScrollingFrame,
        2,
        Enum.FillDirection.Vertical,
        Enum.HorizontalAlignment.Center,
        Enum.VerticalAlignment.Top
    )
    
    -- Create items
    self:PopulateItems()
end

-- Populate dropdown items
function Dropdown:PopulateItems()
    -- Clear existing items first
    for _, child in pairs(self.ScrollingFrame:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end
    
    -- Add items
    for i, item in ipairs(self.Items) do
        self:AddItemButton(item, i)
    end
end

-- Add an item button to the dropdown
function Dropdown:AddItemButton(item, index)
    -- Create button
    local button = Instance.new("TextButton")
    button.Name = "Item_" .. item
    button.Size = UDim2.new(1, -Config.Element.Padding, 0, Config.Element.Dropdown.ItemHeight)
    button.BackgroundColor3 = self.Selected[item] and self:GetTheme().Dropdown.SelectedBackground or self:GetTheme().Dropdown.Background
    button.BackgroundTransparency = 0
    button.Text = ""
    button.AutoButtonColor = false
    button.LayoutOrder = index
    button.ZIndex = 12
    button.Parent = self.ScrollingFrame
    
    -- Add corner
    Utils.RoundCorners(button, UDim.new(0, Config.Element.CornerRadius.Offset / 2))
    
    -- Item text
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "ItemText"
    textLabel.Size = UDim2.new(1, -Config.Element.Padding * 2, 1, 0)
    textLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Font = Config.Element.Font
    textLabel.TextSize = Config.Element.TextSize
    textLabel.TextColor3 = self:GetTheme().Dropdown.TextColor
    textLabel.Text = tostring(item)
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.ZIndex = 13
    textLabel.Parent = button
    
    -- Handle hover
    button.MouseEnter:Connect(function()
        if not self.Disabled then
            Utils.Tween(
                button,
                {BackgroundColor3 = self:GetTheme().Dropdown.BackgroundHover},
                Config.Element.AnimationDuration * 0.5
            )
        end
    end)
    
    button.MouseLeave:Connect(function()
        if not self.Disabled then
            Utils.Tween(
                button,
                {BackgroundColor3 = self.Selected[item] and self:GetTheme().Dropdown.SelectedBackground or self:GetTheme().Dropdown.Background},
                Config.Element.AnimationDuration * 0.5
            )
        end
    end)
    
    -- Handle click
    button.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:SelectItem(item)
            
            -- Close dropdown if not multi-select
            if not self.MultiSelect then
                self:ToggleDropdown(false)
            end
        end
    end)
    
    -- Add checkmark for multi-select
    if self.MultiSelect then
        local checkmark = Instance.new("ImageLabel")
        checkmark.Name = "Checkmark"
        checkmark.Size = UDim2.fromOffset(16, 16)
        checkmark.Position = UDim2.new(1, -20, 0.5, -8)
        checkmark.BackgroundTransparency = 1
        checkmark.Image = "rbxassetid://6031094667" -- Checkmark icon
        checkmark.ImageColor3 = self:GetTheme().Dropdown.TextColor
        checkmark.ImageTransparency = self.Selected[item] and 0 or 1
        checkmark.ZIndex = 14
        checkmark.Parent = button
    end
    
    return button
end

-- Set up event connections
function Dropdown:SetupConnections()
    -- Mouse enter
    self.MouseEnterConnection = self.DropdownFrame.MouseEnter:Connect(function()
        if not self.Disabled then
            self:OnMouseEnter()
        end
    end)
    
    -- Mouse leave
    self.MouseLeaveConnection = self.DropdownFrame.MouseLeave:Connect(function()
        if not self.Disabled then
            self:OnMouseLeave()
        end
    end)
    
    -- Button pressed
    self.ButtonPressedConnection = self.Button.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:ToggleDropdown()
        end
    end)
    
    -- Input outside dropdown (for closing)
    self.InputBeganConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if self.Expanded then
                -- Check if click is outside dropdown
                local position = input.Position
                local inMainFrame = Utils.IsMouseOverObject(self.DropdownFrame)
                local inDropdownMenu = self.DropdownMenu.Visible and Utils.IsMouseOverObject(self.DropdownMenu)
                
                if not inMainFrame and not inDropdownMenu then
                    self:ToggleDropdown(false)
                end
            end
        end
    end)
    
    -- Theme changed
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Get current theme
function Dropdown:GetTheme()
    return self.CustomTheme or ThemeManager:GetTheme().Element
end

-- Update dropdown theme
function Dropdown:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors based on theme
    self.DropdownFrame.BackgroundColor3 = self:GetTheme().Dropdown.Background
    self.TextLabel.TextColor3 = self:GetTheme().Dropdown.TextColor
    self.DropdownIcon.ImageColor3 = self:GetTheme().Dropdown.DropdownIconColor
    self.Stroke.Color = self:GetTheme().Dropdown.BorderColor
    
    -- Update dropdown menu
    if self.DropdownMenu then
        self.DropdownMenu.BackgroundColor3 = self:GetTheme().Dropdown.Background
        
        -- Update items
        for _, button in pairs(self.ScrollingFrame:GetChildren()) do
            if button:IsA("TextButton") then
                local itemName = button.Name:gsub("Item_", "")
                button.BackgroundColor3 = self.Selected[itemName] and self:GetTheme().Dropdown.SelectedBackground or self:GetTheme().Dropdown.Background
                
                -- Update text color
                local textLabel = button:FindFirstChild("ItemText")
                if textLabel then
                    textLabel.TextColor3 = self:GetTheme().Dropdown.TextColor
                end
                
                -- Update checkmark color
                local checkmark = button:FindFirstChild("Checkmark")
                if checkmark then
                    checkmark.ImageColor3 = self:GetTheme().Dropdown.TextColor
                end
            end
        end
    end
    
    -- Update state
    self:UpdateState()
end

-- Handle mouse enter
function Dropdown:OnMouseEnter()
    self.Hovering = true
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 0.9},
        Config.Element.AnimationDuration
    )
    
    -- Tween background color
    Utils.Tween(
        self.DropdownFrame,
        {BackgroundColor3 = self:GetTheme().Dropdown.BackgroundHover},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse leave
function Dropdown:OnMouseLeave()
    self.Hovering = false
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 1},
        Config.Element.AnimationDuration
    )
    
    -- Tween background color back
    Utils.Tween(
        self.DropdownFrame,
        {BackgroundColor3 = self:GetTheme().Dropdown.Background},
        Config.Element.AnimationDuration
    )
end

-- Toggle dropdown menu
function Dropdown:ToggleDropdown(state)
    -- Set state explicitly if provided, otherwise toggle
    if state ~= nil then
        self.Expanded = state
    else
        self.Expanded = not self.Expanded
    end
    
    -- Calculate menu height
    local itemCount = math.min(#self.Items, self.MaxVisibleItems)
    local menuHeight = itemCount * Config.Element.Dropdown.ItemHeight + (Config.Element.Padding)
    
    if self.Expanded then
        -- Show menu
        self.DropdownMenu.Size = UDim2.new(1, 0, 0, 0)
        self.DropdownMenu.Visible = true
        
        -- Rotate icon
        Utils.Tween(
            self.DropdownIcon,
            {Rotation = 180},
            Config.Element.Dropdown.DropdownAnimationDuration
        )
        
        -- Expand menu
        Utils.Tween(
            self.DropdownMenu,
            {Size = UDim2.new(1, 0, 0, menuHeight)},
            Config.Element.Dropdown.DropdownAnimationDuration
        )
    else
        -- Rotate icon back
        Utils.Tween(
            self.DropdownIcon,
            {Rotation = 0},
            Config.Element.Dropdown.DropdownAnimationDuration
        )
        
        -- Collapse menu
        Utils.Tween(
            self.DropdownMenu,
            {Size = UDim2.new(1, 0, 0, 0)},
            Config.Element.Dropdown.DropdownAnimationDuration,
            Enum.EasingStyle.Quad,
            Enum.EasingDirection.Out,
            0,
            false,
            function()
                self.DropdownMenu.Visible = false
            end
        )
    end
end

-- Select an item
function Dropdown:SelectItem(item)
    -- Update selection based on multi-select mode
    if self.MultiSelect then
        -- Toggle selection
        self.Selected[item] = not self.Selected[item]
    else
        -- Clear previous selection
        self.Selected = {}
        -- Select new item
        self.Selected[item] = true
    end
    
    -- Update item visuals
    for _, button in pairs(self.ScrollingFrame:GetChildren()) do
        if button:IsA("TextButton") then
            local itemName = button.Name:gsub("Item_", "")
            
            -- Update background color
            button.BackgroundColor3 = self.Selected[itemName] and self:GetTheme().Dropdown.SelectedBackground or self:GetTheme().Dropdown.Background
            
            -- Update checkmark visibility for multi-select
            if self.MultiSelect then
                local checkmark = button:FindFirstChild("Checkmark")
                if checkmark then
                    checkmark.ImageTransparency = self.Selected[itemName] and 0 or 1
                end
            end
        end
    end
    
    -- Update display text
    self:UpdateDisplayText()
    
    -- Call callback
    task.spawn(function()
        if self.MultiSelect then
            local selectedItems = {}
            for item, selected in pairs(self.Selected) do
                if selected then
                    table.insert(selectedItems, item)
                end
            end
            self.Callback(selectedItems)
        else
            for item, selected in pairs(self.Selected) do
                if selected then
                    self.Callback(item)
                    break
                end
            end
        end
    end)
    
    -- Fire change event
    if self.MultiSelect then
        local selectedItems = {}
        for item, selected in pairs(self.Selected) do
            if selected then
                table.insert(selectedItems, item)
            end
        end
        self.OnSelectionChanged:Fire(selectedItems)
    else
        for item, selected in pairs(self.Selected) do
            if selected then
                self.OnSelectionChanged:Fire(item)
                break
            end
        end
    end
end

-- Update the display text based on selected items
function Dropdown:UpdateDisplayText()
    if self.MultiSelect then
        -- Count selected items
        local count = 0
        for _, selected in pairs(self.Selected) do
            if selected then
                count = count + 1
            end
        end
        
        if count == 0 then
            self.DisplayText = "None"
        elseif count == 1 then
            -- Show the single selected item
            for item, selected in pairs(self.Selected) do
                if selected then
                    self.DisplayText = tostring(item)
                    break
                end
            end
        else
            -- Show count for multiple items
            self.DisplayText = count .. " selected"
        end
    else
        -- Show the single selected item or "None"
        local hasSelection = false
        for item, selected in pairs(self.Selected) do
            if selected then
                self.DisplayText = tostring(item)
                hasSelection = true
                break
            end
        end
        
        if not hasSelection then
            self.DisplayText = "None"
        end
    end
    
    -- Update label text
    if self.TextLabel then
        self.TextLabel.Text = self.Text .. ": " .. self.DisplayText
    end
end

-- Get the current selection
function Dropdown:GetSelection()
    if self.MultiSelect then
        local selected = {}
        for item, isSelected in pairs(self.Selected) do
            if isSelected then
                table.insert(selected, item)
            end
        end
        return selected
    else
        for item, isSelected in pairs(self.Selected) do
            if isSelected then
                return item
            end
        end
        return nil
    end
end

-- Set items
function Dropdown:SetItems(items)
    self.Items = items
    
    -- Clear selection for items that no longer exist
    local newSelected = {}
    for item, selected in pairs(self.Selected) do
        local found = false
        for _, newItem in ipairs(items) do
            if tostring(newItem) == tostring(item) then
                found = true
                break
            end
        end
        
        if found and selected then
            newSelected[item] = true
        end
    end
    
    self.Selected = newSelected
    
    -- Update display text
    self:UpdateDisplayText()
    
    -- Recreate the dropdown items
    self:PopulateItems()
end

-- Set selection programmatically
function Dropdown:SetSelection(selection)
    if self.MultiSelect and type(selection) == "table" then
        -- Clear current selection
        self.Selected = {}
        
        -- Add new selections
        for _, item in ipairs(selection) do
            self.Selected[tostring(item)] = true
        end
    elseif not self.MultiSelect then
        -- Clear current selection
        self.Selected = {}
        
        -- Set new selection
        if selection ~= nil then
            self.Selected[tostring(selection)] = true
        end
    end
    
    -- Update display text
    self:UpdateDisplayText()
    
    -- Update item visuals if menu exists
    if self.ScrollingFrame then
        for _, button in pairs(self.ScrollingFrame:GetChildren()) do
            if button:IsA("TextButton") then
                local itemName = button.Name:gsub("Item_", "")
                
                -- Update background color
                button.BackgroundColor3 = self.Selected[itemName] and self:GetTheme().Dropdown.SelectedBackground or self:GetTheme().Dropdown.Background
                
                -- Update checkmark visibility for multi-select
                if self.MultiSelect then
                    local checkmark = button:FindFirstChild("Checkmark")
                    if checkmark then
                        checkmark.ImageTransparency = self.Selected[itemName] and 0 or 1
                    end
                end
            end
        end
    end
end

-- Set dropdown disabled state
function Dropdown:SetDisabled(disabled)
    self.Disabled = disabled
    
    -- Close dropdown if being disabled
    if disabled and self.Expanded then
        self:ToggleDropdown(false)
    end
    
    self:UpdateState()
end

-- Set dropdown text
function Dropdown:SetText(text)
    self.Text = text
    self:UpdateDisplayText()
end

-- Update visual state based on properties
function Dropdown:UpdateState()
    if self.Disabled then
        -- Disabled state
        self.DropdownFrame.BackgroundColor3 = self:GetTheme().Dropdown.Background
        self.TextLabel.TextColor3 = self:GetTheme().Dropdown.TextColor
        self.DropdownIcon.ImageColor3 = self:GetTheme().Dropdown.DropdownIconColor
        
        -- Set transparency
        self.TextLabel.TextTransparency = 0.5
        self.DropdownFrame.BackgroundTransparency = 0.5
        self.Stroke.Transparency = 0.5
        self.DropdownIcon.ImageTransparency = 0.5
    else
        -- Enabled state
        self.DropdownFrame.BackgroundColor3 = self:GetTheme().Dropdown.Background
        self.TextLabel.TextColor3 = self:GetTheme().Dropdown.TextColor
        self.DropdownIcon.ImageColor3 = self:GetTheme().Dropdown.DropdownIconColor
        
        -- Reset transparency
        self.TextLabel.TextTransparency = 0
        self.DropdownFrame.BackgroundTransparency = 0
        self.Stroke.Transparency = 0
        self.DropdownIcon.ImageTransparency = 0
    end
end

-- Clean up
function Dropdown:Destroy()
    -- Disconnect event connections
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.ButtonPressedConnection then
        self.ButtonPressedConnection:Disconnect()
    end
    
    if self.InputBeganConnection then
        self.InputBeganConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Clean up events
    self.OnSelectionChanged:Destroy()
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return Dropdown

-- ========================== Components/Keybind.lua ==========================
--[[
    Keybind component for the UI library
]]
local Keybind = {}
Keybind.__index = Keybind

-- Services
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal

-- Key name mappings
local KEY_DISPLAY_NAMES = {
    [Enum.KeyCode.Unknown] = "...",
    [Enum.KeyCode.LeftShift] = "L-Shift",
    [Enum.KeyCode.RightShift] = "R-Shift",
    [Enum.KeyCode.LeftControl] = "L-Ctrl",
    [Enum.KeyCode.RightControl] = "R-Ctrl",
    [Enum.KeyCode.LeftAlt] = "L-Alt",
    [Enum.KeyCode.RightAlt] = "R-Alt",
    [Enum.KeyCode.BackSlash] = "\\",
    [Enum.KeyCode.Slash] = "/",
    [Enum.KeyCode.Question] = "?",
    [Enum.KeyCode.Period] = ".",
    [Enum.KeyCode.Semicolon] = ";",
    [Enum.KeyCode.Quote] = "'",
    [Enum.KeyCode.LeftBracket] = "[",
    [Enum.KeyCode.RightBracket] = "]",
    [Enum.KeyCode.Comma] = ",",
    [Enum.KeyCode.Backquote] = "`",
    [Enum.KeyCode.Minus] = "-",
    [Enum.KeyCode.Equals] = "=",
    [Enum.KeyCode.Return] = "Enter",
    [Enum.KeyCode.Backspace] = "Backspace",
    [Enum.KeyCode.Delete] = "Delete",
    [Enum.KeyCode.Insert] = "Insert",
    [Enum.KeyCode.Up] = "Up",
    [Enum.KeyCode.Down] = "Down",
    [Enum.KeyCode.Left] = "Left",
    [Enum.KeyCode.Right] = "Right",
    [Enum.KeyCode.Tab] = "Tab",
    [Enum.KeyCode.CapsLock] = "Caps",
    [Enum.KeyCode.Escape] = "Esc",
    [Enum.KeyCode.Space] = "Space",
    [Enum.KeyCode.F1] = "F1",
    [Enum.KeyCode.F2] = "F2",
    [Enum.KeyCode.F3] = "F3",
    [Enum.KeyCode.F4] = "F4",
    [Enum.KeyCode.F5] = "F5",
    [Enum.KeyCode.F6] = "F6",
    [Enum.KeyCode.F7] = "F7",
    [Enum.KeyCode.F8] = "F8",
    [Enum.KeyCode.F9] = "F9",
    [Enum.KeyCode.F10] = "F10",
    [Enum.KeyCode.F11] = "F11",
    [Enum.KeyCode.F12] = "F12",
    [Enum.KeyCode.PageUp] = "PgUp",
    [Enum.KeyCode.PageDown] = "PgDown",
    [Enum.KeyCode.Home] = "Home",
    [Enum.KeyCode.End] = "End"
}

-- Blacklisted keys (keys that cannot be bound)
local BLACKLISTED_KEYS = {
    [Enum.KeyCode.Unknown] = true
}

-- Create a new keybind instance
function Keybind.new(parent, options)
    -- Load dependencies when first created
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
    end
    
    local self = setmetatable({}, Keybind)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "Keybind"
    self.Text = options.Text or "Keybind"
    self.Default = options.Default
    self.Callback = options.Callback or function() end
    self.ChangedCallback = options.ChangedCallback or function() end
    self.AllowMouse = options.AllowMouse or false
    self.OnPress = options.OnPress or false
    self.ToolTip = options.ToolTip
    self.Disabled = options.Disabled or false
    self.CustomTheme = options.CustomTheme
    
    -- Internal state
    self.Listening = false
    self.Value = self.Default
    self.Hovering = false
    
    -- Events
    self.OnChanged = Signal.new()
    self.KeyPressed = Signal.new()
    
    -- Create keybind UI
    self:Create(parent)
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Initialize states
    self:UpdateState()
    
    return self
end

-- Create keybind UI elements
function Keybind:Create(parent)
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_Keybind"
    self.Container.BackgroundTransparency = 1
    self.Container.Size = UDim2.new(1, 0, 0, Config.Element.Height)
    self.Container.Parent = parent
    
    -- Keybind frame
    self.KeybindFrame = Instance.new("Frame")
    self.KeybindFrame.Name = "KeybindFrame"
    self.KeybindFrame.Size = UDim2.new(1, 0, 1, 0)
    self.KeybindFrame.BackgroundColor3 = self:GetTheme().Keybind.Background
    self.KeybindFrame.BackgroundTransparency = 0
    self.KeybindFrame.Parent = self.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.KeybindFrame, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.KeybindFrame,
        self:GetTheme().Keybind.BorderColor,
        Config.Element.BorderWidth
    )
    
    -- Label
    self.TextLabel = Instance.new("TextLabel")
    self.TextLabel.Name = "KeybindText"
    self.TextLabel.BackgroundTransparency = 1
    self.TextLabel.Size = UDim2.new(0.7, -Config.Element.Padding, 1, 0)
    self.TextLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    self.TextLabel.Font = Config.Element.Font
    self.TextLabel.TextSize = Config.Element.TextSize
    self.TextLabel.TextColor3 = self:GetTheme().Keybind.TextColor
    self.TextLabel.Text = self.Text
    self.TextLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TextLabel.Parent = self.KeybindFrame
    
    -- Key display
    self.KeyDisplay = Instance.new("Frame")
    self.KeyDisplay.Name = "KeyDisplay"
    self.KeyDisplay.Size = UDim2.new(0.3, -Config.Element.Padding, 0, 24)
    self.KeyDisplay.Position = UDim2.new(0.7, 0, 0.5, -12)
    self.KeyDisplay.BackgroundColor3 = self:GetTheme().Keybind.Background
    self.KeyDisplay.BackgroundTransparency = 0.2
    self.KeyDisplay.Parent = self.KeybindFrame
    
    -- Add corner to key display
    Utils.RoundCorners(self.KeyDisplay, UDim.new(0, 4))
    
    -- Add stroke to key display
    Utils.AddStroke(
        self.KeyDisplay,
        self:GetTheme().Keybind.BorderColor,
        1
    )
    
    -- Key text
    self.KeyText = Instance.new("TextLabel")
    self.KeyText.Name = "KeyText"
    self.KeyText.Size = UDim2.fromScale(1, 1)
    self.KeyText.BackgroundTransparency = 1
    self.KeyText.Font = Config.Element.Font
    self.KeyText.TextSize = Config.Element.Keybind.KeyTextSize
    self.KeyText.TextColor3 = self:GetTheme().Keybind.KeyTextColor
    self.KeyText.Text = self:GetDisplayText()
    self.KeyText.Parent = self.KeyDisplay
    
    -- Hover overlay
    self.HoverOverlay = Instance.new("Frame")
    self.HoverOverlay.Name = "HoverOverlay"
    self.HoverOverlay.Size = UDim2.fromScale(1, 1)
    self.HoverOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HoverOverlay.BackgroundTransparency = 1
    self.HoverOverlay.ZIndex = 2
    self.HoverOverlay.Parent = self.KeybindFrame
    
    -- Add corner to overlay
    Utils.RoundCorners(self.HoverOverlay, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Create detection button for the whole component
    self.Button = Instance.new("TextButton")
    self.Button.Name = "KeybindButton"
    self.Button.Size = UDim2.fromScale(1, 1)
    self.Button.BackgroundTransparency = 1
    self.Button.Text = ""
    self.Button.ZIndex = 3
    self.Button.Parent = self.KeybindFrame
    
    -- Create detection button just for the key display
    self.KeyButton = Instance.new("TextButton")
    self.KeyButton.Name = "KeyButton"
    self.KeyButton.Size = UDim2.fromScale(1, 1)
    self.KeyButton.BackgroundTransparency = 1
    self.KeyButton.Text = ""
    self.KeyButton.ZIndex = 4
    self.KeyButton.Parent = self.KeyDisplay
end

-- Set up event connections
function Keybind:SetupConnections()
    -- Mouse enter
    self.MouseEnterConnection = self.KeybindFrame.MouseEnter:Connect(function()
        if not self.Disabled then
            self:OnMouseEnter()
        end
    end)
    
    -- Mouse leave
    self.MouseLeaveConnection = self.KeybindFrame.MouseLeave:Connect(function()
        if not self.Disabled then
            self:OnMouseLeave()
        end
    end)
    
    -- Key button clicked to start listening
    self.KeyButtonClickedConnection = self.KeyButton.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:StartListening()
        end
    end)
    
    -- Main button clicked for OnPress mode
    self.MainButtonClickedConnection = self.Button.MouseButton1Click:Connect(function()
        if not self.Disabled and not self.Listening and self.OnPress then
            -- Trigger callback
            task.spawn(function()
                self.Callback(self.Value)
            end)
            
            -- Fire key pressed event
            self.KeyPressed:Fire()
            
            -- Visual feedback
            self:PressEffect()
        end
    end)
    
    -- Input began for key detection
    self.InputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if self.Listening then
            self:HandleListeningInput(input)
        elseif not self.OnPress and not self.Disabled and not self.Listening then
            self:HandleRegularInput(input)
        end
    end)
    
    -- Theme changed
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Get current theme
function Keybind:GetTheme()
    return self.CustomTheme or ThemeManager:GetTheme().Element
end

-- Update keybind theme
function Keybind:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors based on theme
    self.KeybindFrame.BackgroundColor3 = self:GetTheme().Keybind.Background
    self.TextLabel.TextColor3 = self:GetTheme().Keybind.TextColor
    self.Stroke.Color = self:GetTheme().Keybind.BorderColor
    self.KeyDisplay.BackgroundColor3 = self:GetTheme().Keybind.Background
    self.KeyText.TextColor3 = self:GetTheme().Keybind.KeyTextColor
    
    -- Update state
    self:UpdateState()
end

-- Handle mouse enter
function Keybind:OnMouseEnter()
    self.Hovering = true
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 0.9},
        Config.Element.AnimationDuration
    )
    
    -- Tween key display
    Utils.Tween(
        self.KeyDisplay,
        {BackgroundTransparency = 0},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse leave
function Keybind:OnMouseLeave()
    self.Hovering = false
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 1},
        Config.Element.AnimationDuration
    )
    
    -- Tween key display
    Utils.Tween(
        self.KeyDisplay,
        {BackgroundTransparency = 0.2},
        Config.Element.AnimationDuration
    )
end

-- Start listening for key input
function Keybind:StartListening()
    self.Listening = true
    
    -- Change key text to indicate listening
    self.KeyText.Text = Config.Element.Keybind.ListenText
    
    -- Change key display color
    Utils.Tween(
        self.KeyDisplay,
        {BackgroundColor3 = self:GetTheme().Keybind.BackgroundActive},
        Config.Element.AnimationDuration
    )
    
    -- Create ripple effect
    Utils.CreateRipple(self.KeyDisplay)
end

-- Stop listening for key input
function Keybind:StopListening()
    self.Listening = false
    
    -- Restore key text
    self.KeyText.Text = self:GetDisplayText()
    
    -- Restore key display color
    Utils.Tween(
        self.KeyDisplay,
        {BackgroundColor3 = self:GetTheme().Keybind.Background},
        Config.Element.AnimationDuration
    )
end

-- Handle input while listening
function Keybind:HandleListeningInput(input)
    local keyCode = input.KeyCode
    local userInputType = input.UserInputType
    
    -- Handle escape to cancel
    if keyCode == Enum.KeyCode.Escape then
        self:StopListening()
        return
    end
    
    -- Check if it's a valid key
    if keyCode ~= Enum.KeyCode.Unknown then
        -- Check if it's a blacklisted key
        if BLACKLISTED_KEYS[keyCode] then
            return
        end
        
        -- Set new keybind
        self:SetKeybind(keyCode)
        self:StopListening()
        return
    end
    
    -- Handle mouse input if allowed
    if self.AllowMouse then
        if userInputType == Enum.UserInputType.MouseButton1 or
           userInputType == Enum.UserInputType.MouseButton2 or
           userInputType == Enum.UserInputType.MouseButton3 then
            -- Set new keybind to mouse button
            self:SetKeybind(userInputType)
            self:StopListening()
            return
        end
    end
end

-- Handle regular input when not listening
function Keybind:HandleRegularInput(input)
    local keyCode = input.KeyCode
    local userInputType = input.UserInputType
    
    -- Check if the pressed key matches the keybind
    if self.Value then
        if (keyCode ~= Enum.KeyCode.Unknown and keyCode == self.Value) or
           (self.AllowMouse and (
               (userInputType == Enum.UserInputType.MouseButton1 and self.Value == Enum.UserInputType.MouseButton1) or
               (userInputType == Enum.UserInputType.MouseButton2 and self.Value == Enum.UserInputType.MouseButton2) or
               (userInputType == Enum.UserInputType.MouseButton3 and self.Value == Enum.UserInputType.MouseButton3)
           )) then
            -- Trigger callback
            task.spawn(function()
                self.Callback(self.Value)
            end)
            
            -- Fire key pressed event
            self.KeyPressed:Fire()
            
            -- Visual feedback
            self:PressEffect()
        end
    end
end

-- Create press effect animation
function Keybind:PressEffect()
    -- Flash key display
    local originalColor = self.KeyDisplay.BackgroundColor3
    Utils.Tween(
        self.KeyDisplay,
        {BackgroundColor3 = self:GetTheme().Keybind.BackgroundActive},
        Config.Element.AnimationDuration * 0.5
    )
    
    task.delay(Config.Element.AnimationDuration * 0.5, function()
        Utils.Tween(
            self.KeyDisplay,
            {BackgroundColor3 = originalColor},
            Config.Element.AnimationDuration * 0.5
        )
    end)
    
    -- Create ripple effect
    Utils.CreateRipple(self.KeyDisplay)
end

-- Get display text for the current key
function Keybind:GetDisplayText()
    if not self.Value then
        return "None"
    end
    
    -- Handle mouse buttons
    if self.Value == Enum.UserInputType.MouseButton1 then
        return "MB1"
    elseif self.Value == Enum.UserInputType.MouseButton2 then
        return "MB2"
    elseif self.Value == Enum.UserInputType.MouseButton3 then
        return "MB3"
    end
    
    -- Handle keyboard keys
    return KEY_DISPLAY_NAMES[self.Value] or tostring(self.Value):gsub("Enum.KeyCode.", "")
end

-- Set the keybind
function Keybind:SetKeybind(key)
    -- Update value
    self.Value = key
    
    -- Update text
    self.KeyText.Text = self:GetDisplayText()
    
    -- Call changed callback
    task.spawn(function()
        self.ChangedCallback(self.Value)
    end)
    
    -- Fire changed event
    self.OnChanged:Fire(self.Value)
end

-- Set keybind disabled state
function Keybind:SetDisabled(disabled)
    self.Disabled = disabled
    
    -- Stop listening if being disabled
    if disabled and self.Listening then
        self:StopListening()
    end
    
    self:UpdateState()
end

-- Set keybind text
function Keybind:SetText(text)
    self.Text = text
    self.TextLabel.Text = text
end

-- Clear the keybind
function Keybind:Clear()
    self:SetKeybind(nil)
end

-- Update visual state based on properties
function Keybind:UpdateState()
    if self.Disabled then
        -- Disabled state
        self.KeybindFrame.BackgroundColor3 = self:GetTheme().Keybind.Background
        self.TextLabel.TextColor3 = self:GetTheme().Keybind.TextColor
        self.KeyText.TextColor3 = self:GetTheme().Keybind.KeyTextColor
        
        -- Set transparency
        self.TextLabel.TextTransparency = 0.5
        self.KeybindFrame.BackgroundTransparency = 0.5
        self.Stroke.Transparency = 0.5
        self.KeyDisplay.BackgroundTransparency = 0.6
        self.KeyText.TextTransparency = 0.5
    else
        -- Enabled state
        self.KeybindFrame.BackgroundColor3 = self:GetTheme().Keybind.Background
        self.TextLabel.TextColor3 = self:GetTheme().Keybind.TextColor
        self.KeyText.TextColor3 = self:GetTheme().Keybind.KeyTextColor
        
        -- Reset transparency
        self.TextLabel.TextTransparency = 0
        self.KeybindFrame.BackgroundTransparency = 0
        self.Stroke.Transparency = 0
        self.KeyDisplay.BackgroundTransparency = self.Hovering and 0 or 0.2
        self.KeyText.TextTransparency = 0
    end
end

-- Clean up
function Keybind:Destroy()
    -- Disconnect event connections
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.KeyButtonClickedConnection then
        self.KeyButtonClickedConnection:Disconnect()
    end
    
    if self.MainButtonClickedConnection then
        self.MainButtonClickedConnection:Disconnect()
    end
    
    if self.InputBeganConnection then
        self.InputBeganConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Clean up events
    self.OnChanged:Destroy()
    self.KeyPressed:Destroy()
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return Keybind

-- ========================== Components/ColorPicker.lua ==========================
--[[
    ColorPicker component for the UI library
]]
local ColorPicker = {}
ColorPicker.__index = ColorPicker

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal

-- Create a new color picker instance
function ColorPicker.new(parent, options)
    -- Load dependencies when first created
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
    end
    
    local self = setmetatable({}, ColorPicker)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "ColorPicker"
    self.Text = options.Text or "Color Picker"
    self.Default = options.Default or Color3.fromRGB(255, 255, 255)
    self.Callback = options.Callback or function() end
    self.ToolTip = options.ToolTip
    self.Disabled = options.Disabled or false
    self.CustomTheme = options.CustomTheme
    
    -- Internal state
    self.Color = self.Default
    self.Hovering = false
    self.PickerOpen = false
    self.PickerDragging = {
        Hue = false,
        Saturation = false,
        Alpha = false
    }
    self.Alpha = options.Alpha or 1
    self.UseAlpha = options.UseAlpha or false
    self.RainbowMode = false
    self.RainbowSpeed = 10
    
    -- Events
    self.OnChanged = Signal.new()
    
    -- Create color picker UI
    self:Create(parent)
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Initialize states
    self:UpdateState()
    
    return self
end

-- Create color picker UI elements
function ColorPicker:Create(parent)
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_ColorPicker"
    self.Container.BackgroundTransparency = 1
    self.Container.Size = UDim2.new(1, 0, 0, Config.Element.Height)
    self.Container.ClipsDescendants = false
    self.Container.Parent = parent
    
    -- Color picker frame
    self.PickerFrame = Instance.new("Frame")
    self.PickerFrame.Name = "PickerFrame"
    self.PickerFrame.Size = UDim2.new(1, 0, 1, 0)
    self.PickerFrame.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    self.PickerFrame.BackgroundTransparency = 0
    self.PickerFrame.Parent = self.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.PickerFrame, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.PickerFrame,
        self:GetTheme().ColorPicker.BorderColor,
        Config.Element.BorderWidth
    )
    
    -- Label
    self.TextLabel = Instance.new("TextLabel")
    self.TextLabel.Name = "PickerText"
    self.TextLabel.BackgroundTransparency = 1
    self.TextLabel.Size = UDim2.new(1, -(Config.Element.ColorPicker.SwatchSize + Config.Element.Padding * 3), 1, 0)
    self.TextLabel.Position = UDim2.fromOffset(Config.Element.Padding, 0)
    self.TextLabel.Font = Config.Element.Font
    self.TextLabel.TextSize = Config.Element.TextSize
    self.TextLabel.TextColor3 = self:GetTheme().ColorPicker.TextColor
    self.TextLabel.Text = self.Text
    self.TextLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TextLabel.Parent = self.PickerFrame
    
    -- Color swatch
    self.ColorSwatch = Instance.new("Frame")
    self.ColorSwatch.Name = "ColorSwatch"
    self.ColorSwatch.Size = UDim2.fromOffset(Config.Element.ColorPicker.SwatchSize, Config.Element.ColorPicker.SwatchSize)
    self.ColorSwatch.Position = UDim2.new(1, -Config.Element.ColorPicker.SwatchSize - Config.Element.Padding, 0.5, -Config.Element.ColorPicker.SwatchSize / 2)
    self.ColorSwatch.BackgroundColor3 = self.Color
    self.ColorSwatch.BackgroundTransparency = 0
    self.ColorSwatch.Parent = self.PickerFrame
    
    -- Add corner to swatch
    self.ColorSwatchCorner = Utils.RoundCorners(self.ColorSwatch, Config.Element.ColorPicker.SwatchCornerRadius)
    
    -- Add stroke to swatch
    self.ColorSwatchStroke = Utils.AddStroke(
        self.ColorSwatch,
        self:GetTheme().ColorPicker.BorderColor,
        1
    )
    
    -- Hover overlay
    self.HoverOverlay = Instance.new("Frame")
    self.HoverOverlay.Name = "HoverOverlay"
    self.HoverOverlay.Size = UDim2.fromScale(1, 1)
    self.HoverOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HoverOverlay.BackgroundTransparency = 1
    self.HoverOverlay.ZIndex = 2
    self.HoverOverlay.Parent = self.PickerFrame
    
    -- Add corner to overlay
    Utils.RoundCorners(self.HoverOverlay, UDim.new(0, Config.Element.CornerRadius.Offset))
    
    -- Create detection button
    self.Button = Instance.new("TextButton")
    self.Button.Name = "PickerButton"
    self.Button.Size = UDim2.fromScale(1, 1)
    self.Button.BackgroundTransparency = 1
    self.Button.Text = ""
    self.Button.ZIndex = 3
    self.Button.Parent = self.PickerFrame
    
    -- Create color picker popup
    self:CreateColorPickerPopup()
end

-- Create the color picker popup
function ColorPicker:CreateColorPickerPopup()
    -- Popup container
    self.Popup = Instance.new("Frame")
    self.Popup.Name = "ColorPickerPopup"
    self.Popup.Size = UDim2.fromOffset(Config.Element.ColorPicker.PickerWidth, Config.Element.ColorPicker.PickerHeight)
    self.Popup.Position = UDim2.new(1, 10, 0, 0)
    self.Popup.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    self.Popup.BackgroundTransparency = 0
    self.Popup.Visible = false
    self.Popup.ZIndex = 100
    self.Popup.Parent = self.Container
    
    -- Add corner
    Utils.RoundCorners(self.Popup, UDim.new(0, 6))
    
    -- Add stroke
    Utils.AddStroke(
        self.Popup,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        100
    )
    
    -- Add shadow
    Utils.CreateShadow(self.Popup, 6, 0.5)
    
    -- Popup title
    self.PopupTitle = Instance.new("TextLabel")
    self.PopupTitle.Name = "PopupTitle"
    self.PopupTitle.Size = UDim2.new(1, -Config.Element.Padding * 2, 0, 24)
    self.PopupTitle.Position = UDim2.fromOffset(Config.Element.Padding, Config.Element.Padding)
    self.PopupTitle.BackgroundTransparency = 1
    self.PopupTitle.Font = Config.Element.Font
    self.PopupTitle.TextSize = Config.Element.TextSize
    self.PopupTitle.TextColor3 = self:GetTheme().ColorPicker.TextColor
    self.PopupTitle.Text = "Pick a color"
    self.PopupTitle.TextXAlignment = Enum.TextXAlignment.Left
    self.PopupTitle.ZIndex = 101
    self.PopupTitle.Parent = self.Popup
    
    -- Color preview
    self.PopupPreview = Instance.new("Frame")
    self.PopupPreview.Name = "ColorPreview"
    self.PopupPreview.Size = UDim2.fromOffset(Config.Element.ColorPicker.PreviewSwatchSize, Config.Element.ColorPicker.PreviewSwatchSize)
    self.PopupPreview.Position = UDim2.new(1, -Config.Element.ColorPicker.PreviewSwatchSize - Config.Element.Padding, 0, Config.Element.Padding)
    self.PopupPreview.BackgroundColor3 = self.Color
    self.PopupPreview.ZIndex = 101
    self.PopupPreview.Parent = self.Popup
    
    -- Add corner to preview
    Utils.RoundCorners(self.PopupPreview, UDim.new(0, 4))
    
    -- Add stroke to preview
    Utils.AddStroke(
        self.PopupPreview,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        101
    )
    
    -- Create the saturation picker
    self:CreateSaturationPicker()
    
    -- Create the hue slider
    self:CreateHueSlider()
    
    -- Create alpha slider if enabled
    if self.UseAlpha then
        self:CreateAlphaSlider()
    end
    
    -- Create color input fields
    self:CreateColorInputs()
    
    -- Create buttons
    self:CreateButtons()
end

-- Create the saturation picker (color field)
function ColorPicker:CreateSaturationPicker()
    -- Container
    self.SaturationContainer = Instance.new("Frame")
    self.SaturationContainer.Name = "SaturationContainer"
    self.SaturationContainer.Size = UDim2.new(1, -Config.Element.Padding * 2 - Config.Element.ColorPicker.HueSliderWidth - 4, 0, 120)
    self.SaturationContainer.Position = UDim2.new(0, Config.Element.Padding, 0, 40)
    self.SaturationContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.SaturationContainer.BorderSizePixel = 0
    self.SaturationContainer.ZIndex = 101
    self.SaturationContainer.Parent = self.Popup
    
    -- Add corner
    Utils.RoundCorners(self.SaturationContainer, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.SaturationContainer,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        101
    )
    
    -- White gradient
    self.WhiteGradient = Instance.new("Frame")
    self.WhiteGradient.Name = "WhiteGradient"
    self.WhiteGradient.Size = UDim2.fromScale(1, 1)
    self.WhiteGradient.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.WhiteGradient.BorderSizePixel = 0
    self.WhiteGradient.ZIndex = 102
    self.WhiteGradient.Parent = self.SaturationContainer
    
    -- White gradient UIGradient
    self.WhiteUIGradient = Instance.new("UIGradient")
    self.WhiteUIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
    })
    self.WhiteUIGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1)
    })
    self.WhiteUIGradient.Rotation = 90
    self.WhiteUIGradient.Parent = self.WhiteGradient
    
    -- Black gradient
    self.BlackGradient = Instance.new("Frame")
    self.BlackGradient.Name = "BlackGradient"
    self.BlackGradient.Size = UDim2.fromScale(1, 1)
    self.BlackGradient.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    self.BlackGradient.BorderSizePixel = 0
    self.BlackGradient.ZIndex = 103
    self.BlackGradient.Parent = self.SaturationContainer
    
    -- Black gradient UIGradient
    self.BlackUIGradient = Instance.new("UIGradient")
    self.BlackUIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    })
    self.BlackUIGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    self.BlackUIGradient.Rotation = 0
    self.BlackUIGradient.Parent = self.BlackGradient
    
    -- Hue overlay
    self.HueOverlay = Instance.new("Frame")
    self.HueOverlay.Name = "HueOverlay"
    self.HueOverlay.Size = UDim2.fromScale(1, 1)
    self.HueOverlay.BackgroundColor3 = self:HueToColor(0)
    self.HueOverlay.BorderSizePixel = 0
    self.HueOverlay.ZIndex = 101
    self.HueOverlay.Parent = self.SaturationContainer
    
    -- Add corner
    Utils.RoundCorners(self.HueOverlay, UDim.new(0, 4))
    
    -- Selector
    self.SaturationSelector = Instance.new("Frame")
    self.SaturationSelector.Name = "SaturationSelector"
    self.SaturationSelector.Size = UDim2.fromOffset(8, 8)
    self.SaturationSelector.Position = UDim2.fromScale(1, 0)
    self.SaturationSelector.AnchorPoint = Vector2.new(0.5, 0.5)
    self.SaturationSelector.BackgroundTransparency = 1
    self.SaturationSelector.BorderSizePixel = 0
    self.SaturationSelector.ZIndex = 105
    self.SaturationSelector.Parent = self.SaturationContainer
    
    -- Selector circle
    self.SaturationSelectorCircle = Instance.new("Frame")
    self.SaturationSelectorCircle.Name = "SelectorCircle"
    self.SaturationSelectorCircle.Size = UDim2.fromOffset(10, 10)
    self.SaturationSelectorCircle.Position = UDim2.fromScale(0.5, 0.5)
    self.SaturationSelectorCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    self.SaturationSelectorCircle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.SaturationSelectorCircle.BorderSizePixel = 0
    self.SaturationSelectorCircle.ZIndex = 106
    self.SaturationSelectorCircle.Parent = self.SaturationSelector
    
    -- Add corner to make it circular
    Utils.RoundCorners(self.SaturationSelectorCircle, UDim.new(1, 0))
    
    -- Add stroke to selector
    Utils.AddStroke(
        self.SaturationSelectorCircle,
        Color3.fromRGB(0, 0, 0),
        1,
        0,
        107
    )
    
    -- Detection button
    self.SaturationButton = Instance.new("TextButton")
    self.SaturationButton.Name = "SaturationButton"
    self.SaturationButton.Size = UDim2.fromScale(1, 1)
    self.SaturationButton.BackgroundTransparency = 1
    self.SaturationButton.Text = ""
    self.SaturationButton.ZIndex = 104
    self.SaturationButton.Parent = self.SaturationContainer
end

-- Create the hue slider
function ColorPicker:CreateHueSlider()
    -- Container
    self.HueContainer = Instance.new("Frame")
    self.HueContainer.Name = "HueContainer"
    self.HueContainer.Size = UDim2.new(0, Config.Element.ColorPicker.HueSliderWidth, 0, 120)
    self.HueContainer.Position = UDim2.new(1, -Config.Element.Padding - Config.Element.ColorPicker.HueSliderWidth, 0, 40)
    self.HueContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HueContainer.BorderSizePixel = 0
    self.HueContainer.ZIndex = 101
    self.HueContainer.Parent = self.Popup
    
    -- Add corner
    Utils.RoundCorners(self.HueContainer, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.HueContainer,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        101
    )
    
    -- Hue gradient
    self.HueGradient = Instance.new("UIGradient")
    self.HueGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),     -- Red
        ColorSequenceKeypoint.new(0.167, Color3.fromRGB(255, 255, 0)), -- Yellow
        ColorSequenceKeypoint.new(0.333, Color3.fromRGB(0, 255, 0)),   -- Green
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),   -- Cyan
        ColorSequenceKeypoint.new(0.667, Color3.fromRGB(0, 0, 255)),   -- Blue
        ColorSequenceKeypoint.new(0.833, Color3.fromRGB(255, 0, 255)), -- Magenta
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))      -- Red
    })
    self.HueGradient.Rotation = 90
    self.HueGradient.Parent = self.HueContainer
    
    -- Hue selector
    self.HueSelector = Instance.new("Frame")
    self.HueSelector.Name = "HueSelector"
    self.HueSelector.Size = UDim2.new(1, 4, 0, 3)
    self.HueSelector.Position = UDim2.new(0, -2, 0, 0)
    self.HueSelector.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HueSelector.BorderSizePixel = 0
    self.HueSelector.ZIndex = 103
    self.HueSelector.Parent = self.HueContainer
    
    -- Add stroke to selector
    Utils.AddStroke(
        self.HueSelector,
        Color3.fromRGB(0, 0, 0),
        1,
        0,
        104
    )
    
    -- Detection button
    self.HueButton = Instance.new("TextButton")
    self.HueButton.Name = "HueButton"
    self.HueButton.Size = UDim2.fromScale(1, 1)
    self.HueButton.BackgroundTransparency = 1
    self.HueButton.Text = ""
    self.HueButton.ZIndex = 102
    self.HueButton.Parent = self.HueContainer
end

-- Create the alpha slider
function ColorPicker:CreateAlphaSlider()
    -- Container
    self.AlphaContainer = Instance.new("Frame")
    self.AlphaContainer.Name = "AlphaContainer"
    self.AlphaContainer.Size = UDim2.new(1, -Config.Element.Padding * 2, 0, Config.Element.ColorPicker.AlphaSliderHeight)
    self.AlphaContainer.Position = UDim2.new(0, Config.Element.Padding, 0, 165)
    self.AlphaContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.AlphaContainer.BorderSizePixel = 0
    self.AlphaContainer.ZIndex = 101
    self.AlphaContainer.Parent = self.Popup
    
    -- Add corner
    Utils.RoundCorners(self.AlphaContainer, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.AlphaContainer,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        101
    )
    
    -- Checkered background for transparency
    self.AlphaPattern = Instance.new("Frame")
    self.AlphaPattern.Name = "AlphaPattern"
    self.AlphaPattern.Size = UDim2.fromScale(1, 1)
    self.AlphaPattern.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.AlphaPattern.BorderSizePixel = 0
    self.AlphaPattern.ZIndex = 102
    self.AlphaPattern.Parent = self.AlphaContainer
    
    -- Pattern image
    self.AlphaPatternImage = Instance.new("ImageLabel")
    self.AlphaPatternImage.Name = "PatternImage"
    self.AlphaPatternImage.Size = UDim2.fromScale(1, 1)
    self.AlphaPatternImage.BackgroundTransparency = 1
    self.AlphaPatternImage.Image = "rbxassetid://4581716129"  -- Transparency pattern asset
    self.AlphaPatternImage.ScaleType = Enum.ScaleType.Tile
    self.AlphaPatternImage.TileSize = UDim2.fromOffset(16, 16)
    self.AlphaPatternImage.ZIndex = 102
    self.AlphaPatternImage.Parent = self.AlphaPattern
    
    -- Alpha gradient
    self.AlphaGradient = Instance.new("Frame")
    self.AlphaGradient.Name = "AlphaGradient"
    self.AlphaGradient.Size = UDim2.fromScale(1, 1)
    self.AlphaGradient.BackgroundColor3 = self.Color
    self.AlphaGradient.BorderSizePixel = 0
    self.AlphaGradient.ZIndex = 103
    self.AlphaGradient.Parent = self.AlphaContainer
    
    -- Add corner
    Utils.RoundCorners(self.AlphaGradient, UDim.new(0, 4))
    
    -- Alpha gradient UIGradient
    self.AlphaUIGradient = Instance.new("UIGradient")
    self.AlphaUIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
    })
    self.AlphaUIGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    self.AlphaUIGradient.Rotation = 0
    self.AlphaUIGradient.Parent = self.AlphaGradient
    
    -- Alpha selector
    self.AlphaSelector = Instance.new("Frame")
    self.AlphaSelector.Name = "AlphaSelector"
    self.AlphaSelector.Size = UDim2.new(0, 3, 1, 4)
    self.AlphaSelector.Position = UDim2.new(1, 0, 0, -2)
    self.AlphaSelector.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.AlphaSelector.BorderSizePixel = 0
    self.AlphaSelector.ZIndex = 105
    self.AlphaSelector.Parent = self.AlphaContainer
    
    -- Add stroke to selector
    Utils.AddStroke(
        self.AlphaSelector,
        Color3.fromRGB(0, 0, 0),
        1,
        0,
        106
    )
    
    -- Detection button
    self.AlphaButton = Instance.new("TextButton")
    self.AlphaButton.Name = "AlphaButton"
    self.AlphaButton.Size = UDim2.fromScale(1, 1)
    self.AlphaButton.BackgroundTransparency = 1
    self.AlphaButton.Text = ""
    self.AlphaButton.ZIndex = 104
    self.AlphaButton.Parent = self.AlphaContainer
end

-- Create color input fields (RGB, HEX)
function ColorPicker:CreateColorInputs()
    -- Container
    local baseY = self.UseAlpha and 185 or 165
    
    self.InputsContainer = Instance.new("Frame")
    self.InputsContainer.Name = "InputsContainer"
    self.InputsContainer.Size = UDim2.new(1, -Config.Element.Padding * 2, 0, 60)
    self.InputsContainer.Position = UDim2.new(0, Config.Element.Padding, 0, baseY)
    self.InputsContainer.BackgroundTransparency = 1
    self.InputsContainer.ZIndex = 101
    self.InputsContainer.Parent = self.Popup
    
    -- RGB inputs
    local inputWidth = (Config.Element.ColorPicker.PickerWidth - Config.Element.Padding * 5) / 3
    
    -- R input
    self.RInput = self:CreateColorInput("R", UDim2.new(0, inputWidth, 0, 25), UDim2.new(0, 0, 0, 0), 101)
    
    -- G input
    self.GInput = self:CreateColorInput("G", UDim2.new(0, inputWidth, 0, 25), UDim2.new(0, inputWidth + Config.Element.Padding, 0, 0), 101)
    
    -- B input
    self.BInput = self:CreateColorInput("B", UDim2.new(0, inputWidth, 0, 25), UDim2.new(0, (inputWidth + Config.Element.Padding) * 2, 0, 0), 101)
    
    -- HEX input
    self.HexInput = self:CreateColorInput("Hex", UDim2.new(1, 0, 0, 25), UDim2.new(0, 0, 0, 30), 101)
end

-- Create a single color input field
function ColorPicker:CreateColorInput(name, size, position, zIndex)
    -- Container
    local container = Instance.new("Frame")
    container.Name = name .. "Container"
    container.Size = size
    container.Position = position
    container.BackgroundTransparency = 1
    container.ZIndex = zIndex
    container.Parent = self.InputsContainer
    
    -- Label
    local label = Instance.new("TextLabel")
    label.Name = name .. "Label"
    label.Size = UDim2.new(0, 20, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = Config.Element.Font
    label.TextSize = Config.Element.TextSize - 2
    label.TextColor3 = self:GetTheme().ColorPicker.TextColor
    label.Text = name .. ":"
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = zIndex + 1
    label.Parent = container
    
    -- Input box
    local input = Instance.new("TextBox")
    input.Name = name .. "Input"
    input.Size = UDim2.new(1, -24, 1, 0)
    input.Position = UDim2.new(0, 24, 0, 0)
    input.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    input.BackgroundTransparency = 0.5
    input.Font = Config.Element.Font
    input.TextSize = Config.Element.TextSize - 2
    input.TextColor3 = self:GetTheme().ColorPicker.TextColor
    input.Text = ""
    input.PlaceholderText = name == "Hex" and "#FFFFFF" or "255"
    input.ClearTextOnFocus = false
    input.ZIndex = zIndex + 1
    input.Parent = container
    
    -- Add corner
    Utils.RoundCorners(input, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        input,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        zIndex + 1
    )
    
    return input
end

-- Create action buttons (Rainbow, Cancel, Confirm)
function ColorPicker:CreateButtons()
    -- Base position calculation
    local baseY = self.UseAlpha and 250 or 230
    
    -- Container
    self.ButtonsContainer = Instance.new("Frame")
    self.ButtonsContainer.Name = "ButtonsContainer"
    self.ButtonsContainer.Size = UDim2.new(1, -Config.Element.Padding * 2, 0, 30)
    self.ButtonsContainer.Position = UDim2.new(0, Config.Element.Padding, 0, baseY)
    self.ButtonsContainer.BackgroundTransparency = 1
    self.ButtonsContainer.ZIndex = 101
    self.ButtonsContainer.Parent = self.Popup
    
    -- Rainbow toggle
    self.RainbowToggle = Instance.new("Frame")
    self.RainbowToggle.Name = "RainbowToggle"
    self.RainbowToggle.Size = UDim2.new(0, 90, 0, 24)
    self.RainbowToggle.Position = UDim2.new(0, 0, 0, 3)
    self.RainbowToggle.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    self.RainbowToggle.ZIndex = 102
    self.RainbowToggle.Parent = self.ButtonsContainer
    
    -- Add corner
    Utils.RoundCorners(self.RainbowToggle, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.RainbowToggle,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        102
    )
    
    -- Rainbow text
    self.RainbowText = Instance.new("TextLabel")
    self.RainbowText.Name = "RainbowText"
    self.RainbowText.Size = UDim2.new(1, -24, 1, 0)
    self.RainbowText.BackgroundTransparency = 1
    self.RainbowText.Font = Config.Element.Font
    self.RainbowText.TextSize = Config.Element.TextSize - 2
    self.RainbowText.TextColor3 = self:GetTheme().ColorPicker.TextColor
    self.RainbowText.Text = "Rainbow"
    self.RainbowText.TextXAlignment = Enum.TextXAlignment.Left
    self.RainbowText.Position = UDim2.new(0, 5, 0, 0)
    self.RainbowText.ZIndex = 103
    self.RainbowText.Parent = self.RainbowToggle
    
    -- Rainbow indicator
    self.RainbowIndicator = Instance.new("Frame")
    self.RainbowIndicator.Name = "RainbowIndicator"
    self.RainbowIndicator.Size = UDim2.fromOffset(16, 16)
    self.RainbowIndicator.Position = UDim2.new(1, -20, 0.5, -8)
    self.RainbowIndicator.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    self.RainbowIndicator.ZIndex = 103
    self.RainbowIndicator.Parent = self.RainbowToggle
    
    -- Add corner to make it circular
    Utils.RoundCorners(self.RainbowIndicator, UDim.new(1, 0))
    
    -- Rainbow button
    self.RainbowButton = Instance.new("TextButton")
    self.RainbowButton.Name = "RainbowButton"
    self.RainbowButton.Size = UDim2.fromScale(1, 1)
    self.RainbowButton.BackgroundTransparency = 1
    self.RainbowButton.Text = ""
    self.RainbowButton.ZIndex = 104
    self.RainbowButton.Parent = self.RainbowToggle
    
    -- Cancel button
    self.CancelButton = Instance.new("TextButton")
    self.CancelButton.Name = "CancelButton"
    self.CancelButton.Size = UDim2.new(0, 50, 0, 24)
    self.CancelButton.Position = UDim2.new(1, -110, 0, 3)
    self.CancelButton.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    self.CancelButton.Font = Config.Element.Font
    self.CancelButton.TextSize = Config.Element.TextSize - 2
    self.CancelButton.TextColor3 = self:GetTheme().ColorPicker.TextColor
    self.CancelButton.Text = "Cancel"
    self.CancelButton.ZIndex = 102
    self.CancelButton.Parent = self.ButtonsContainer
    
    -- Add corner
    Utils.RoundCorners(self.CancelButton, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.CancelButton,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        102
    )
    
    -- Confirm button
    self.ConfirmButton = Instance.new("TextButton")
    self.ConfirmButton.Name = "ConfirmButton"
    self.ConfirmButton.Size = UDim2.new(0, 50, 0, 24)
    self.ConfirmButton.Position = UDim2.new(1, -55, 0, 3)
    self.ConfirmButton.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    self.ConfirmButton.Font = Config.Element.Font
    self.ConfirmButton.TextSize = Config.Element.TextSize - 2
    self.ConfirmButton.TextColor3 = self:GetTheme().ColorPicker.TextColor
    self.ConfirmButton.Text = "OK"
    self.ConfirmButton.ZIndex = 102
    self.ConfirmButton.Parent = self.ButtonsContainer
    
    -- Add corner
    Utils.RoundCorners(self.ConfirmButton, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.ConfirmButton,
        self:GetTheme().ColorPicker.BorderColor,
        1,
        0,
        102
    )
    
    -- Update popup size
    self.Popup.Size = UDim2.fromOffset(Config.Element.ColorPicker.PickerWidth, baseY + 40)
end

-- Set up event connections
function ColorPicker:SetupConnections()
    -- Mouse enter
    self.MouseEnterConnection = self.PickerFrame.MouseEnter:Connect(function()
        if not self.Disabled then
            self:OnMouseEnter()
        end
    end)
    
    -- Mouse leave
    self.MouseLeaveConnection = self.PickerFrame.MouseLeave:Connect(function()
        if not self.Disabled then
            self:OnMouseLeave()
        end
    end)
    
    -- Button pressed
    self.ButtonPressedConnection = self.Button.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:ToggleColorPicker()
        end
    end)
    
    -- Input began for picker interactions
    self.InputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Check for picker interactions
            if self.PickerOpen then
                -- Check for saturation picker
                if self.SaturationButton.Visible and self:IsMouseOverFrame(self.SaturationContainer) then
                    self.PickerDragging.Saturation = true
                    self:UpdateSaturationSelector(input)
                    return
                end
                
                -- Check for hue slider
                if self.HueButton.Visible and self:IsMouseOverFrame(self.HueContainer) then
                    self.PickerDragging.Hue = true
                    self:UpdateHueSelector(input)
                    return
                end
                
                -- Check for alpha slider
                if self.UseAlpha and self.AlphaButton.Visible and self:IsMouseOverFrame(self.AlphaContainer) then
                    self.PickerDragging.Alpha = true
                    self:UpdateAlphaSelector(input)
                    return
                end
            end
        end
    end)
    
    -- Input ended
    self.InputEndedConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Stop all dragging
            self.PickerDragging.Saturation = false
            self.PickerDragging.Hue = false
            self.PickerDragging.Alpha = false
        end
    end)
    
    -- Mouse movement for picker interactions
    self.MouseMoveConnection = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            -- Handle picker dragging
            if self.PickerDragging.Saturation then
                self:UpdateSaturationSelector(input)
            elseif self.PickerDragging.Hue then
                self:UpdateHueSelector(input)
            elseif self.PickerDragging.Alpha then
                self:UpdateAlphaSelector(input)
            end
        end
    end)
    
    -- Setup RGB input connections
    self.RInputConnection = self.RInput.FocusLost:Connect(function(enterPressed)
        self:UpdateFromRGBInput("R")
    end)
    
    self.GInputConnection = self.GInput.FocusLost:Connect(function(enterPressed)
        self:UpdateFromRGBInput("G")
    end)
    
    self.BInputConnection = self.BInput.FocusLost:Connect(function(enterPressed)
        self:UpdateFromRGBInput("B")
    end)
    
    -- Setup HEX input connection
    self.HexInputConnection = self.HexInput.FocusLost:Connect(function(enterPressed)
        self:UpdateFromHexInput()
    end)
    
    -- Rainbow toggle
    self.RainbowToggleConnection = self.RainbowButton.MouseButton1Click:Connect(function()
        self:ToggleRainbow()
    end)
    
    -- Cancel button
    self.CancelButtonConnection = self.CancelButton.MouseButton1Click:Connect(function()
        self:ToggleColorPicker(false)
    end)
    
    -- Confirm button
    self.ConfirmButtonConnection = self.ConfirmButton.MouseButton1Click:Connect(function()
        -- Apply the color
        self:ApplyColor()
        self:ToggleColorPicker(false)
    end)
    
    -- Rainbow updater
    self.RainbowUpdateConnection = nil
    
    -- Input outside picker (for closing)
    self.InputOutsideConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if self.PickerOpen then
                -- Check if click is outside picker
                if not self:IsMouseOverFrame(self.PickerFrame) and not self:IsMouseOverFrame(self.Popup) then
                    self:ToggleColorPicker(false)
                end
            end
        end
    end)
    
    -- Theme changed
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Get current theme
function ColorPicker:GetTheme()
    return self.CustomTheme or ThemeManager:GetTheme().Element
end

-- Update color picker theme
function ColorPicker:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors based on theme
    self.PickerFrame.BackgroundColor3 = self:GetTheme().ColorPicker.Background
    self.TextLabel.TextColor3 = self:GetTheme().ColorPicker.TextColor
    self.Stroke.Color = self:GetTheme().ColorPicker.BorderColor
    self.ColorSwatchStroke.Color = self:GetTheme().ColorPicker.BorderColor
    
    -- Update popup elements if created
    if self.Popup then
        self.Popup.BackgroundColor3 = self:GetTheme().ColorPicker.Background
        self.PopupTitle.TextColor3 = self:GetTheme().ColorPicker.TextColor
        
        -- Input fields
        for _, input in pairs({self.RInput, self.GInput, self.BInput, self.HexInput}) do
            if input then
                input.BackgroundColor3 = self:GetTheme().ColorPicker.Background
                input.TextColor3 = self:GetTheme().ColorPicker.TextColor
            end
        end
        
        -- Buttons
        for _, button in pairs({self.RainbowToggle, self.CancelButton, self.ConfirmButton}) do
            if button then
                button.BackgroundColor3 = self:GetTheme().ColorPicker.Background
                
                -- Text label for the rainbow toggle
                if button == self.RainbowToggle then
                    self.RainbowText.TextColor3 = self:GetTheme().ColorPicker.TextColor
                else
                    button.TextColor3 = self:GetTheme().ColorPicker.TextColor
                end
            end
        end
    end
    
    -- Update state
    self:UpdateState()
end

-- Handle mouse enter
function ColorPicker:OnMouseEnter()
    self.Hovering = true
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 0.9},
        Config.Element.AnimationDuration
    )
    
    -- Tween color swatch
    Utils.Tween(
        self.ColorSwatch,
        {Size = UDim2.fromOffset(Config.Element.ColorPicker.SwatchSize + 2, Config.Element.ColorPicker.SwatchSize + 2)},
        Config.Element.AnimationDuration
    )
    Utils.Tween(
        self.ColorSwatch,
        {Position = UDim2.new(1, -Config.Element.ColorPicker.SwatchSize - Config.Element.Padding - 1, 0.5, -Config.Element.ColorPicker.SwatchSize / 2 - 1)},
        Config.Element.AnimationDuration
    )
end

-- Handle mouse leave
function ColorPicker:OnMouseLeave()
    self.Hovering = false
    
    -- Tween hover overlay
    Utils.Tween(
        self.HoverOverlay,
        {BackgroundTransparency = 1},
        Config.Element.AnimationDuration
    )
    
    -- Tween color swatch back
    Utils.Tween(
        self.ColorSwatch,
        {Size = UDim2.fromOffset(Config.Element.ColorPicker.SwatchSize, Config.Element.ColorPicker.SwatchSize)},
        Config.Element.AnimationDuration
    )
    Utils.Tween(
        self.ColorSwatch,
        {Position = UDim2.new(1, -Config.Element.ColorPicker.SwatchSize - Config.Element.Padding, 0.5, -Config.Element.ColorPicker.SwatchSize / 2)},
        Config.Element.AnimationDuration
    )
end

-- Toggle color picker popup
function ColorPicker:ToggleColorPicker(state)
    -- Set state explicitly if provided, otherwise toggle
    if state ~= nil then
        self.PickerOpen = state
    else
        self.PickerOpen = not self.PickerOpen
    end
    
    if self.PickerOpen then
        -- Reset to current color
        self:UpdateColorPickerPositions()
        self:UpdateInputs()
        
        -- Show popup
        self.Popup.Visible = true
        
        -- Start rainbow update if needed
        if self.RainbowMode then
            self:StartRainbowUpdate()
        end
    else
        -- Hide popup
        self.Popup.Visible = false
        
        -- Stop rainbow update
        self:StopRainbowUpdate()
    end
end

-- Update saturation selector position based on input
function ColorPicker:UpdateSaturationSelector(input)
    -- Get mouse position relative to saturation container
    local mousePos = UserInputService:GetMouseLocation()
    local containerPos = self.SaturationContainer.AbsolutePosition
    local containerSize = self.SaturationContainer.AbsoluteSize
    
    -- Calculate relative position (0-1)
    local relativeX = math.clamp((mousePos.X - containerPos.X) / containerSize.X, 0, 1)
    local relativeY = math.clamp((mousePos.Y - containerPos.Y) / containerSize.Y, 0, 1)
    
    -- Update selector position
    self.SaturationSelector.Position = UDim2.fromScale(relativeX, relativeY)
    
    -- Update color based on position
    self:UpdateColor()
end

-- Update hue selector position based on input
function ColorPicker:UpdateHueSelector(input)
    -- Get mouse position relative to hue container
    local mousePos = UserInputService:GetMouseLocation()
    local containerPos = self.HueContainer.AbsolutePosition
    local containerSize = self.HueContainer.AbsoluteSize
    
    -- Calculate relative position (0-1)
    local relativeY = math.clamp((mousePos.Y - containerPos.Y) / containerSize.Y, 0, 1)
    
    -- Update selector position
    self.HueSelector.Position = UDim2.new(0, -2, relativeY, 0)
    
    -- Update hue overlay color
    local hue = 1 - relativeY
    self.HueOverlay.BackgroundColor3 = self:HueToColor(hue)
    
    -- Update color based on position
    self:UpdateColor()
end

-- Update alpha selector position based on input
function ColorPicker:UpdateAlphaSelector(input)
    if not self.UseAlpha then return end
    
    -- Get mouse position relative to alpha container
    local mousePos = UserInputService:GetMouseLocation()
    local containerPos = self.AlphaContainer.AbsolutePosition
    local containerSize = self.AlphaContainer.AbsoluteSize
    
    -- Calculate relative position (0-1)
    local relativeX = math.clamp((mousePos.X - containerPos.X) / containerSize.X, 0, 1)
    
    -- Update selector position
    self.AlphaSelector.Position = UDim2.new(relativeX, 0, 0, -2)
    
    -- Update alpha
    self.Alpha = relativeX
    
    -- Update color based on position
    self:UpdateColor()
end

-- Check if mouse is over a frame
function ColorPicker:IsMouseOverFrame(frame)
    local mousePos = UserInputService:GetMouseLocation()
    local framePos = frame.AbsolutePosition
    local frameSize = frame.AbsoluteSize
    
    return (
        mousePos.X >= framePos.X and
        mousePos.X <= framePos.X + frameSize.X and
        mousePos.Y >= framePos.Y and
        mousePos.Y <= framePos.Y + frameSize.Y
    )
end

-- Convert hue to Color3
function ColorPicker:HueToColor(hue)
    -- Hue cycle: Red -> Yellow -> Green -> Cyan -> Blue -> Magenta -> Red
    if hue <= 0 then
        return Color3.fromRGB(255, 0, 0)
    elseif hue < 1/6 then
        return Color3.fromRGB(255, 255 * (hue * 6), 0)
    elseif hue < 2/6 then
        return Color3.fromRGB(255 * (2 - 6 * hue), 255, 0)
    elseif hue < 3/6 then
        return Color3.fromRGB(0, 255, 255 * (6 * hue - 2))
    elseif hue < 4/6 then
        return Color3.fromRGB(0, 255 * (4 - 6 * hue), 255)
    elseif hue < 5/6 then
        return Color3.fromRGB(255 * (6 * hue - 4), 0, 255)
    elseif hue < 1 then
        return Color3.fromRGB(255, 0, 255 * (6 - 6 * hue))
    else
        return Color3.fromRGB(255, 0, 0)
    end
end

-- Update color from current selector positions
function ColorPicker:UpdateColor()
    -- Stop rainbow mode when manually changing color
    if self.RainbowMode then
        self:ToggleRainbow(false)
    end
    
    -- Get hue from position
    local huePos = self.HueSelector.Position.Y.Scale
    local hue = 1 - huePos
    
    -- Get saturation/value from position
    local satPos = self.SaturationSelector.Position
    local saturation = satPos.X.Scale
    local value = 1 - satPos.Y.Scale
    
    -- Convert HSV to RGB
    local color = self:HSVToRGB(hue, saturation, value)
    
    -- Store the color
    self.Color = color
    
    -- Update color displays
    self.ColorSwatch.BackgroundColor3 = color
    self.PopupPreview.BackgroundColor3 = color
    self.AlphaGradient.BackgroundColor3 = color
    
    -- Update inputs
    self:UpdateInputs()
    
    -- Update transparency if alpha is enabled
    if self.UseAlpha then
        self.ColorSwatch.BackgroundTransparency = 1 - self.Alpha
        self.PopupPreview.BackgroundTransparency = 1 - self.Alpha
    end
end

-- Update color inputs (RGB, HEX)
function ColorPicker:UpdateInputs()
    -- RGB values
    local r, g, b = math.floor(self.Color.R * 255 + 0.5), math.floor(self.Color.G * 255 + 0.5), math.floor(self.Color.B * 255 + 0.5)
    
    -- Update RGB inputs
    self.RInput.Text = tostring(r)
    self.GInput.Text = tostring(g)
    self.BInput.Text = tostring(b)
    
    -- Update HEX input
    self.HexInput.Text = "#" .. string.format("%02X%02X%02X", r, g, b)
end

-- Update color picker positions based on current color
function ColorPicker:UpdateColorPickerPositions()
    -- Convert color to HSV
    local h, s, v = self:RGBToHSV(self.Color)
    
    -- Update hue selector
    self.HueSelector.Position = UDim2.new(0, -2, 1 - h, 0)
    
    -- Update hue overlay
    self.HueOverlay.BackgroundColor3 = self:HueToColor(h)
    
    -- Update saturation selector
    self.SaturationSelector.Position = UDim2.fromScale(s, 1 - v)
    
    -- Update alpha selector if enabled
    if self.UseAlpha then
        self.AlphaSelector.Position = UDim2.new(self.Alpha, 0, 0, -2)
    end
end

-- Update from RGB input
function ColorPicker:UpdateFromRGBInput(channel)
    -- Get input value
    local inputField = channel == "R" and self.RInput or channel == "G" and self.GInput or self.BInput
    local value = tonumber(inputField.Text)
    
    -- Validate input
    if not value then
        self:UpdateInputs() -- Reset to current value
        return
    end
    
    -- Clamp value
    value = math.clamp(math.floor(value), 0, 255)
    inputField.Text = tostring(value)
    
    -- Get current RGB values
    local r = channel == "R" and value or math.floor(self.Color.R * 255 + 0.5)
    local g = channel == "G" and value or math.floor(self.Color.G * 255 + 0.5)
    local b = channel == "B" and value or math.floor(self.Color.B * 255 + 0.5)
    
    -- Update color
    self.Color = Color3.fromRGB(r, g, b)
    
    -- Update color displays
    self.ColorSwatch.BackgroundColor3 = self.Color
    self.PopupPreview.BackgroundColor3 = self.Color
    self.AlphaGradient.BackgroundColor3 = self.Color
    
    -- Update other inputs
    if channel == "R" then
        self.GInput.Text = tostring(g)
        self.BInput.Text = tostring(b)
    elseif channel == "G" then
        self.RInput.Text = tostring(r)
        self.BInput.Text = tostring(b)
    else
        self.RInput.Text = tostring(r)
        self.GInput.Text = tostring(g)
    end
    
    -- Update HEX input
    self.HexInput.Text = "#" .. string.format("%02X%02X%02X", r, g, b)
    
    -- Update picker positions
    self:UpdateColorPickerPositions()
end

-- Update from HEX input
function ColorPicker:UpdateFromHexInput()
    -- Get input value
    local hex = self.HexInput.Text:gsub("#", ""):upper()
    
    -- Validate format
    if hex:match("^%x%x%x%x%x%x$") then
        -- Valid hex, update color
        local r = tonumber("0x" .. hex:sub(1, 2))
        local g = tonumber("0x" .. hex:sub(3, 4))
        local b = tonumber("0x" .. hex:sub(5, 6))
        
        self.Color = Color3.fromRGB(r, g, b)
        
        -- Update color displays
        self.ColorSwatch.BackgroundColor3 = self.Color
        self.PopupPreview.BackgroundColor3 = self.Color
        self.AlphaGradient.BackgroundColor3 = self.Color
        
        -- Update RGB inputs
        self.RInput.Text = tostring(r)
        self.GInput.Text = tostring(g)
        self.BInput.Text = tostring(b)
        
        -- Format hex properly
        self.HexInput.Text = "#" .. hex
        
        -- Update picker positions
        self:UpdateColorPickerPositions()
    else
        -- Invalid hex, reset to current value
        self:UpdateInputs()
    end
end

-- Toggle rainbow mode
function ColorPicker:ToggleRainbow(state)
    -- Set state explicitly if provided, otherwise toggle
    if state ~= nil then
        self.RainbowMode = state
    else
        self.RainbowMode = not self.RainbowMode
    end
    
    -- Update indicator
    self.RainbowIndicator.BackgroundColor3 = self.RainbowMode and Color3.fromRGB(40, 200, 40) or Color3.fromRGB(60, 60, 60)
    
    if self.RainbowMode then
        -- Start rainbow update
        self:StartRainbowUpdate()
    else
        -- Stop rainbow update
        self:StopRainbowUpdate()
    end
end

-- Start rainbow update loop
function ColorPicker:StartRainbowUpdate()
    -- Disconnect existing connection if any
    self:StopRainbowUpdate()
    
    -- Create new update connection
    self.RainbowUpdateConnection = RunService.Heartbeat:Connect(function(deltaTime)
        -- Calculate new hue
        local hue = (tick() % self.RainbowSpeed) / self.RainbowSpeed
        
        -- Update color directly with full saturation and value
        local color = self:HSVToRGB(hue, 1, 1)
        self.Color = color
        
        -- Update displays
        self.ColorSwatch.BackgroundColor3 = color
        self.PopupPreview.BackgroundColor3 = color
        self.AlphaGradient.BackgroundColor3 = color
        
        -- Update hue selector position
        self.HueSelector.Position = UDim2.new(0, -2, 1 - hue, 0)
        
        -- Update hue overlay
        self.HueOverlay.BackgroundColor3 = self:HueToColor(hue)
        
        -- Update saturation selector to top-right (full saturation, full value)
        self.SaturationSelector.Position = UDim2.fromScale(1, 0)
        
        -- Update inputs
        self:UpdateInputs()
    end)
end

-- Stop rainbow update loop
function ColorPicker:StopRainbowUpdate()
    if self.RainbowUpdateConnection then
        self.RainbowUpdateConnection:Disconnect()
        self.RainbowUpdateConnection = nil
    end
end

-- Apply the selected color
function ColorPicker:ApplyColor()
    -- Call the callback
    task.spawn(function()
        if self.UseAlpha then
            self.Callback(self.Color, self.Alpha)
        else
            self.Callback(self.Color)
        end
    end)
    
    -- Fire change event
    if self.UseAlpha then
        self.OnChanged:Fire(self.Color, self.Alpha)
    else
        self.OnChanged:Fire(self.Color)
    end
end

-- Convert RGB to HSV
function ColorPicker:RGBToHSV(color)
    local r, g, b = color.R, color.G, color.B
    local max, min = math.max(r, g, b), math.min(r, g, b)
    local h, s, v
    
    -- Calculate value
    v = max
    
    -- Calculate saturation
    if max == 0 then
        s = 0
    else
        s = (max - min) / max
    end
    
    -- Calculate hue
    if max == min then
        h = 0 -- No saturation
    else
        if max == r then
            h = (g - b) / (max - min)
            if g < b then h = h + 6 end
        elseif max == g then
            h = (b - r) / (max - min) + 2
        else
            h = (r - g) / (max - min) + 4
        end
        h = h / 6
    end
    
    return h, s, v
end

-- Convert HSV to RGB
function ColorPicker:HSVToRGB(h, s, v)
    local r, g, b
    
    if s == 0 then
        -- If saturation is 0, color is grayscale
        r, g, b = v, v, v
    else
        local i = math.floor(h * 6)
        local f = h * 6 - i
        local p = v * (1 - s)
        local q = v * (1 - f * s)
        local t = v * (1 - (1 - f) * s)
        
        i = i % 6
        
        if i == 0 then r, g, b = v, t, p
        elseif i == 1 then r, g, b = q, v, p
        elseif i == 2 then r, g, b = p, v, t
        elseif i == 3 then r, g, b = p, q, v
        elseif i == 4 then r, g, b = t, p, v
        elseif i == 5 then r, g, b = v, p, q
        end
    end
    
    return Color3.new(r, g, b)
end

-- Set color programmatically
function ColorPicker:SetColor(color, alpha)
    self.Color = color
    
    if alpha ~= nil and self.UseAlpha then
        self.Alpha = math.clamp(alpha, 0, 1)
    end
    
    -- Update displays
    self.ColorSwatch.BackgroundColor3 = color
    
    -- Update transparency if using alpha
    if self.UseAlpha then
        self.ColorSwatch.BackgroundTransparency = 1 - self.Alpha
    end
    
    -- Update picker positions if open
    if self.PickerOpen then
        self.PopupPreview.BackgroundColor3 = color
        self.AlphaGradient.BackgroundColor3 = color
        
        if self.UseAlpha then
            self.PopupPreview.BackgroundTransparency = 1 - self.Alpha
        end
        
        self:UpdateColorPickerPositions()
        self:UpdateInputs()
    end
    
    -- Call the callback
    task.spawn(function()
        if self.UseAlpha then
            self.Callback(self.Color, self.Alpha)
        else
            self.Callback(self.Color)
        end
    end)
    
    -- Fire change event
    if self.UseAlpha then
        self.OnChanged:Fire(self.Color, self.Alpha)
    else
        self.OnChanged:Fire(self.Color)
    end
end

-- Get the current color
function ColorPicker:GetColor()
    if self.UseAlpha then
        return self.Color, self.Alpha
    else
        return self.Color
    end
end

-- Set color picker disabled state
function ColorPicker:SetDisabled(disabled)
    self.Disabled = disabled
    
    -- Close picker if being disabled
    if disabled and self.PickerOpen then
        self:ToggleColorPicker(false)
    end
    
    self:UpdateState()
end

-- Set color picker text
function ColorPicker:SetText(text)
    self.Text = text
    self.TextLabel.Text = text
end

-- Update visual state based on properties
function ColorPicker:UpdateState()
    if self.Disabled then
        -- Disabled state
        self.PickerFrame.BackgroundColor3 = self:GetTheme().ColorPicker.Background
        self.TextLabel.TextColor3 = self:GetTheme().ColorPicker.TextColor
        
        -- Set transparency
        self.TextLabel.TextTransparency = 0.5
        self.PickerFrame.BackgroundTransparency = 0.5
        self.Stroke.Transparency = 0.5
        self.ColorSwatch.BackgroundTransparency = self.UseAlpha and math.max(0.5, 1 - self.Alpha) or 0.5
        self.ColorSwatchStroke.Transparency = 0.5
    else
        -- Enabled state
        self.PickerFrame.BackgroundColor3 = self:GetTheme().ColorPicker.Background
        self.TextLabel.TextColor3 = self:GetTheme().ColorPicker.TextColor
        
        -- Reset transparency
        self.TextLabel.TextTransparency = 0
        self.PickerFrame.BackgroundTransparency = 0
        self.Stroke.Transparency = 0
        self.ColorSwatch.BackgroundTransparency = self.UseAlpha and (1 - self.Alpha) or 0
        self.ColorSwatchStroke.Transparency = 0
    end
end

-- Clean up
function ColorPicker:Destroy()
    -- Stop rainbow update
    self:StopRainbowUpdate()
    
    -- Disconnect event connections
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.ButtonPressedConnection then
        self.ButtonPressedConnection:Disconnect()
    end
    
    if self.InputBeganConnection then
        self.InputBeganConnection:Disconnect()
    end
    
    if self.InputEndedConnection then
        self.InputEndedConnection:Disconnect()
    end
    
    if self.MouseMoveConnection then
        self.MouseMoveConnection:Disconnect()
    end
    
    if self.InputOutsideConnection then
        self.InputOutsideConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    if self.RInputConnection then
        self.RInputConnection:Disconnect()
    end
    
    if self.GInputConnection then
        self.GInputConnection:Disconnect()
    end
    
    if self.BInputConnection then
        self.BInputConnection:Disconnect()
    end
    
    if self.HexInputConnection then
        self.HexInputConnection:Disconnect()
    end
    
    if self.RainbowToggleConnection then
        self.RainbowToggleConnection:Disconnect()
    end
    
    if self.CancelButtonConnection then
        self.CancelButtonConnection:Disconnect()
    end
    
    if self.ConfirmButtonConnection then
        self.ConfirmButtonConnection:Disconnect()
    end
    
    -- Clean up events
    self.OnChanged:Destroy()
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return ColorPicker

-- ========================== Layout/Window.lua ==========================
--[[
    Window component for the UI library
    The main container for the entire UI
]]
local Window = {}
Window.__index = Window

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal
local TabManager
local Drag
local Init

-- Create a new window instance
function Window.new(options)
    -- Load dependencies
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
        TabManager = require(script.Parent.TabManager)
        Drag = requireModule("Drag")
        Init = requireModule("Init")
    end
    
    local self = setmetatable({}, Window)
    
    -- Default options
    options = options or {}
    self.Title = options.Title or "NebulaUI"
    self.Size = options.Size or Config.Window.DefaultSize
    self.Position = options.Position
    self.Theme = options.Theme
    self.Resizable = options.Resizable ~= false
    self.MinSize = options.MinSize or Config.Window.MinSize
    
    -- Validate size
    self.Size = Vector2.new(
        math.max(self.Size.X, self.MinSize.X),
        math.max(self.Size.Y, self.MinSize.Y)
    )
    
    -- Callbacks
    self.OnMinimize = options.OnMinimize
    self.OnClose = options.OnClose
    
    -- Internal state
    self.Dragging = false
    self.Resizing = false
    self.Minimized = false
    self.Tabs = {}
    self.CurrentTab = nil
    
    -- Events
    self.TabChanged = Signal.new()
    self.WindowResized = Signal.new()
    self.WindowClosed = Signal.new()
    self.WindowMinimized = Signal.new()
    
    -- Set theme if specified
    if self.Theme then
        ThemeManager:SetTheme(self.Theme)
    end
    
    -- Create window UI
    self:Create()
    
    -- Set up event connections
    self:SetupConnections()
    
    -- Return the object
    return self
end

-- Create window UI elements
function Window:Create()
    -- Main ScreenGui
    self.ScreenGui = Instance.new("ScreenGui")
    self.ScreenGui.Name = "NebulaUI_" .. Utils.GenerateUID()
    self.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    self.ScreenGui.ResetOnSpawn = false
    self.ScreenGui.IgnoreGuiInset = true
    
    -- Parent it appropriately
    if Init.IS_STUDIO then
        self.ScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    else
        pcall(function()
            self.ScreenGui.Parent = CoreGui
        end)
        
        if not self.ScreenGui.Parent then
            self.ScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
        end
    end
    
    -- Main window container
    self.Container = Instance.new("Frame")
    self.Container.Name = "WindowContainer"
    self.Container.Size = UDim2.fromOffset(self.Size.X, self.Size.Y)
    self.Container.BackgroundColor3 = ThemeManager:GetTheme().Window.Background
    self.Container.BorderSizePixel = 0
    self.Container.AnchorPoint = Vector2.new(0.5, 0.5)
    
    -- Set position or default to center
    if self.Position then
        self.Container.Position = UDim2.fromOffset(self.Position.X, self.Position.Y)
    else
        self.Container.Position = UDim2.fromScale(0.5, 0.5)
    end
    
    self.Container.Parent = self.ScreenGui
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.Container, UDim.new(0, Config.Window.CornerRadius.Offset))
    
    -- Add shadow
    self.Shadow = Utils.CreateShadow(
        self.Container, 
        Config.Window.ShadowSize, 
        Config.Window.ShadowTransparency
    )
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.Container,
        ThemeManager:GetTheme().Window.BorderColor,
        Config.Window.BorderWidth
    )
    
    -- Create title bar
    self:CreateTitleBar()
    
    -- Create content area
    self:CreateContentArea()
    
    -- Create tab manager
    self.TabController = TabManager.new(self.TabContainer)
    
    -- Create resize handle if resizable
    if self.Resizable then
        self:CreateResizeHandle()
    end
end

-- Create title bar
function Window:CreateTitleBar()
    -- Title bar
    self.TitleBar = Instance.new("Frame")
    self.TitleBar.Name = "TitleBar"
    self.TitleBar.Size = UDim2.new(1, 0, 0, Config.Window.TitleBarHeight)
    self.TitleBar.BackgroundColor3 = ThemeManager:GetTheme().Window.TopBar
    self.TitleBar.BorderSizePixel = 0
    self.TitleBar.Parent = self.Container
    
    -- Add corner to ensure the top corners are rounded
    local topCorner = Utils.RoundCorners(self.TitleBar, UDim.new(0, Config.Window.CornerRadius.Offset))
    
    -- Clip the bottom corners
    local clipFrame = Instance.new("Frame")
    clipFrame.Name = "BottomClip"
    clipFrame.Size = UDim2.new(1, 0, 0.5, 0)
    clipFrame.Position = UDim2.fromScale(0, 0.5)
    clipFrame.BackgroundColor3 = ThemeManager:GetTheme().Window.TopBar
    clipFrame.BorderSizePixel = 0
    clipFrame.ZIndex = self.TitleBar.ZIndex
    clipFrame.Parent = self.TitleBar
    
    -- Title text
    self.TitleLabel = Instance.new("TextLabel")
    self.TitleLabel.Name = "TitleText"
    self.TitleLabel.Size = UDim2.new(1, -80, 1, 0)
    self.TitleLabel.Position = UDim2.fromOffset(10, 0)
    self.TitleLabel.BackgroundTransparency = 1
    self.TitleLabel.Font = Config.Window.TitleFont
    self.TitleLabel.TextSize = Config.Window.TitleTextSize
    self.TitleLabel.TextColor3 = ThemeManager:GetTheme().Window.TextColor
    self.TitleLabel.Text = self.Title
    self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TitleLabel.Parent = self.TitleBar
    
    -- Create window controls
    self:CreateWindowControls()
    
    -- Make title bar draggable
    self.DragController = Drag.Enable(self.Container, self.TitleBar)
end

-- Create window control buttons (minimize, close)
function Window:CreateWindowControls()
    -- Controls container
    self.Controls = Instance.new("Frame")
    self.Controls.Name = "Controls"
    self.Controls.Size = UDim2.new(0, 60, 1, 0)
    self.Controls.Position = UDim2.new(1, -60, 0, 0)
    self.Controls.BackgroundTransparency = 1
    self.Controls.Parent = self.TitleBar
    
    -- Minimize button
    self.MinimizeButton = Instance.new("ImageButton")
    self.MinimizeButton.Name = "MinimizeButton"
    self.MinimizeButton.Size = UDim2.fromOffset(16, 16)
    self.MinimizeButton.Position = UDim2.new(0, 10, 0.5, -8)
    self.MinimizeButton.BackgroundTransparency = 1
    self.MinimizeButton.Image = "rbxassetid://6031090990" -- Minimize icon
    self.MinimizeButton.ImageColor3 = ThemeManager:GetTheme().Window.TextColor
    self.MinimizeButton.Parent = self.Controls
    
    -- Close button
    self.CloseButton = Instance.new("ImageButton")
    self.CloseButton.Name = "CloseButton"
    self.CloseButton.Size = UDim2.fromOffset(16, 16)
    self.CloseButton.Position = UDim2.new(0, 36, 0.5, -8)
    self.CloseButton.BackgroundTransparency = 1
    self.CloseButton.Image = "rbxassetid://6031094678" -- Close icon
    self.CloseButton.ImageColor3 = ThemeManager:GetTheme().Window.TextColor
    self.CloseButton.Parent = self.Controls
end

-- Create content area
function Window:CreateContentArea()
    -- Content frame
    self.ContentFrame = Instance.new("Frame")
    self.ContentFrame.Name = "ContentFrame"
    self.ContentFrame.Size = UDim2.new(1, 0, 1, -Config.Window.TitleBarHeight)
    self.ContentFrame.Position = UDim2.new(0, 0, 0, Config.Window.TitleBarHeight)
    self.ContentFrame.BackgroundColor3 = ThemeManager:GetTheme().Window.Background
    self.ContentFrame.BorderSizePixel = 0
    self.ContentFrame.Parent = self.Container
    
    -- Add padding
    self.ContentPadding = Utils.AddPadding(self.ContentFrame, Config.Window.Padding)
    
    -- Tab container
    self.TabContainer = Instance.new("Frame")
    self.TabContainer.Name = "TabContainer"
    self.TabContainer.Size = UDim2.fromScale(1, 1)
    self.TabContainer.BackgroundTransparency = 1
    self.TabContainer.Parent = self.ContentFrame
end

-- Create resize handle for window
function Window:CreateResizeHandle()
    -- Resize handle
    self.ResizeHandle = Instance.new("TextButton")
    self.ResizeHandle.Name = "ResizeHandle"
    self.ResizeHandle.Size = UDim2.fromOffset(Config.Window.ResizeHandleSize, Config.Window.ResizeHandleSize)
    self.ResizeHandle.Position = UDim2.new(1, -Config.Window.ResizeHandleSize, 1, -Config.Window.ResizeHandleSize)
    self.ResizeHandle.BackgroundTransparency = 1
    self.ResizeHandle.Text = ""
    self.ResizeHandle.ZIndex = 10
    self.ResizeHandle.Parent = self.Container
    
    -- Resize icon
    self.ResizeIcon = Instance.new("ImageLabel")
    self.ResizeIcon.Name = "ResizeIcon"
    self.ResizeIcon.Size = UDim2.fromOffset(12, 12)
    self.ResizeIcon.Position = UDim2.new(1, -12, 1, -12)
    self.ResizeIcon.BackgroundTransparency = 1
    self.ResizeIcon.Image = "rbxassetid://6031091004" -- Corner resize icon
    self.ResizeIcon.ImageColor3 = ThemeManager:GetTheme().Window.TextColor
    self.ResizeIcon.ImageTransparency = 0.5
    self.ResizeIcon.ZIndex = 9
    self.ResizeIcon.Parent = self.Container
end

-- Set up event connections
function Window:SetupConnections()
    -- Theme changed event
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
    
    -- Minimize button
    self.MinimizeButtonConnection = self.MinimizeButton.MouseButton1Click:Connect(function()
        self:Minimize()
    end)
    
    -- Close button
    self.CloseButtonConnection = self.CloseButton.MouseButton1Click:Connect(function()
        self:Close()
    end)
    
    -- Resize handle
    if self.Resizable then
        -- Mouse button down
        self.ResizeBeginConnection = self.ResizeHandle.MouseButton1Down:Connect(function()
            self:BeginResize()
        end)
        
        -- Mouse button up
        self.ResizeEndConnection = UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self:EndResize()
            end
        end)
        
        -- Mouse movement
        self.ResizeMoveConnection = UserInputService.InputChanged:Connect(function(input)
            if self.Resizing and input.UserInputType == Enum.UserInputType.MouseMovement then
                self:UpdateResize(input)
            end
        end)
        
        -- Mouse enter/leave resize handle
        self.ResizeEnterConnection = self.ResizeHandle.MouseEnter:Connect(function()
            self.ResizeIcon.ImageTransparency = 0
        end)
        
        self.ResizeLeaveConnection = self.ResizeHandle.MouseLeave:Connect(function()
            if not self.Resizing then
                self.ResizeIcon.ImageTransparency = 0.5
            end
        end)
    end
    
    -- Tab manager events
    self.TabManager_TabChangedConnection = self.TabController.TabChanged:Connect(function(tab)
        self.CurrentTab = tab
        self.TabChanged:Fire(tab)
    end)
end

-- Update theme
function Window:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors
    self.Container.BackgroundColor3 = theme.Window.Background
    self.TitleBar.BackgroundColor3 = theme.Window.TopBar
    self.TitleBar.BottomClip.BackgroundColor3 = theme.Window.TopBar
    self.ContentFrame.BackgroundColor3 = theme.Window.Background
    self.TitleLabel.TextColor3 = theme.Window.TextColor
    self.MinimizeButton.ImageColor3 = theme.Window.TextColor
    self.CloseButton.ImageColor3 = theme.Window.TextColor
    self.Stroke.Color = theme.Window.BorderColor
    self.Shadow.BackgroundColor3 = theme.Window.ShadowColor
    
    if self.ResizeIcon then
        self.ResizeIcon.ImageColor3 = theme.Window.TextColor
    end
    
    -- Update tab manager
    if self.TabController then
        self.TabController:UpdateTheme(theme)
    end
end

-- Begin resize operation
function Window:BeginResize()
    self.Resizing = true
    self.ResizeIcon.ImageTransparency = 0
    
    -- Store initial size and mouse position
    self.InitialSize = self.Container.AbsoluteSize
    self.InitialMousePos = UserInputService:GetMouseLocation()
end

-- Update resize operation
function Window:UpdateResize(input)
    if not self.Resizing then return end
    
    -- Calculate size delta
    local mousePos = UserInputService:GetMouseLocation()
    local delta = mousePos - self.InitialMousePos
    
    -- Calculate new size
    local newWidth = self.InitialSize.X + delta.X
    local newHeight = self.InitialSize.Y + delta.Y
    
    -- Enforce minimum size
    newWidth = math.max(newWidth, self.MinSize.X)
    newHeight = math.max(newHeight, self.MinSize.Y)
    
    -- Update container size
    self.Container.Size = UDim2.fromOffset(newWidth, newHeight)
    
    -- Fire resize event
    self.WindowResized:Fire(Vector2.new(newWidth, newHeight))
end

-- End resize operation
function Window:EndResize()
    self.Resizing = false
    
    -- Reset transparency if mouse is not over the handle
    local mousePos = UserInputService:GetMouseLocation()
    local handlePos = self.ResizeHandle.AbsolutePosition
    local handleSize = self.ResizeHandle.AbsoluteSize
    
    if not (
        mousePos.X >= handlePos.X and
        mousePos.X <= handlePos.X + handleSize.X and
        mousePos.Y >= handlePos.Y and
        mousePos.Y <= handlePos.Y + handleSize.Y
    ) then
        self.ResizeIcon.ImageTransparency = 0.5
    end
end

-- Minimize the window
function Window:Minimize()
    self.Minimized = not self.Minimized
    
    if self.Minimized then
        -- Store current height
        self.PreviousHeight = self.Container.Size.Y.Offset
        
        -- Tween to minimized state
        Utils.Tween(
            self.Container,
            {Size = UDim2.fromOffset(self.Container.Size.X.Offset, Config.Window.TitleBarHeight)},
            Config.Window.AnimationDuration
        )
        
        -- Hide content
        self.ContentFrame.Visible = false
        
        -- Update minimize icon
        self.MinimizeButton.Image = "rbxassetid://6031090987" -- Maximize icon
    else
        -- Tween back to previous height
        Utils.Tween(
            self.Container,
            {Size = UDim2.fromOffset(self.Container.Size.X.Offset, self.PreviousHeight)},
            Config.Window.AnimationDuration
        )
        
        -- Show content
        self.ContentFrame.Visible = true
        
        -- Update minimize icon
        self.MinimizeButton.Image = "rbxassetid://6031090990" -- Minimize icon
    end
    
    -- Call minimize callback if provided
    if self.OnMinimize then
        self.OnMinimize(self.Minimized)
    end
    
    -- Fire minimize event
    self.WindowMinimized:Fire(self.Minimized)
end

-- Close the window
function Window:Close()
    -- Call close callback if provided
    if self.OnClose then
        local shouldClose = self.OnClose()
        if shouldClose == false then
            return
        end
    end
    
    -- Tween out
    Utils.Tween(
        self.Container,
        {Size = UDim2.fromOffset(self.Container.Size.X.Offset, 0)},
        Config.Window.AnimationDuration,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out,
        0,
        false,
        function()
            -- Fire close event
            self.WindowClosed:Fire()
            
            -- Clean up
            self:Destroy()
        end
    )
end

-- Create a new tab
function Window:AddTab(options)
    options = options or {}
    
    -- Create tab through tab manager
    local tab = self.TabController:AddTab(options)
    table.insert(self.Tabs, tab)
    
    -- Select first tab by default
    if #self.Tabs == 1 then
        self.TabController:SelectTab(tab.Name)
        self.CurrentTab = tab
    end
    
    return tab
end

-- Set window title
function Window:SetTitle(title)
    self.Title = title
    self.TitleLabel.Text = title
end

-- Set window theme
function Window:SetTheme(theme)
    ThemeManager:SetTheme(theme)
end

-- Get all tabs
function Window:GetTabs()
    return self.Tabs
end

-- Select a tab by name
function Window:SelectTab(tabName)
    self.TabController:SelectTab(tabName)
end

-- Clean up and destroy
function Window:Destroy()
    -- Disconnect events
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    if self.MinimizeButtonConnection then
        self.MinimizeButtonConnection:Disconnect()
    end
    
    if self.CloseButtonConnection then
        self.CloseButtonConnection:Disconnect()
    end
    
    if self.ResizeBeginConnection then
        self.ResizeBeginConnection:Disconnect()
    end
    
    if self.ResizeEndConnection then
        self.ResizeEndConnection:Disconnect()
    end
    
    if self.ResizeMoveConnection then
        self.ResizeMoveConnection:Disconnect()
    end
    
    if self.ResizeEnterConnection then
        self.ResizeEnterConnection:Disconnect()
    end
    
    if self.ResizeLeaveConnection then
        self.ResizeLeaveConnection:Disconnect()
    end
    
    if self.TabManager_TabChangedConnection then
        self.TabManager_TabChangedConnection:Disconnect()
    end
    
    -- Destroy drag controller
    if self.DragController then
        self.DragController:Destroy()
    end
    
    -- Destroy tab controller
    if self.TabController then
        self.TabController:Destroy()
    end
    
    -- Clean up events
    self.TabChanged:Destroy()
    self.WindowResized:Destroy()
    self.WindowClosed:Destroy()
    self.WindowMinimized:Destroy()
    
    -- Destroy UI
    if self.ScreenGui then
        self.ScreenGui:Destroy()
    end
end

return Window

-- ========================== Layout/TabManager.lua ==========================
--[[
    TabManager component for the UI library
    Manages the tabs and their content
]]
local TabManager = {}
TabManager.__index = TabManager

-- Services
local TweenService = game:GetService("TweenService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal
local Section

-- Create a new tab manager instance
function TabManager.new(parent)
    -- Load dependencies
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
        Section = require(script.Parent.Section)
    end
    
    local self = setmetatable({}, TabManager)
    
    -- Parent container
    self.Parent = parent
    
    -- Internal state
    self.Tabs = {}
    self.TabButtons = {}
    self.CurrentTab = nil
    
    -- Events
    self.TabChanged = Signal.new()
    
    -- Create tab manager UI
    self:Create()
    
    -- Set up event connections
    self:SetupConnections()
    
    return self
end

-- Create tab manager UI
function TabManager:Create()
    -- Tab button container
    self.TabButtonContainer = Instance.new("Frame")
    self.TabButtonContainer.Name = "TabButtonContainer"
    self.TabButtonContainer.Size = UDim2.new(1, 0, 0, Config.Window.TabButtonHeight)
    self.TabButtonContainer.BackgroundTransparency = 1
    self.TabButtonContainer.Parent = self.Parent
    
    -- Add list layout for buttons
    self.TabButtonLayout = Utils.AddListLayout(
        self.TabButtonContainer,
        5,
        Enum.FillDirection.Horizontal,
        Enum.HorizontalAlignment.Left,
        Enum.VerticalAlignment.Center
    )
    
    -- Add padding to button container
    Utils.AddPadding(self.TabButtonContainer, 5)
    
    -- Tab content container
    self.TabContentContainer = Instance.new("Frame")
    self.TabContentContainer.Name = "TabContentContainer"
    self.TabContentContainer.Size = UDim2.new(1, 0, 1, -(Config.Window.TabButtonHeight + 5))
    self.TabContentContainer.Position = UDim2.new(0, 0, 0, Config.Window.TabButtonHeight + 5)
    self.TabContentContainer.BackgroundTransparency = 1
    self.TabContentContainer.Parent = self.Parent
end

-- Set up event connections
function TabManager:SetupConnections()
    -- Theme changed event
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Update theme
function TabManager:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update tab buttons
    for _, button in pairs(self.TabButtons) do
        if button.Selected then
            button.BackgroundColor3 = theme.Tab.BackgroundSelected
            button.TextLabel.TextColor3 = theme.Tab.TextColorSelected
        else
            button.BackgroundColor3 = theme.Tab.Background
            button.TextLabel.TextColor3 = theme.Tab.TextColor
        end
    end
    
    -- Update tabs content
    for _, tab in pairs(self.Tabs) do
        if tab.Sections then
            for _, section in pairs(tab.Sections) do
                section:UpdateTheme(theme)
            end
        end
    end
end

-- Create a new tab
function TabManager:AddTab(options)
    options = options or {}
    local name = options.Name or "Tab"
    local icon = options.Icon
    
    -- Create tab data
    local tab = {
        Name = name,
        Icon = icon,
        Content = Instance.new("ScrollingFrame"),
        Sections = {},
        ParentTab = self
    }
    
    -- Set up content frame
    tab.Content.Name = name .. "_Content"
    tab.Content.Size = UDim2.fromScale(1, 1)
    tab.Content.BackgroundTransparency = 1
    tab.Content.BorderSizePixel = 0
    tab.Content.ScrollBarThickness = 4
    tab.Content.ScrollBarImageColor3 = ThemeManager:GetTheme().Section.BorderColor
    tab.Content.CanvasSize = UDim2.fromScale(0, 0)
    tab.Content.AutomaticCanvasSize = Enum.AutomaticSize.Y
    tab.Content.Visible = false
    tab.Content.Parent = self.TabContentContainer
    
    -- Add padding to content
    Utils.AddPadding(tab.Content, 5)
    
    -- Add list layout to content
    tab.ContentLayout = Utils.AddListLayout(
        tab.Content,
        8,
        Enum.FillDirection.Vertical,
        Enum.HorizontalAlignment.Center,
        Enum.VerticalAlignment.Top
    )
    
    -- Create tab button
    local button = self:CreateTabButton(tab)
    self.TabButtons[name] = button
    
    -- Add methods to tab
    tab.AddSection = function(sectionOptions)
        return self:AddSection(tab, sectionOptions)
    end
    
    -- Store tab
    self.Tabs[name] = tab
    
    return tab
end

-- Create a tab button
function TabManager:CreateTabButton(tab)
    -- Button container
    local button = Instance.new("Frame")
    button.Name = tab.Name .. "_Button"
    button.Size = UDim2.new(0, 120, 1, 0)
    button.BackgroundColor3 = ThemeManager:GetTheme().Tab.Background
    button.Parent = self.TabButtonContainer
    
    -- Add corner
    Utils.RoundCorners(button, UDim.new(0, 4))
    
    -- Add text label
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "ButtonText"
    textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    textLabel.Position = UDim2.fromScale(0.5, 0.5)
    textLabel.Size = UDim2.new(1, -10, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Font = Config.Window.TabButtonFont
    textLabel.TextSize = Config.Window.TabButtonTextSize
    textLabel.TextColor3 = ThemeManager:GetTheme().Tab.TextColor
    textLabel.Text = tab.Name
    textLabel.Parent = button
    
    -- Add icon if provided
    if tab.Icon then
        local icon = Instance.new("ImageLabel")
        icon.Name = "TabIcon"
        icon.Size = UDim2.fromOffset(16, 16)
        icon.Position = UDim2.new(0, 6, 0.5, -8)
        icon.BackgroundTransparency = 1
        icon.Image = tab.Icon
        icon.ImageColor3 = ThemeManager:GetTheme().Tab.TextColor
        icon.Parent = button
        
        -- Adjust text position
        textLabel.Position = UDim2.new(0.5, 8, 0.5, 0)
    end
    
    -- Add detection button
    local clickButton = Instance.new("TextButton")
    clickButton.Name = "ClickDetector"
    clickButton.Size = UDim2.fromScale(1, 1)
    clickButton.BackgroundTransparency = 1
    clickButton.Text = ""
    clickButton.ZIndex = 5
    clickButton.Parent = button
    
    -- Store references
    button.TextLabel = textLabel
    button.Selected = false
    
    -- Connect click event
    clickButton.MouseButton1Click:Connect(function()
        self:SelectTab(tab.Name)
    end)
    
    -- Hover effects
    clickButton.MouseEnter:Connect(function()
        if not button.Selected then
            Utils.Tween(
                button,
                {BackgroundColor3 = ThemeManager:GetTheme().Tab.BackgroundSelected},
                Config.Element.AnimationDuration
            )
        end
    end)
    
    clickButton.MouseLeave:Connect(function()
        if not button.Selected then
            Utils.Tween(
                button,
                {BackgroundColor3 = ThemeManager:GetTheme().Tab.Background},
                Config.Element.AnimationDuration
            )
        end
    end)
    
    return button
end

-- Add a section to a tab
function TabManager:AddSection(tab, options)
    -- Create the section
    local section = Section.new(tab.Content, options)
    
    -- Store section
    table.insert(tab.Sections, section)
    
    return section
end

-- Select a tab by name
function TabManager:SelectTab(tabName)
    -- Check if tab exists
    if not self.Tabs[tabName] then
        warn("Tab with name '" .. tabName .. "' does not exist")
        return
    end
    
    -- Get tab
    local tab = self.Tabs[tabName]
    
    -- Skip if already selected
    if self.CurrentTab == tab then
        return
    end
    
    -- Hide current tab if exists
    if self.CurrentTab then
        self.CurrentTab.Content.Visible = false
        
        -- Update button state
        local currentButton = self.TabButtons[self.CurrentTab.Name]
        currentButton.Selected = false
        currentButton.BackgroundColor3 = ThemeManager:GetTheme().Tab.Background
        currentButton.TextLabel.TextColor3 = ThemeManager:GetTheme().Tab.TextColor
    end
    
    -- Show new tab
    tab.Content.Visible = true
    
    -- Update button state
    local button = self.TabButtons[tabName]
    button.Selected = true
    button.BackgroundColor3 = ThemeManager:GetTheme().Tab.BackgroundSelected
    button.TextLabel.TextColor3 = ThemeManager:GetTheme().Tab.TextColorSelected
    
    -- Update current tab
    self.CurrentTab = tab
    
    -- Fire changed event
    self.TabChanged:Fire(tab)
end

-- Get all tabs
function TabManager:GetTabs()
    local tabsList = {}
    for _, tab in pairs(self.Tabs) do
        table.insert(tabsList, tab)
    end
    return tabsList
end

-- Get current tab
function TabManager:GetCurrentTab()
    return self.CurrentTab
end

-- Remove a tab
function TabManager:RemoveTab(tabName)
    -- Check if tab exists
    if not self.Tabs[tabName] then
        return false
    end
    
    -- Get tab
    local tab = self.Tabs[tabName]
    
    -- Clean up sections
    for _, section in pairs(tab.Sections) do
        section:Destroy()
    end
    
    -- Clean up content
    tab.Content:Destroy()
    
    -- Clean up button
    self.TabButtons[tabName]:Destroy()
    self.TabButtons[tabName] = nil
    
    -- Select another tab if this was the current one
    if self.CurrentTab == tab then
        self.CurrentTab = nil
        
        -- Find another tab to select
        local nextTab = next(self.Tabs)
        if nextTab and nextTab ~= tabName then
            self:SelectTab(nextTab)
        end
    end
    
    -- Remove from tabs
    self.Tabs[tabName] = nil
    
    return true
end

-- Clean up and destroy
function TabManager:Destroy()
    -- Disconnect events
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Clean up tabs
    for tabName, tab in pairs(self.Tabs) do
        -- Clean up sections
        for _, section in pairs(tab.Sections) do
            section:Destroy()
        end
        
        -- Clean up content
        tab.Content:Destroy()
    end
    
    -- Clean up buttons
    for _, button in pairs(self.TabButtons) do
        button:Destroy()
    end
    
    -- Clean up events
    self.TabChanged:Destroy()
    
    -- Clean up containers
    if self.TabButtonContainer then
        self.TabButtonContainer:Destroy()
    end
    
    if self.TabContentContainer then
        self.TabContentContainer:Destroy()
    end
end

return TabManager

-- ========================== Layout/Section.lua ==========================
--[[
    Section component for the UI library
    A container for UI elements within a tab
]]
local Section = {}
Section.__index = Section

-- Services
local TweenService = game:GetService("TweenService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Signal
local Components = {}

-- Create a new section instance
function Section.new(parent, options)
    -- Load dependencies
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
        
        -- Load components
        Components.Button = require(script.Parent.Parent.Components.Button)
        Components.Toggle = require(script.Parent.Parent.Components.Toggle)
        Components.Slider = require(script.Parent.Parent.Components.Slider)
        Components.Dropdown = require(script.Parent.Parent.Components.Dropdown)
        Components.Keybind = require(script.Parent.Parent.Components.Keybind)
        Components.ColorPicker = require(script.Parent.Parent.Components.ColorPicker)
    end
    
    local self = setmetatable({}, Section)
    
    -- Default options
    options = options or {}
    self.Name = options.Name or "Section"
    self.Parent = parent
    self.Open = options.Open ~= false -- Default to open
    
    -- Internal state
    self.Items = {}
    self.Size = UDim2.new(1, -10, 0, Config.Section.DefaultHeight)
    
    -- Events
    self.SectionToggled = Signal.new()
    
    -- Create section UI
    self:Create()
    
    -- Set up event connections
    self:SetupConnections()
    
    return self
end

-- Create section UI
function Section:Create()
    -- Main container
    self.Container = Instance.new("Frame")
    self.Container.Name = self.Name .. "_Section"
    self.Container.Size = UDim2.new(1, 0, 0, Config.Section.DefaultHeight)
    self.Container.BackgroundColor3 = ThemeManager:GetTheme().Section.Background
    self.Container.Parent = self.Parent
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.Container, UDim.new(0, Config.Section.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.Container,
        ThemeManager:GetTheme().Section.BorderColor,
        Config.Section.BorderWidth
    )
    
    -- Create header
    self:CreateHeader()
    
    -- Create content container
    self:CreateContent()
    
    -- Update initial state
    self:UpdateState()
end

-- Create section header
function Section:CreateHeader()
    -- Header container
    self.Header = Instance.new("Frame")
    self.Header.Name = "SectionHeader"
    self.Header.Size = UDim2.new(1, 0, 0, Config.Section.HeaderHeight)
    self.Header.BackgroundTransparency = 1
    self.Header.Parent = self.Container
    
    -- Header text
    self.HeaderText = Instance.new("TextLabel")
    self.HeaderText.Name = "HeaderText"
    self.HeaderText.Size = UDim2.new(1, -30, 1, 0)
    self.HeaderText.Position = UDim2.fromOffset(Config.Section.Padding, 0)
    self.HeaderText.BackgroundTransparency = 1
    self.HeaderText.Font = Config.Section.HeaderFont
    self.HeaderText.TextSize = Config.Section.HeaderTextSize
    self.HeaderText.TextColor3 = ThemeManager:GetTheme().Section.TextColor
    self.HeaderText.Text = self.Name
    self.HeaderText.TextXAlignment = Enum.TextXAlignment.Left
    self.HeaderText.Parent = self.Header
    
    -- Toggle button
    self.ToggleButton = Instance.new("ImageButton")
    self.ToggleButton.Name = "ToggleButton"
    self.ToggleButton.Size = UDim2.fromOffset(16, 16)
    self.ToggleButton.Position = UDim2.new(1, -20, 0.5, -8)
    self.ToggleButton.BackgroundTransparency = 1
    self.ToggleButton.Image = "rbxassetid://6031094670" -- Collapse icon
    self.ToggleButton.ImageColor3 = ThemeManager:GetTheme().Section.TextColor
    self.ToggleButton.Parent = self.Header
    
    -- Header button for clicking anywhere on header
    self.HeaderButton = Instance.new("TextButton")
    self.HeaderButton.Name = "HeaderButton"
    self.HeaderButton.Size = UDim2.fromScale(1, 1)
    self.HeaderButton.BackgroundTransparency = 1
    self.HeaderButton.Text = ""
    self.HeaderButton.ZIndex = 5
    self.HeaderButton.Parent = self.Header
end

-- Create section content container
function Section:CreateContent()
    -- Content container
    self.Content = Instance.new("Frame")
    self.Content.Name = "SectionContent"
    self.Content.Size = UDim2.new(1, 0, 1, -Config.Section.HeaderHeight)
    self.Content.Position = UDim2.new(0, 0, 0, Config.Section.HeaderHeight)
    self.Content.BackgroundTransparency = 1
    self.Content.ClipsDescendants = true
    self.Content.Parent = self.Container
    
    -- Add padding
    self.ContentPadding = Utils.AddPadding(self.Content, Config.Section.Padding)
    
    -- Item list layout
    self.ItemLayout = Utils.AddListLayout(
        self.Content,
        Config.Section.Padding,
        Enum.FillDirection.Vertical,
        Enum.HorizontalAlignment.Center,
        Enum.VerticalAlignment.Top
    )
    
    -- Connect layout changed event to update size
    self.ItemLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        self:UpdateSize()
    end)
}

-- Set up event connections
function Section:SetupConnections()
    -- Header button for toggling section
    self.HeaderButtonConnection = self.HeaderButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
    
    -- Toggle button for toggling section
    self.ToggleButtonConnection = self.ToggleButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
    
    -- Theme changed event
    self.ThemeChangedConnection = ThemeManager.ThemeChanged:Connect(function(theme)
        self:UpdateTheme(theme)
    end)
end

-- Update theme
function Section:UpdateTheme(theme)
    theme = theme or ThemeManager:GetTheme()
    
    -- Update colors
    self.Container.BackgroundColor3 = theme.Section.Background
    self.HeaderText.TextColor3 = theme.Section.TextColor
    self.ToggleButton.ImageColor3 = theme.Section.TextColor
    self.Stroke.Color = theme.Section.BorderColor
    
    -- Update items
    for _, item in ipairs(self.Items) do
        if item.UpdateTheme then
            item:UpdateTheme(theme)
        end
    end
end

-- Toggle section open/closed
function Section:Toggle(state)
    -- Set state explicitly if provided, otherwise toggle
    if state ~= nil then
        self.Open = state
    else
        self.Open = not self.Open
    end
    
    -- Update state
    self:UpdateState()
    
    -- Fire toggled event
    self.SectionToggled:Fire(self.Open)
end

-- Update section state
function Section:UpdateState()
    if self.Open then
        -- Calculate expanded size based on content
        local contentSize = self.ItemLayout.AbsoluteContentSize.Y + (Config.Section.Padding * 2)
        local targetSize = UDim2.new(1, 0, 0, contentSize + Config.Section.HeaderHeight)
        
        -- Rotate toggle button to down arrow
        Utils.Tween(
            self.ToggleButton,
            {Rotation = 0},
            Config.Section.AnimationDuration
        )
        
        -- Expand section
        Utils.Tween(
            self.Container,
            {Size = targetSize},
            Config.Section.AnimationDuration
        )
    else
        -- Rotate toggle button to right arrow
        Utils.Tween(
            self.ToggleButton,
            {Rotation = -90},
            Config.Section.AnimationDuration
        )
        
        -- Collapse section
        Utils.Tween(
            self.Container,
            {Size = UDim2.new(1, 0, 0, Config.Section.HeaderHeight)},
            Config.Section.AnimationDuration
        )
    end
end

-- Update section size based on content
function Section:UpdateSize()
    if not self.Open then return end
    
    local contentSize = self.ItemLayout.AbsoluteContentSize.Y + (Config.Section.Padding * 2)
    local targetSize = UDim2.new(1, 0, 0, contentSize + Config.Section.HeaderHeight)
    
    -- Update size
    self.Container.Size = targetSize
    self.Size = targetSize
}

-- Set section header text
function Section:SetText(text)
    self.Name = text
    self.HeaderText.Text = text
end

-- Add a button
function Section:AddButton(options)
    local button = Components.Button.new(self.Content, options)
    table.insert(self.Items, button)
    self:UpdateSize()
    return button
end

-- Add a toggle
function Section:AddToggle(options)
    local toggle = Components.Toggle.new(self.Content, options)
    table.insert(self.Items, toggle)
    self:UpdateSize()
    return toggle
end

-- Add a slider
function Section:AddSlider(options)
    local slider = Components.Slider.new(self.Content, options)
    table.insert(self.Items, slider)
    self:UpdateSize()
    return slider
end

-- Add a dropdown
function Section:AddDropdown(options)
    local dropdown = Components.Dropdown.new(self.Content, options)
    table.insert(self.Items, dropdown)
    self:UpdateSize()
    return dropdown
end

-- Add a keybind
function Section:AddKeybind(options)
    local keybind = Components.Keybind.new(self.Content, options)
    table.insert(self.Items, keybind)
    self:UpdateSize()
    return keybind
end

-- Add a color picker
function Section:AddColorPicker(options)
    local colorPicker = Components.ColorPicker.new(self.Content, options)
    table.insert(self.Items, colorPicker)
    self:UpdateSize()
    return colorPicker
end

-- Clean up and destroy
function Section:Destroy()
    -- Disconnect events
    if self.HeaderButtonConnection then
        self.HeaderButtonConnection:Disconnect()
    end
    
    if self.ToggleButtonConnection then
        self.ToggleButtonConnection:Disconnect()
    end
    
    if self.ThemeChangedConnection then
        self.ThemeChangedConnection:Disconnect()
    end
    
    -- Destroy all items
    for _, item in ipairs(self.Items) do
        if item.Destroy then
            item:Destroy()
        end
    end
    
    -- Clean up events
    self.SectionToggled:Destroy()
    
    -- Destroy UI
    if self.Container then
        self.Container:Destroy()
    end
end

return Section

-- ========================== Layout/Scrolling.lua ==========================
--[[
    Scrolling utility for the UI library
    Enhances the default Roblox ScrollingFrame with custom scrolling behavior
]]
local Scrolling = {}
Scrolling.__index = Scrolling

-- Services
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local Config

-- Create a new scrolling controller instance
function Scrolling.new(scrollingFrame, options)
    -- Load dependencies
    if not Utils then
        Utils = requireModule("Utils")
        Config = requireModule("Config")
    end
    
    local self = setmetatable({}, Scrolling)
    
    -- Default options
    options = options or {}
    self.ScrollSpeed = options.ScrollSpeed or 0.1
    self.Elastic = options.Elastic ~= false
    self.ElasticFactor = options.ElasticFactor or 0.2
    self.SmoothScrolling = options.SmoothScrolling ~= false
    self.ScrollBarThickness = options.ScrollBarThickness or 4
    self.ScrollBarColor = options.ScrollBarColor
    self.AutoHideScrollBar = options.AutoHideScrollBar ~= false
    
    -- Set up scrolling frame
    self.ScrollingFrame = scrollingFrame
    self:Setup()
    
    -- Internal state
    self.Dragging = false
    self.DragStartPosition = nil
    self.StartCanvasPosition = nil
    self.TargetCanvasPosition = nil
    self.Velocity = Vector2.new(0, 0)
    self.LastDragDelta = Vector2.new(0, 0)
    self.ScrollBarVisible = true
    
    -- Set up event connections
    self:SetupConnections()
    
    return self
end

-- Set up scrolling frame
function Scrolling:Setup()
    -- Configure scrolling frame
    self.ScrollingFrame.ScrollBarThickness = self.ScrollBarThickness
    self.ScrollingFrame.ScrollingDirection = Enum.ScrollingDirection.Y
    self.ScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    self.ScrollingFrame.ScrollBarImageTransparency = 0
    self.ScrollingFrame.TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
    self.ScrollingFrame.MidImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
    self.ScrollingFrame.BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
    
    -- Set scroll bar color
    if self.ScrollBarColor then
        self.ScrollingFrame.ScrollBarImageColor3 = self.ScrollBarColor
    end
    
    -- Create detection frame for mouse wheel
    self.MouseWheelCatcher = Instance.new("Frame")
    self.MouseWheelCatcher.Name = "MouseWheelCatcher"
    self.MouseWheelCatcher.Size = UDim2.fromScale(1, 1)
    self.MouseWheelCatcher.BackgroundTransparency = 1
    self.MouseWheelCatcher.ZIndex = 10
    self.MouseWheelCatcher.Parent = self.ScrollingFrame
    
    -- Initial scrollbar visibility
    if self.AutoHideScrollBar then
        self:SetScrollBarVisible(false)
    end
}

-- Set up event connections
function Scrolling:SetupConnections()
    -- Mouse wheel scrolling
    self.MouseWheelConnection = self.MouseWheelCatcher.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            -- Calculate scroll delta
            local delta = Vector2.new(0, input.Position.Z * 30 * self.ScrollSpeed)
            
            -- Update target canvas position
            if self.SmoothScrolling then
                self.TargetCanvasPosition = self.ScrollingFrame.CanvasPosition - delta
                
                -- Add to velocity for momentum
                self.Velocity = self.Velocity - delta * 0.5
            else
                -- Immediate scrolling
                self.ScrollingFrame.CanvasPosition = self.ScrollingFrame.CanvasPosition - delta
            end
            
            -- Show scrollbar temporarily
            if self.AutoHideScrollBar then
                self:SetScrollBarVisible(true)
                self:ScheduleScrollBarHide()
            end
        end
    end)
    
    -- Mouse button down for dragging
    self.MouseButtonDownConnection = self.ScrollingFrame.MouseButton1Down:Connect(function(x, y)
        -- Start dragging
        self.Dragging = true
        self.DragStartPosition = Vector2.new(x, y)
        self.StartCanvasPosition = self.ScrollingFrame.CanvasPosition
        self.TargetCanvasPosition = self.ScrollingFrame.CanvasPosition
        
        -- Show scrollbar
        if self.AutoHideScrollBar then
            self:SetScrollBarVisible(true)
        end
    end)
    
    -- Mouse button up for ending drag
    self.MouseButtonUpConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- End dragging
            self.Dragging = false
            
            -- Schedule scrollbar hide
            if self.AutoHideScrollBar then
                self:ScheduleScrollBarHide()
            end
            
            -- Keep velocity for momentum
            if self.SmoothScrolling then
                self.Velocity = self.LastDragDelta * 10
            end
        end
    end)
    
    -- Mouse movement for dragging
    self.MouseMoveConnection = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if self.Dragging then
                -- Get mouse position
                local mousePos = input.Position
                
                -- Calculate drag delta
                local delta = Vector2.new(
                    mousePos.X - self.DragStartPosition.X,
                    mousePos.Y - self.DragStartPosition.Y
                )
                
                -- Update canvas position
                if self.SmoothScrolling then
                    self.TargetCanvasPosition = self.StartCanvasPosition - delta
                else
                    self.ScrollingFrame.CanvasPosition = self.StartCanvasPosition - delta
                end
                
                -- Store last drag delta for momentum
                self.LastDragDelta = Vector2.new(0, self.Velocity.Y * 0.8 - delta.Y * 0.2)
            end
        end
    end)
    
    -- Mouse enter/leave for scrollbar visibility
    if self.AutoHideScrollBar then
        self.MouseEnterConnection = self.ScrollingFrame.MouseEnter:Connect(function()
            self:SetScrollBarVisible(true)
        end)
        
        self.MouseLeaveConnection = self.ScrollingFrame.MouseLeave:Connect(function()
            if not self.Dragging then
                self:ScheduleScrollBarHide()
            end
        end)
    end
    
    -- Canvas size changed (for elastic bounds)
    self.CanvasSizeChangedConnection = self.ScrollingFrame:GetPropertyChangedSignal("CanvasSize"):Connect(function()
        self:EnforceBounds()
    end)
    
    -- Update loop for smooth scrolling
    if self.SmoothScrolling then
        self.UpdateConnection = RunService.RenderStepped:Connect(function(deltaTime)
            self:Update(deltaTime)
        end)
    end
}

-- Update smooth scrolling
function Scrolling:Update(deltaTime)
    if not self.ScrollingFrame then return end
    
    -- Apply velocity decay
    self.Velocity = self.Velocity * 0.9
    
    -- Stop updating if velocity is very small
    if self.Velocity.Magnitude < 0.1 then
        self.Velocity = Vector2.new(0, 0)
    end
    
    -- Update target position with velocity
    if self.TargetCanvasPosition then
        self.TargetCanvasPosition = self.TargetCanvasPosition + self.Velocity * deltaTime
    end
    
    -- Apply elastic bounds if enabled
    if self.Elastic and self.TargetCanvasPosition then
        self:ApplyElasticBounds()
    end
    
    -- Smoothly move towards target position
    if self.TargetCanvasPosition and not self.Dragging then
        local currentPos = self.ScrollingFrame.CanvasPosition
        local targetPos = self.TargetCanvasPosition
        
        -- Interpolate smoothly
        local newPos = currentPos:Lerp(targetPos, math.min(deltaTime * 10, 1))
        
        -- Update position
        self.ScrollingFrame.CanvasPosition = newPos
        
        -- If very close to target, snap exactly
        if (currentPos - targetPos).Magnitude < 1 then
            self.ScrollingFrame.CanvasPosition = targetPos
        end
    end
}

-- Apply elastic bounds to scroll limits
function Scrolling:ApplyElasticBounds()
    if not self.TargetCanvasPosition then return end
    
    local canvasSize = self.ScrollingFrame.CanvasSize
    local absoluteSize = self.ScrollingFrame.AbsoluteSize
    
    -- Calculate bounds
    local minY = 0
    local maxY = math.max(0, canvasSize.Y.Offset - absoluteSize.Y)
    
    -- Apply elastic effect if out of bounds
    if self.TargetCanvasPosition.Y < minY then
        local overshoot = minY - self.TargetCanvasPosition.Y
        self.TargetCanvasPosition = Vector2.new(
            self.TargetCanvasPosition.X,
            minY - (overshoot * self.ElasticFactor)
        )
        
        -- Reduce velocity when out of bounds
        self.Velocity = self.Velocity * 0.8
    elseif self.TargetCanvasPosition.Y > maxY then
        local overshoot = self.TargetCanvasPosition.Y - maxY
        self.TargetCanvasPosition = Vector2.new(
            self.TargetCanvasPosition.X,
            maxY + (overshoot * self.ElasticFactor)
        )
        
        -- Reduce velocity when out of bounds
        self.Velocity = self.Velocity * 0.8
    end
}

-- Enforce canvas bounds (non-elastic)
function Scrolling:EnforceBounds()
    if not self.ScrollingFrame then return end
    if self.Elastic then return end
    
    local canvasSize = self.ScrollingFrame.CanvasSize
    local absoluteSize = self.ScrollingFrame.AbsoluteSize
    
    -- Calculate bounds
    local minY = 0
    local maxY = math.max(0, canvasSize.Y.Offset - absoluteSize.Y)
    
    -- Enforce bounds
    if self.ScrollingFrame.CanvasPosition.Y < minY then
        self.ScrollingFrame.CanvasPosition = Vector2.new(
            self.ScrollingFrame.CanvasPosition.X,
            minY
        )
    elseif self.ScrollingFrame.CanvasPosition.Y > maxY then
        self.ScrollingFrame.CanvasPosition = Vector2.new(
            self.ScrollingFrame.CanvasPosition.X,
            maxY
        )
    end
    
    -- Update target position as well
    if self.TargetCanvasPosition then
        if self.TargetCanvasPosition.Y < minY then
            self.TargetCanvasPosition = Vector2.new(
                self.TargetCanvasPosition.X,
                minY
            )
        elseif self.TargetCanvasPosition.Y > maxY then
            self.TargetCanvasPosition = Vector2.new(
                self.TargetCanvasPosition.X,
                maxY
            )
        end
    end
}

-- Set scrollbar visibility
function Scrolling:SetScrollBarVisible(visible)
    if self.ScrollBarVisible == visible then return end
    
    self.ScrollBarVisible = visible
    
    -- Cancel any pending hide
    if self.HideScrollBarTask then
        task.cancel(self.HideScrollBarTask)
        self.HideScrollBarTask = nil
    end
    
    -- Animate scrollbar transparency
    if visible then
        Utils.Tween(
            self.ScrollingFrame,
            {ScrollBarImageTransparency = 0},
            0.2
        )
    else
        Utils.Tween(
            self.ScrollingFrame,
            {ScrollBarImageTransparency = 1},
            0.2
        )
    end
}

-- Schedule scrollbar hide with delay
function Scrolling:ScheduleScrollBarHide()
    -- Cancel existing task
    if self.HideScrollBarTask then
        task.cancel(self.HideScrollBarTask)
    end
    
    -- Create new hide task
    self.HideScrollBarTask = task.delay(1.5, function()
        self:SetScrollBarVisible(false)
        self.HideScrollBarTask = nil
    end)
}

-- Scroll to a specific position
function Scrolling:ScrollTo(position, instant)
    position = Vector2.new(0, position)
    
    if instant or not self.SmoothScrolling then
        self.ScrollingFrame.CanvasPosition = position
        self.TargetCanvasPosition = position
    else
        self.TargetCanvasPosition = position
        self.Velocity = Vector2.new(0, 0)
    end
    
    -- Show scrollbar temporarily
    if self.AutoHideScrollBar then
        self:SetScrollBarVisible(true)
        self:ScheduleScrollBarHide()
    end
}

-- Scroll to top
function Scrolling:ScrollToTop(instant)
    self:ScrollTo(0, instant)
}

-- Scroll to bottom
function Scrolling:ScrollToBottom(instant)
    local canvasSize = self.ScrollingFrame.CanvasSize
    local absoluteSize = self.ScrollingFrame.AbsoluteSize
    local maxScroll = math.max(0, canvasSize.Y.Offset - absoluteSize.Y)
    
    self:ScrollTo(maxScroll, instant)
}

-- Clean up and destroy
function Scrolling:Destroy()
    -- Disconnect all connections
    if self.MouseWheelConnection then
        self.MouseWheelConnection:Disconnect()
    end
    
    if self.MouseButtonDownConnection then
        self.MouseButtonDownConnection:Disconnect()
    end
    
    if self.MouseButtonUpConnection then
        self.MouseButtonUpConnection:Disconnect()
    end
    
    if self.MouseMoveConnection then
        self.MouseMoveConnection:Disconnect()
    end
    
    if self.MouseEnterConnection then
        self.MouseEnterConnection:Disconnect()
    end
    
    if self.MouseLeaveConnection then
        self.MouseLeaveConnection:Disconnect()
    end
    
    if self.CanvasSizeChangedConnection then
        self.CanvasSizeChangedConnection:Disconnect()
    end
    
    if self.UpdateConnection then
        self.UpdateConnection:Disconnect()
    end
    
    -- Cancel any pending tasks
    if self.HideScrollBarTask then
        task.cancel(self.HideScrollBarTask)
        self.HideScrollBarTask = nil
    end
    
    -- Destroy mouse wheel catcher
    if self.MouseWheelCatcher then
        self.MouseWheelCatcher:Destroy()
    end
}

-- Apply scrolling to an existing ScrollingFrame
function Scrolling.Apply(scrollingFrame, options)
    return Scrolling.new(scrollingFrame, options)
end

return Scrolling

-- ========================== Extra/Notification.lua ==========================
--[[
    Notification component for the UI library
    Displays temporary notifications to the user
]]
local Notification = {}
Notification.__index = Notification

-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Init

-- Notification types
Notification.Types = {
    Default = "Default",
    Success = "Success",
    Error = "Error",
    Warning = "Warning",
    Info = "Info"
}

-- Active notifications
Notification.Active = {}

-- Container for notifications
Notification.Container = nil

-- Create notification container
function Notification.SetupContainer()
    -- Load dependencies if not loaded
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Init = requireModule("Init")
    end
    
    -- Check if container already exists
    if Notification.Container then
        return Notification.Container
    end
    
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NebulaUI_Notifications"
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    
    -- Parent it appropriately
    if Init.IS_STUDIO then
        screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    else
        pcall(function()
            screenGui.Parent = CoreGui
        end)
        
        if not screenGui.Parent then
            screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
        end
    end
    
    -- Create container
    local container = Instance.new("Frame")
    container.Name = "NotificationContainer"
    container.Size = UDim2.new(0, Config.Extra.Notification.Width, 1, 0)
    container.Position = UDim2.fromScale(1, 0)
    container.AnchorPoint = Vector2.new(1, 0)
    container.BackgroundTransparency = 1
    container.Parent = screenGui
    
    -- Add list layout
    local listLayout = Utils.AddListLayout(
        container,
        Config.Extra.Notification.StackSpacing,
        Enum.FillDirection.Vertical,
        Enum.HorizontalAlignment.Center,
        Enum.VerticalAlignment.Bottom
    )
    
    -- Store container
    Notification.Container = container
    
    return container
end

-- Show a notification
function Notification.Show(options)
    options = options or {}
    
    -- Set up container if needed
    if not Notification.Container then
        Notification.SetupContainer()
    end
    
    -- Create new notification instance
    local notification = setmetatable({}, Notification)
    
    -- Set options
    notification.Title = options.Title or "Notification"
    notification.Content = options.Content or ""
    notification.Type = options.Type or Notification.Types.Default
    notification.Duration = options.Duration or Config.Extra.Notification.Duration
    notification.Callback = options.Callback
    notification.Theme = options.CustomTheme
    
    -- Create notification UI
    notification:Create()
    
    -- Add to active notifications
    table.insert(Notification.Active, notification)
    
    -- Automatically close after duration
    if notification.Duration > 0 then
        task.delay(notification.Duration, function()
            notification:Close()
        end)
    end
    
    return notification
end

-- Create notification UI
function Notification:Create()
    -- Main frame
    self.Frame = Instance.new("Frame")

    -- Main frame
    self.Frame = Instance.new("Frame")
    self.Frame.Name = "Notification_" .. Utils.GenerateUID(5)
    self.Frame.Size = UDim2.new(0, Config.Extra.Notification.Width, 0, 0) -- Height will be set after creation
    self.Frame.BackgroundColor3 = self:GetTheme().Notification.Background
    self.Frame.BackgroundTransparency = 0
    self.Frame.AnchorPoint = Vector2.new(0.5, 1)
    self.Frame.Position = UDim2.new(0.5, 0, 1, 20) -- Start below screen
    self.Frame.ClipsDescendants = true
    self.Frame.Parent = Notification.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.Frame, UDim.new(0, Config.Extra.Notification.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.Frame,
        self:GetTheme().Notification.BorderColor,
        Config.Extra.Notification.BorderWidth
    )
    
    -- Add padding
    self.Padding = Utils.AddPadding(self.Frame, Config.Extra.Notification.Padding)
    
    -- Create content
    self:CreateContent()
    
    -- Set up close button
    self:CreateCloseButton()
    
    -- Calculate height based on content
    self:UpdateHeight()
    
    -- Animate in
    self:AnimateIn()
end

-- Create notification content
function Notification:CreateContent()
    -- Title bar with icon
    self.TitleBar = Instance.new("Frame")
    self.TitleBar.Name = "TitleBar"
    self.TitleBar.Size = UDim2.new(1, 0, 0, 24)
    self.TitleBar.BackgroundTransparency = 1
    self.TitleBar.Parent = self.Frame
    
    -- Type icon
    self.Icon = Instance.new("ImageLabel")
    self.Icon.Name = "TypeIcon"
    self.Icon.Size = UDim2.fromOffset(Config.Extra.Notification.IconSize, Config.Extra.Notification.IconSize)
    self.Icon.Position = UDim2.fromOffset(0, 0)
    self.Icon.BackgroundTransparency = 1
    self.Icon.ImageColor3 = self:GetAccentColor()
    self.Icon.Parent = self.TitleBar
    
    -- Set icon based on type
    self:SetTypeIcon()
    
    -- Title text
    self.TitleText = Instance.new("TextLabel")
    self.TitleText.Name = "Title"
    self.TitleText.Size = UDim2.new(1, -(Config.Extra.Notification.IconSize + 20), 1, 0)
    self.TitleText.Position = UDim2.fromOffset(Config.Extra.Notification.IconSize + 5, 0)
    self.TitleText.BackgroundTransparency = 1
    self.TitleText.Font = Config.Extra.Notification.TitleFont
    self.TitleText.TextSize = Config.Extra.Notification.TitleTextSize
    self.TitleText.TextColor3 = self:GetTheme().Notification.TextColor
    self.TitleText.Text = self.Title
    self.TitleText.TextXAlignment = Enum.TextXAlignment.Left
    self.TitleText.TextYAlignment = Enum.TextYAlignment.Center
    self.TitleText.Parent = self.TitleBar
    
    -- Content text
    self.ContentText = Instance.new("TextLabel")
    self.ContentText.Name = "Content"
    self.ContentText.Size = UDim2.new(1, 0, 0, 0)
    self.ContentText.Position = UDim2.new(0, 0, 0, self.TitleBar.Size.Y.Offset + 5)
    self.ContentText.BackgroundTransparency = 1
    self.ContentText.Font = Config.Extra.Notification.TextFont
    self.ContentText.TextSize = Config.Extra.Notification.TextSize
    self.ContentText.TextColor3 = self:GetTheme().Notification.TextColor
    self.ContentText.Text = self.Content
    self.ContentText.TextXAlignment = Enum.TextXAlignment.Left
    self.ContentText.TextYAlignment = Enum.TextYAlignment.Top
    self.ContentText.TextWrapped = true
    self.ContentText.AutomaticSize = Enum.AutomaticSize.Y
    self.ContentText.Parent = self.Frame
    
    -- Add accent bar
    self.AccentBar = Instance.new("Frame")
    self.AccentBar.Name = "AccentBar"
    self.AccentBar.Size = UDim2.new(0, 3, 1, 0)
    self.AccentBar.Position = UDim2.fromOffset(-3, 0)
    self.AccentBar.BackgroundColor3 = self:GetAccentColor()
    self.AccentBar.BorderSizePixel = 0
    self.AccentBar.Parent = self.Frame
end

-- Create close button
function Notification:CreateCloseButton()
    -- Close button
    self.CloseButton = Instance.new("ImageButton")
    self.CloseButton.Name = "CloseButton"
    self.CloseButton.Size = UDim2.fromOffset(16, 16)
    self.CloseButton.Position = UDim2.new(1, -16, 0, 4)
    self.CloseButton.BackgroundTransparency = 1
    self.CloseButton.Image = "rbxassetid://6031094678" -- Close icon
    self.CloseButton.ImageColor3 = self:GetTheme().Notification.TextColor
    self.CloseButton.ImageTransparency = 0.5
    self.CloseButton.Parent = self.Frame
    
    -- Connect close event
    self.CloseButton.MouseButton1Click:Connect(function()
        self:Close()
    end)
    
    -- Hover effects
    self.CloseButton.MouseEnter:Connect(function()
        Utils.Tween(
            self.CloseButton,
            {ImageTransparency = 0},
            0.2
        )
    end)
    
    self.CloseButton.MouseLeave:Connect(function()
        Utils.Tween(
            self.CloseButton,
            {ImageTransparency = 0.5},
            0.2
        )
    end)
end

-- Set icon based on notification type
function Notification:SetTypeIcon()
    local iconAsset
    
    -- Choose icon based on type
    if self.Type == Notification.Types.Success then
        iconAsset = "rbxassetid://6031071053" -- Checkmark icon
    elseif self.Type == Notification.Types.Error then
        iconAsset = "rbxassetid://6031071057" -- X icon
    elseif self.Type == Notification.Types.Warning then
        iconAsset = "rbxassetid://6031071054" -- Warning icon
    elseif self.Type == Notification.Types.Info then
        iconAsset = "rbxassetid://6026568198" -- Info icon
    else
        iconAsset = "rbxassetid://6031071050" -- Bell icon
    end
    
    self.Icon.Image = iconAsset
end

-- Get accent color based on notification type
function Notification:GetAccentColor()
    local theme = self:GetTheme()
    
    if self.Type == Notification.Types.Success then
        return theme.Notification.AccentSuccess
    elseif self.Type == Notification.Types.Error then
        return theme.Notification.AccentError
    elseif self.Type == Notification.Types.Warning then
        return theme.Notification.AccentWarning
    elseif self.Type == Notification.Types.Info then
        return theme.Notification.AccentInfo
    else
        return theme.Notification.AccentDefault
    end
end

-- Get theme
function Notification:GetTheme()
    return self.Theme or ThemeManager:GetTheme().Extra
end

-- Update notification height based on content
function Notification:UpdateHeight()
    -- Wait for text to layout
    task.defer(function()
        -- Calculate content height
        local titleHeight = self.TitleBar.Size.Y.Offset
        local contentHeight = self.ContentText.TextBounds.Y
        local padding = Config.Extra.Notification.Padding
        
        -- Set frame height
        local totalHeight = titleHeight + contentHeight + (padding * 2) + 5
        totalHeight = math.max(totalHeight, Config.Extra.Notification.MinHeight)
        
        self.Frame.Size = UDim2.new(0, Config.Extra.Notification.Width, 0, totalHeight)
    end)
end

-- Animate notification in
function Notification:AnimateIn()
    -- Get current notification index
    local index = table.find(Notification.Active, self)
    
    -- Calculate final position based on active notifications
    local yOffset = 0
    for i = 1, index - 1 do
        local notification = Notification.Active[i]
        if notification and notification.Frame then
            yOffset = yOffset + notification.Frame.Size.Y.Offset + Config.Extra.Notification.StackSpacing
        end
    end
    
    -- Set final position
    local finalPosition = UDim2.new(0.5, 0, 1, -yOffset - Config.Extra.Notification.StackSpacing)
    
    -- Animate in
    self.Frame.Position = UDim2.new(0.5, 0, 1, 20)
    
    -- Bring in from below
    Utils.Tween(
        self.Frame,
        {Position = finalPosition},
        Config.Extra.Notification.AnimationDuration,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
end

-- Close notification
function Notification:Close()
    -- Animate out
    Utils.Tween(
        self.Frame,
        {Position = UDim2.new(1.5, 0, self.Frame.Position.Y.Scale, self.Frame.Position.Y.Offset)},
        Config.Extra.Notification.AnimationDuration,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out,
        0,
        false,
        function()
            -- Remove from active notifications
            local index = table.find(Notification.Active, self)
            if index then
                table.remove(Notification.Active, index)
            end
            
            -- Reposition remaining notifications
            self:RepositionNotifications(index)
            
            -- Destroy frame
            self.Frame:Destroy()
            
            -- Call callback if provided
            if self.Callback then
                self.Callback()
            end
        end
    )
end

-- Reposition notifications after one is closed
function Notification:RepositionNotifications(startIndex)
    startIndex = startIndex or 1
    
    -- Update positions of all notifications after the closed one
    for i = startIndex, #Notification.Active do
        local notification = Notification.Active[i]
        if notification and notification.Frame then
            -- Calculate new position
            local yOffset = 0
            for j = 1, i - 1 do
                local aboveNotification = Notification.Active[j]
                if aboveNotification and aboveNotification.Frame then
                    yOffset = yOffset + aboveNotification.Frame.Size.Y.Offset + Config.Extra.Notification.StackSpacing
                end
            end
            
            -- Animate to new position
            local newPosition = UDim2.new(0.5, 0, 1, -yOffset - Config.Extra.Notification.StackSpacing)
            
            Utils.Tween(
                notification.Frame,
                {Position = newPosition},
                Config.Extra.Notification.AnimationDuration
            )
        end
    end
end

-- Create success notification
function Notification.Success(title, content, options)
    options = options or {}
    options.Title = title
    options.Content = content
    options.Type = Notification.Types.Success
    
    return Notification.Show(options)
end

-- Create error notification
function Notification.Error(title, content, options)
    options = options or {}
    options.Title = title
    options.Content = content
    options.Type = Notification.Types.Error
    
    return Notification.Show(options)
end

-- Create warning notification
function Notification.Warning(title, content, options)
    options = options or {}
    options.Title = title
    options.Content = content
    options.Type = Notification.Types.Warning
    
    return Notification.Show(options)
end

-- Create info notification
function Notification.Info(title, content, options)
    options = options or {}
    options.Title = title
    options.Content = content
    options.Type = Notification.Types.Info
    
    return Notification.Show(options)
end

-- Clear all notifications
function Notification.ClearAll()
    -- Clone the table to avoid issues while iterating
    local activeNotifications = table.clone(Notification.Active)
    
    -- Close all notifications
    for _, notification in ipairs(activeNotifications) do
        notification:Close()
    end
end

return Notification

-- ========================== Extra/SaveSystem.lua ==========================
--[[
    SaveSystem component for the UI library
    Handles saving and loading UI configurations
]]
local SaveSystem = {}
SaveSystem.__index = SaveSystem

-- Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local DataStoreService = nil

-- Only require DataStoreService in game, not in Studio
if not RunService:IsStudio() then
    pcall(function()
        DataStoreService = game:GetService("DataStoreService")
    end)
end

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local Config
local Signal

-- SaveSystem state
SaveSystem.Initialized = false
SaveSystem.DataStore = nil
SaveSystem.UseDataStore = false
SaveSystem.ConfigFolder = "NebulaUI"
SaveSystem.AutoSaveInterval = 30
SaveSystem.Configs = {}
SaveSystem.AutoSaveEnabled = true
SaveSystem.CurrentConfig = nil

-- Events
SaveSystem.ConfigSaved = nil
SaveSystem.ConfigLoaded = nil
SaveSystem.AutoSaveChanged = nil

-- Initialize the save system
function SaveSystem.Initialize(options)
    -- Prevent multiple initialization
    if SaveSystem.Initialized then
        return
    end
    
    -- Load dependencies
    if not Utils then
        Utils = requireModule("Utils")
        Config = requireModule("Config")
        Signal = requireModule("Signal")
    end
    
    -- Set up options
    options = options or {}
    SaveSystem.UseDataStore = options.UseDataStore or Config.Extra.SaveSystem.UseDataStoreService
    SaveSystem.ConfigFolder = options.ConfigFolder or Config.Extra.SaveSystem.ConfigFolder
    SaveSystem.AutoSaveInterval = options.AutoSaveInterval or Config.Extra.SaveSystem.AutoSaveInterval
    
    -- Create events
    SaveSystem.ConfigSaved = Signal.new()
    SaveSystem.ConfigLoaded = Signal.new()
    SaveSystem.AutoSaveChanged = Signal.new()
    
    -- Set up DataStore if enabled
    if SaveSystem.UseDataStore and DataStoreService then
        local success, result = pcall(function()
            return DataStoreService:GetDataStore(SaveSystem.ConfigFolder)
        end)
        
        if success then
            SaveSystem.DataStore = result
        else
            warn("Failed to get DataStore: " .. tostring(result))
            SaveSystem.UseDataStore = false
        end
    end
    
    -- Load existing configs
    SaveSystem.LoadConfigList()
    
    -- Set default config
    SaveSystem.CurrentConfig = Config.Extra.SaveSystem.DefaultConfigName
    
    -- Start auto-save if enabled
    if SaveSystem.AutoSaveEnabled and SaveSystem.AutoSaveInterval > 0 then
        SaveSystem.StartAutoSave()
    end
    
    SaveSystem.Initialized = true
end

-- Start auto-save timer
function SaveSystem.StartAutoSave()
    -- Clear existing timer
    if SaveSystem.AutoSaveTimer then
        SaveSystem.StopAutoSave()
    end
    
    -- Set up new timer
    SaveSystem.AutoSaveTimer = task.spawn(function()
        while true do
            task.wait(SaveSystem.AutoSaveInterval)
            
            if SaveSystem.AutoSaveEnabled and SaveSystem.CurrentConfig then
                SaveSystem.SaveCurrentConfig()
            end
        end
    end)
end

-- Stop auto-save timer
function SaveSystem.StopAutoSave()
    if SaveSystem.AutoSaveTimer then
        task.cancel(SaveSystem.AutoSaveTimer)
        SaveSystem.AutoSaveTimer = nil
    end
end

-- Toggle auto-save
function SaveSystem.SetAutoSave(enabled)
    SaveSystem.AutoSaveEnabled = enabled
    
    if enabled and not SaveSystem.AutoSaveTimer then
        SaveSystem.StartAutoSave()
    elseif not enabled and SaveSystem.AutoSaveTimer then
        SaveSystem.StopAutoSave()
    end
    
    SaveSystem.AutoSaveChanged:Fire(enabled)
end

-- Load list of saved configs
function SaveSystem.LoadConfigList()
    if SaveSystem.UseDataStore then
        -- Load from DataStore
        -- DataStore doesn't provide a list of keys, so we need to maintain a list
        local success, configList = pcall(function()
            return SaveSystem.DataStore:GetAsync("ConfigList")
        end)
        
        if success and configList then
            SaveSystem.Configs = configList
        else
            SaveSystem.Configs = {}
        end
    else
        -- Load from local storage
        if not (IsClient or isfile) then
            return {} -- Environment doesn't support file operations
        end
        
        -- Create folder if it doesn't exist
        if not isfolder(SaveSystem.ConfigFolder) then
            makefolder(SaveSystem.ConfigFolder)
        end
        
        -- Get list of files
        local success, files = pcall(function()
            return listfiles(SaveSystem.ConfigFolder)
        end)
        
        if success and files then
            -- Extract config names
            SaveSystem.Configs = {}
            for _, file in ipairs(files) do
                -- Extract filename without extension
                local fileName = file:match("([^/\\]+)%.json$")
                if fileName then
                    table.insert(SaveSystem.Configs, fileName)
                end
            end
        else
            SaveSystem.Configs = {}
        end
    end
    
    return SaveSystem.Configs
end

-- Get list of saved configs
function SaveSystem.GetConfigList()
    return SaveSystem.Configs
end

-- Save current UI configuration
function SaveSystem.SaveCurrentConfig()
    return SaveSystem.SaveConfig(SaveSystem.CurrentConfig)
end

-- Save UI configuration
function SaveSystem.SaveConfig(configName, data)
    -- Initialize if not already done
    if not SaveSystem.Initialized then
        SaveSystem.Initialize()
    end
    
    -- Use current config name if not specified
    configName = configName or SaveSystem.CurrentConfig or Config.Extra.SaveSystem.DefaultConfigName
    
    -- Get data to save
    data = data or SaveSystem.GatherConfigData()
    
    -- Convert to JSON
    local jsonData = HttpService:JSONEncode(data)
    
    -- Save configuration
    if SaveSystem.UseDataStore then
        -- Save to DataStore
        local success, errorMessage = pcall(function()
            SaveSystem.DataStore:SetAsync(configName, jsonData)
            
            -- Update config list
            if not table.find(SaveSystem.Configs, configName) then
                table.insert(SaveSystem.Configs, configName)
                SaveSystem.DataStore:SetAsync("ConfigList", SaveSystem.Configs)
            end
        end)
        
        if not success then
            warn("Failed to save config to DataStore: " .. tostring(errorMessage))
            return false
        end
    else
        -- Save to local storage
        if not writefile then
            warn("File system functions are not available in this environment")
            return false
        end
        
        -- Create folder if it doesn't exist
        if not isfolder(SaveSystem.ConfigFolder) then
            makefolder(SaveSystem.ConfigFolder)
        end
        
        -- Save to file
        local filePath = SaveSystem.ConfigFolder .. "/" .. configName .. ".json"
        
        local success, errorMessage = pcall(function()
            writefile(filePath, jsonData)
        end)
        
        if not success then
            warn("Failed to save config to file: " .. tostring(errorMessage))
            return false
        end
        
        -- Update config list
        if not table.find(SaveSystem.Configs, configName) then
            table.insert(SaveSystem.Configs, configName)
        end
    end
    
    -- Update current config
    SaveSystem.CurrentConfig = configName
    
    -- Fire save event
    SaveSystem.ConfigSaved:Fire(configName, data)
    
    return true
end

-- Load UI configuration
function SaveSystem.LoadConfig(configName)
    -- Initialize if not already done
    if not SaveSystem.Initialized then
        SaveSystem.Initialize()
    end
    
    -- Use current config name if not specified
    configName = configName or SaveSystem.CurrentConfig or Config.Extra.SaveSystem.DefaultConfigName
    
    local jsonData
    
    -- Load configuration
    if SaveSystem.UseDataStore then
        -- Load from DataStore
        local success, result = pcall(function()
            return SaveSystem.DataStore:GetAsync(configName)
        end)
        
        if not success or not result then
            warn("Failed to load config from DataStore: " .. tostring(result))
            return false
        end
        
        jsonData = result
    else
        -- Load from local storage
        if not readfile then
            warn("File system functions are not available in this environment")
            return false
        end
        
        local filePath = SaveSystem.ConfigFolder .. "/" .. configName .. ".json"
        
        -- Check if file exists
        if not isfile(filePath) then
            warn("Config file does not exist: " .. filePath)
            return false
        end
        
        -- Read file
        local success, result = pcall(function()
            return readfile(filePath)
        end)
        
        if not success then
            warn("Failed to read config file: " .. tostring(result))
            return false
        end
        
        jsonData = result
    end
    
    -- Parse JSON
    local success, data = pcall(function()
        return HttpService:JSONDecode(jsonData)
    end)
    
    if not success then
        warn("Failed to parse config data: " .. tostring(data))
        return false
    end
    
    -- Update current config
    SaveSystem.CurrentConfig = configName
    
    -- Apply configuration
    SaveSystem.ApplyConfigData(data)
    
    -- Fire load event
    SaveSystem.ConfigLoaded:Fire(configName, data)
    
    return true
end

-- Delete a saved configuration
function SaveSystem.DeleteConfig(configName)
    -- Initialize if not already done
    if not SaveSystem.Initialized then
        SaveSystem.Initialize()
    end
    
    -- Validate config name
    if not configName or configName == "" then
        warn("Invalid config name")
        return false
    end
    
    -- Delete configuration
    if SaveSystem.UseDataStore then
        -- Delete from DataStore
        local success, errorMessage = pcall(function()
            SaveSystem.DataStore:RemoveAsync(configName)
            
            -- Update config list
            local index = table.find(SaveSystem.Configs, configName)
            if index then
                table.remove(SaveSystem.Configs, index)
                SaveSystem.DataStore:SetAsync("ConfigList", SaveSystem.Configs)
            end
        end)
        
        if not success then
            warn("Failed to delete config from DataStore: " .. tostring(errorMessage))
            return false
        end
    else
        -- Delete from local storage
        if not delfile then
            warn("File system functions are not available in this environment")
            return false
        end
        
        local filePath = SaveSystem.ConfigFolder .. "/" .. configName .. ".json"
        
        -- Check if file exists
        if not isfile(filePath) then
            warn("Config file does not exist: " .. filePath)
            return false
        end
        
        -- Delete file
        local success, errorMessage = pcall(function()
            delfile(filePath)
        end)
        
        if not success then
            warn("Failed to delete config file: " .. tostring(errorMessage))
            return false
        end
        
        -- Update config list
        local index = table.find(SaveSystem.Configs, configName)
        if index then
            table.remove(SaveSystem.Configs, index)
        end
    end
    
    -- Reset current config if it was deleted
    if SaveSystem.CurrentConfig == configName then
        SaveSystem.CurrentConfig = Config.Extra.SaveSystem.DefaultConfigName
    end
    
    return true
end

-- Gather current configuration data from the UI
function SaveSystem.GatherConfigData()
    -- This function will be implemented by the Main module
    -- It will collect all UI element states
    
    -- For now, return an empty configuration
    return {
        Theme = "Nebula", -- Default theme
        Elements = {},
        SavedAt = os.time()
    }
end

-- Apply configuration data to the UI
function SaveSystem.ApplyConfigData(data)
    -- This function will be implemented by the Main module
    -- It will apply the loaded configuration to all UI elements
    
    -- For now, do nothing
}

-- Clean up
function SaveSystem.Destroy()
    -- Stop auto-save
    SaveSystem.StopAutoSave()
    
    -- Destroy signals
    if SaveSystem.ConfigSaved then
        SaveSystem.ConfigSaved:Destroy()
    end
    
    if SaveSystem.ConfigLoaded then
        SaveSystem.ConfigLoaded:Destroy()
    end
    
    if SaveSystem.AutoSaveChanged then
        SaveSystem.AutoSaveChanged:Destroy()
    end
}

return SaveSystem

-- ========================== Extra/Prompt.lua ==========================
--[[
    Prompt component for the UI library
    Displays modal prompts for user interaction
]]
local Prompt = {}
Prompt.__index = Prompt

-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")

-- Dependencies
local function requireModule(name)
    return require(script.Parent.Parent.Core[name])
end

local Utils
local ThemeManager
local Config
local Init
local Signal

-- Prompt types
Prompt.Types = {
    Confirm = "Confirm", -- Yes/No or OK/Cancel
    Alert = "Alert", -- Just OK button
    Prompt = "Prompt" -- Input field
}

-- Active prompts
Prompt.Active = {}

-- Currently displayed prompt
Prompt.Current = nil

-- Container for prompts
Prompt.Container = nil
Prompt.Overlay = nil

-- Create prompt container
function Prompt.SetupContainer()
    -- Load dependencies if not loaded
    if not Utils then
        Utils = requireModule("Utils")
        ThemeManager = requireModule("ThemeManager")
        Config = requireModule("Config")
        Init = requireModule("Init")
        Signal = requireModule("Signal")
    end
    
    -- Check if container already exists
    if Prompt.Container then
        return Prompt.Container
    end
    
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NebulaUI_Prompts"
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 10
    
    -- Parent it appropriately
    if Init.IS_STUDIO then
        screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    else
        pcall(function()
            screenGui.Parent = CoreGui
        end)
        
        if not screenGui.Parent then
            screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
        end
    end
    
    -- Create overlay
    local overlay = Instance.new("Frame")
    overlay.Name = "PromptOverlay"
    overlay.Size = UDim2.fromScale(1, 1)
    overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    overlay.BackgroundTransparency = 1
    overlay.Visible = false
    overlay.ZIndex = 100
    overlay.Parent = screenGui
    
    -- Create container
    local container = Instance.new("Frame")
    container.Name = "PromptContainer"
    container.Size = UDim2.fromScale(1, 1)
    container.BackgroundTransparency = 1
    container.Visible = false
    container.ZIndex = 101
    container.Parent = screenGui
    
    -- Store references
    Prompt.Container = container
    Prompt.Overlay = overlay
    Prompt.ScreenGui = screenGui
    
    -- Block input when overlay is visible
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if overlay.Visible and (
            input.UserInputType == Enum.UserInputType.MouseButton1 or
            input.UserInputType == Enum.UserInputType.Touch
        ) then
            -- Check if click is inside the prompt
            local mousePos = UserInputService:GetMouseLocation()
            
            if Prompt.Current and Prompt.Current.Frame then
                local promptPos = Prompt.Current.Frame.AbsolutePosition
                local promptSize = Prompt.Current.Frame.AbsoluteSize
                
                if not (
                    mousePos.X >= promptPos.X and
                    mousePos.X <= promptPos.X + promptSize.X and
                    mousePos.Y >= promptPos.Y and
                    mousePos.Y <= promptPos.Y + promptSize.Y
                ) then
                    -- Close if cancelable
                    if Prompt.Current.Cancelable then
                        Prompt.Current:Cancel()
                    end
                end
            end
        end
    end)
    
    return container
end

-- Show a confirm prompt (Yes/No or OK/Cancel)
function Prompt.Confirm(title, message, options)
    options = options or {}
    options.Title = title
    options.Message = message
    options.Type = Prompt.Types.Confirm
    
    return Prompt.Show(options)
end

-- Show an alert prompt (just OK button)
function Prompt.Alert(title, message, options)
    options = options or {}
    options.Title = title
    options.Message = message
    options.Type = Prompt.Types.Alert
    
    return Prompt.Show(options)
end

-- Show a prompt with input field
function Prompt.Input(title, message, options)
    options = options or {}
    options.Title = title
    options.Message = message
    options.Type = Prompt.Types.Prompt
    
    return Prompt.Show(options)
end

-- Show a prompt
function Prompt.Show(options)
    options = options or {}
    
    -- Set up container if needed
    if not Prompt.Container then
        Prompt.SetupContainer()
    end
    
    -- Create new prompt instance
    local prompt = setmetatable({}, Prompt)
    
    -- Set options
    prompt.Title = options.Title or "Prompt"
    prompt.Message = options.Message or ""
    prompt.Type = options.Type or Prompt.Types.Confirm
    prompt.Callback = options.Callback
    prompt.CancelCallback = options.CancelCallback
    prompt.YesText = options.YesText or "Yes"
    prompt.NoText = options.NoText or "No"
    prompt.OkText = options.OkText or "OK"
    prompt.CancelText = options.CancelText or "Cancel"
    prompt.InputPlaceholder = options.InputPlaceholder or "Enter text..."
    prompt.DefaultValue = options.DefaultValue or ""
    prompt.Cancelable = options.Cancelable ~= false
    prompt.Theme = options.CustomTheme
    
    -- Create events
    prompt.Closed = Signal.new()
    
    -- Create prompt UI
    prompt:Create()
    
    -- Add to active prompts
    table.insert(Prompt.Active, prompt)
    
    -- Display prompt
    prompt:Display()
    
    return prompt
end

-- Create prompt UI
function Prompt:Create()
    -- Main frame
    self.Frame = Instance.new("Frame")
    self.Frame.Name = "Prompt_" .. Utils.GenerateUID(5)
    self.Frame.Size = UDim2.fromOffset(Config.Extra.Prompt.Width, Config.Extra.Prompt.MinHeight)
    self.Frame.BackgroundColor3 = self:GetTheme().Prompt.Background
    self.Frame.BackgroundTransparency = 0
    self.Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.Frame.Position = UDim2.fromScale(0.5, 0.5)
    self.Frame.Visible = false
    self.Frame.Parent = Prompt.Container
    
    -- Add corner
    self.Corner = Utils.RoundCorners(self.Frame, UDim.new(0, Config.Extra.Prompt.CornerRadius.Offset))
    
    -- Add stroke
    self.Stroke = Utils.AddStroke(
        self.Frame,
        self:GetTheme().Prompt.BorderColor,
        Config.Extra.Prompt.BorderWidth
    )
    
    -- Add padding
    self.Padding = Utils.AddPadding(self.Frame, Config.Extra.Prompt.Padding)
    
    -- Create content
    self:CreateContent()
    
    -- Create buttons
    self:CreateButtons()
    
    -- Calculate height based on content
    self:UpdateHeight()
    
    -- Add shadow
    Utils.CreateShadow(self.Frame, 12, 0.5)
}

-- Create prompt content
function Prompt:CreateContent()
    -- Title text
    self.TitleText = Instance.new("TextLabel")
    self.TitleText.Name = "Title"
    self.TitleText.Size = UDim2.new(1, 0, 0, Config.Extra.Prompt.TitleTextSize + 8)
    self.TitleText.BackgroundTransparency = 1
    self.TitleText.Font = Config.Extra.Prompt.TitleFont
    self.TitleText.TextSize = Config.Extra.Prompt.TitleTextSize
    self.TitleText.TextColor3 = self:GetTheme().Prompt.TextColor
    self.TitleText.Text = self.Title
    self.TitleText.TextXAlignment = Enum.TextXAlignment.Left
    self.TitleText.Parent = self.Frame
    
    -- Message text
    self.MessageText = Instance.new("TextLabel")
    self.MessageText.Name = "Message"
    self.MessageText.Size = UDim2.new(1, 0, 0, 0)
    self.MessageText.Position = UDim2.new(0, 0, 0, self.TitleText.Size.Y.Offset + Config.Extra.Prompt.Padding / 2)
    self.MessageText.BackgroundTransparency = 1
    self.MessageText.Font = Config.Extra.Prompt.TextFont
    self.MessageText.TextSize = Config.Extra.Prompt.TextSize
    self.MessageText.TextColor3 = self:GetTheme().Prompt.TextColor
    self.MessageText.Text = self.Message
    self.MessageText.TextXAlignment = Enum.TextXAlignment.Left
    self.MessageText.TextYAlignment = Enum.TextYAlignment.Top
    self.MessageText.TextWrapped = true
    self.MessageText.AutomaticSize = Enum.AutomaticSize.Y
    self.MessageText.Parent = self.Frame
    
    -- Add input field if it's a prompt type
    if self.Type == Prompt.Types.Prompt then
        self:CreateInputField()
    end
}

-- Create input field for prompt
function Prompt:CreateInputField()
    -- Input container
    self.InputContainer = Instance.new("Frame")
    self.InputContainer.Name = "InputContainer"
    self.InputContainer.Size = UDim2.new(1, 0, 0, 32)
    self.InputContainer.Position = UDim2.new(0, 0, 0, self.TitleText.Size.Y.Offset + 10)
    self.InputContainer.BackgroundColor3 = self:GetTheme().Prompt.Background
    self.InputContainer.BackgroundTransparency = 0.5
    self.InputContainer.BorderSizePixel = 0
    self.InputContainer.Parent = self.Frame
    
    -- Add corner
    Utils.RoundCorners(self.InputContainer, UDim.new(0, 4))
    
    -- Add stroke
    Utils.AddStroke(
        self.InputContainer,
        self:GetTheme().Prompt.BorderColor,
        1
    )
    
    -- Input text box
    self.InputField = Instance.new("TextBox")
    self.InputField.Name = "InputField"
    self.InputField.Size = UDim2.new(1, -10, 1, 0)
    self.InputField.Position = UDim2.fromOffset(5, 0)
    self.InputField.BackgroundTransparency = 1
    self.InputField.Font = Config.Extra.Prompt.TextFont
    self.InputField.TextSize = Config.Extra.Prompt.TextSize
    self.InputField.TextColor3 = self:GetTheme().Prompt.TextColor
    self.InputField.PlaceholderText = self.InputPlaceholder
    self.InputField.PlaceholderColor3 = Color3.fromRGB(180, 180, 180)
    self.InputField.Text = self.DefaultValue
    self.InputField.ClearTextOnFocus = false
    self.InputField.Parent = self.InputContainer
    
    -- Reposition message text
    self.MessageText.Position = UDim2.new(0, 0, 0, self.TitleText.Size.Y.Offset + Config.Extra.Prompt.Padding / 2)
    
    -- Reposition input container
    self.InputContainer.Position = UDim2.new(
        0, 
        0, 
        0, 
        self.TitleText.Size.Y.Offset + self.MessageText.AbsoluteSize.Y + Config.Extra.Prompt.Padding
    )
}

-- Create prompt buttons
function Prompt:CreateButtons()
    -- Buttons container
    self.ButtonsContainer = Instance.new("Frame")
    self.ButtonsContainer.Name = "ButtonsContainer"
    self.ButtonsContainer.Size = UDim2.new(1, 0, 0, Config.Extra.Prompt.ButtonHeight)
    self.ButtonsContainer.Position = UDim2.new(0, 0, 1, -Config.Extra.Prompt.ButtonHeight)
    self.ButtonsContainer.BackgroundTransparency = 1
    self.ButtonsContainer.Parent = self.Frame
    
    -- Create different buttons based on prompt type
    if self.Type == Prompt.Types.Confirm then
        -- Yes/No or OK/Cancel buttons
        self:CreateConfirmButtons()
    elseif self.Type == Prompt.Types.Alert then
        -- Just OK button
        self:CreateAlertButton()
    elseif self.Type == Prompt.Types.Prompt then
        -- OK/Cancel buttons for input prompt
        self:CreatePromptButtons()
    end
}

-- Create confirm buttons (Yes/No)
function Prompt:CreateConfirmButtons()
    -- Yes button
    self.YesButton = self:CreateButton(
        self.YesText,
        UDim2.new(0.48, 0, 0, Config.Extra.Prompt.ButtonHeight),
        UDim2.new(0, 0, 0, 0)
    )
    
    -- Connect yes button
    self.YesButton.MouseButton1Click:Connect(function()
        self:Confirm(true)
    end)
    
    -- No button
    self.NoButton = self:CreateButton(
        self.NoText,
        UDim2.new(0.48, 0, 0, Config.Extra.Prompt.ButtonHeight),
        UDim2.new(0.52, 0, 0, 0)
    )
    
    -- Connect no button
    self.NoButton.MouseButton1Click:Connect(function()
        self:Confirm(false)
    end)
}

-- Create alert button (just OK)
function Prompt:CreateAlertButton()
    -- OK button
    self.OkButton = self:CreateButton(
        self.OkText,
        UDim2.new(1, 0, 0, Config.Extra.Prompt.ButtonHeight),
        UDim2.new(0, 0, 0, 0)
    )
    
    -- Connect OK button
    self.OkButton.MouseButton1Click:Connect(function()
        self:Confirm(true)
    end)
}

-- Create prompt buttons (OK/Cancel)
function Prompt:CreatePromptButtons()
    -- OK button
    self.OkButton = self:CreateButton(
        self.OkText,
        UDim2.new(0.48, 0, 0, Config.Extra.Prompt.ButtonHeight),
        UDim2.new(0, 0, 0, 0)
    )
    
    -- Connect OK button
    self.OkButton.MouseButton1Click:Connect(function()
        self:Confirm(self.InputField.Text)
    end)
    
    -- Cancel button
    self.CancelButton = self:CreateButton(
        self.CancelText,
        UDim2.new(0.48, 0, 0, Config.Extra.Prompt.ButtonHeight),
        UDim2.new(0.52, 0, 0, 0)
    )
    
    -- Connect cancel button
    self.CancelButton.MouseButton1Click:Connect(function()
        self:Cancel()
    end)
}

-- Helper to create a button
function Prompt:CreateButton(text, size, position)
    -- Button
    local button = Instance.new("TextButton")
    button.Name = text .. "Button"
    button.Size = size
    button.Position = position
    button.BackgroundColor3 = self:GetTheme().Prompt.ButtonBackground
    button.Font = Config.Extra.Prompt.ButtonFont
    button.TextSize = Config.Extra.Prompt.ButtonTextSize
    button.TextColor3 = self:GetTheme().Prompt.ButtonTextColor
    button.Text = text
    button.AutoButtonColor = false
    button.Parent = self.ButtonsContainer
    
    -- Add corner
    Utils.RoundCorners(button, UDim.new(0, Config.Extra.Prompt.ButtonCornerRadius.Offset))
    
    -- Add stroke
    Utils.AddStroke(
        button,
        self:GetTheme().Prompt.BorderColor,
        1
    )
    
    -- Hover effects
    button.MouseEnter:Connect(function()
        Utils.Tween(
            button,
            {BackgroundColor3 = self:GetTheme().Prompt.ButtonBackgroundHover},
            0.2
        )
    end)
    
    button.MouseLeave:Connect(function()
        Utils.Tween(
            button,
            {BackgroundColor3 = self:GetTheme().Prompt.ButtonBackground},
            0.2
        )
    end)
    
    return button
}

-- Get theme
function Prompt:GetTheme()
    return self.Theme or ThemeManager:GetTheme().Extra
end

-- Update prompt height based on content
function Prompt:UpdateHeight()
    -- Wait for text to layout
    task.defer(function()
        -- Calculate content height
        local titleHeight = self.TitleText.Size.Y.Offset
        local messageHeight = self.MessageText.AbsoluteSize.Y
        local buttonHeight = Config.Extra.Prompt.ButtonHeight
        local padding = Config.Extra.Prompt.Padding * 2
        local inputHeight = self.InputContainer and (self.InputContainer.Size.Y.Offset + Config.Extra.Prompt.Padding) or 0
        
        -- Set frame height
        local totalHeight = titleHeight + messageHeight + buttonHeight + padding + inputHeight
        totalHeight = math.max(totalHeight, Config.Extra.Prompt.MinHeight)
        
        self.Frame.Size = UDim2.new(0, Config.Extra.Prompt.Width, 0, totalHeight)
        
        -- Reposition buttons
        self.ButtonsContainer.Position = UDim2.new(0, 0, 0, totalHeight - buttonHeight - Config.Extra.Prompt.Padding)
    end)
}

-- Display the prompt
function Prompt:Display()
    -- Ensure container is set up
    if not Prompt.Container then
        Prompt.SetupContainer()
    end
    
    -- Close any currently displayed prompt
    if Prompt.Current then
        Prompt.Current:Close(false)
    end
    
    -- Show overlay and container
    Prompt.Overlay.Visible = true
    Prompt.Container.Visible = true
    
    -- Fade in overlay
    Prompt.Overlay.BackgroundTransparency = 1
    Utils.Tween(
        Prompt.Overlay,
        {BackgroundTransparency = 0.5},
        Config.Extra.Prompt.AnimationDuration
    )
    
    -- Show prompt frame
    self.Frame.Visible = true
    
    -- Animate in (scale from center)
    self.Frame.Size = UDim2.new(0, 0, 0, 0)
    Utils.Tween(
        self.Frame,
        {Size = UDim2.fromOffset(Config.Extra.Prompt.Width, self.Frame.Size.Y.Offset)},
        Config.Extra.Prompt.AnimationDuration,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    
    -- Set as current prompt
    Prompt.Current = self
    
    -- Focus input field if it exists
    if self.InputField then
        self.InputField:CaptureFocus()
        
        -- Connect enter key to confirm
        self.InputEnterConnection = self.InputField.FocusLost:Connect(function(enterPressed)
            if enterPressed then
                self:Confirm(self.InputField.Text)
            end
        end)
    end
}

-- Confirm the prompt
function Prompt:Confirm(result)
    -- Call callback
    if self.Callback then
        self.Callback(result)
    end
    
    -- Close the prompt
    self:Close(true)
}

-- Cancel the prompt
function Prompt:Cancel()
    -- Call cancel callback
    if self.CancelCallback then
        self.CancelCallback()
    end
    
    -- Close the prompt
    self:Close(false)
}

-- Close the prompt
function Prompt:Close(confirmed)
    -- Disconnect input enter connection if it exists
    if self.InputEnterConnection then
        self.InputEnterConnection:Disconnect()
        self.InputEnterConnection = nil
    end
    
    -- Animate out
    Utils.Tween(
        self.Frame,
        {Size = UDim2.new(0, 0, 0, 0)},
        Config.Extra.Prompt.AnimationDuration,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.In,
        0,
        false,
        function()
            -- Hide frame
            self.Frame.Visible = false
            
            -- Remove from active prompts
            local index = table.find(Prompt.Active, self)
            if index then
                table.remove(Prompt.Active, index)
            end
            
            -- Show next prompt if any
            local nextPrompt = Prompt.Active[#Prompt.Active]
            if nextPrompt then
                nextPrompt:Display()
            else
                -- Hide overlay and container
                Utils.Tween(
                    Prompt.Overlay,
                    {BackgroundTransparency = 1},
                    Config.Extra.Prompt.AnimationDuration,
                    Enum.EasingStyle.Quad,
                    Enum.EasingDirection.Out,
                    0,
                    false,
                    function()
                        Prompt.Overlay.Visible = false
                        Prompt.Container.Visible = false
                    end
                )
                
                -- Clear current prompt
                Prompt.Current = nil
            end
            
            -- Destroy frame
            self.Frame:Destroy()
            
            -- Fire closed event
            self.Closed:Fire(confirmed)
            self.Closed:Destroy()
        end
    )
}

-- Create a yes/no confirm prompt
function Prompt.YesNo(title, message, callback, options)
    options = options or {}
    options.Title = title
    options.Message = message
    options.Callback = callback
    options.Type = Prompt.Types.Confirm
    options.YesText = options.YesText or "Yes"
    options.NoText = options.NoText or "No"
    
    return Prompt.Show(options)
}

-- Create an OK/Cancel confirm prompt
function Prompt.OkCancel(title, message, callback, options)
    options = options or {}
    options.Title = title
    options.Message = message
    options.Callback = callback
    options.Type = Prompt.Types.Confirm
    options.YesText = options.YesText or "OK"
    options.NoText = options.NoText or "Cancel"
    
    return Prompt.Show(options)
}

-- Close all prompts
function Prompt.CloseAll()
    -- Clone the table to avoid issues while iterating
    local activePrompts = table.clone(Prompt.Active)
    
    -- Close all prompts
    for _, prompt in ipairs(activePrompts) do
        prompt:Close(false)
    end
}

return Prompt

-- ========================== Main.lua ==========================
--[[
    Main module for the NebulaUI library
    Entry point that brings all components together
]]
local NebulaUI = {}
NebulaUI.__index = NebulaUI

-- Version information
NebulaUI.Version = "1.0.0"
NebulaUI.VersionInfo = {
    Major = 1,
    Minor = 0,
    Patch = 0
}

-- Core modules
NebulaUI.Core = {
    Init = script.Parent.Core.Init,
    Signal = script.Parent.Core.Signal,
    Utils = script.Parent.Core.Utils,
    ThemeManager = script.Parent.Core.ThemeManager,
    Drag = script.Parent.Core.Drag,
    Config = script.Parent.Core.Config
}

-- Components
NebulaUI.Components = {
    Button = script.Parent.Components.Button,
    Toggle = script.Parent.Components.Toggle,
    Slider = script.Parent.Components.Slider,
    Dropdown = script.Parent.Components.Dropdown,
    Keybind = script.Parent.Components.Keybind,
    ColorPicker = script.Parent.Components.ColorPicker
}

-- Layout
NebulaUI.Layout = {
    Window = script.Parent.Layout.Window,
    TabManager = script.Parent.Layout.TabManager,
    Section = script.Parent.Layout.Section,
    Scrolling = script.Parent.Layout.Scrolling
}

-- Extra
NebulaUI.Extra = {
    Notification = script.Parent.Extra.Notification,
    SaveSystem = script.Parent.Extra.SaveSystem,
    Prompt = script.Parent.Extra.Prompt
}

-- Loaded modules cache
NebulaUI.Modules = {}

-- Active windows
NebulaUI.Windows = {}

-- Initialize the library
function NebulaUI.Init(options)
    options = options or {}
    
    -- Get Init module
    local Init = NebulaUI:GetModule("Init")
    
    -- Initialize core modules
    Init:Initialize()
    
    -- Initialize theme manager
    local ThemeManager = NebulaUI:GetModule("ThemeManager")
    
    -- Set theme if specified
    if options.Theme then
        ThemeManager:SetTheme(options.Theme)
    end
    
    -- Initialize save system if enabled
    if options.SaveSystem ~= false then
        local SaveSystem = NebulaUI:GetModule("SaveSystem")
        SaveSystem.Initialize(options.SaveSystemOptions)
    end
    
    return NebulaUI
end

-- Get a module (with lazy loading)
function NebulaUI:GetModule(name)
    -- Return from cache if already loaded
    if self.Modules[name] then
        return self.Modules[name]
    end
    
    -- Find module path
    local modulePath
    
    if self.Core[name] then
        modulePath = self.Core[name]
    elseif self.Components[name] then
        modulePath = self.Components[name]
    elseif self.Layout[name] then
        modulePath = self.Layout[name]
    elseif self.Extra[name] then
        modulePath = self.Extra[name]
    end
    
    -- Load module
    if modulePath then
        local module = require(modulePath)
        self.Modules[name] = module
        return module
    end
    
    error("Module not found: " .. name)
}

-- Create a new window
function NebulaUI:CreateWindow(options)
    -- Get Window module
    local Window = self:GetModule("Window")
    
    -- Create new window
    local window = Window.new(options)
    
    -- Store window
    table.insert(self.Windows, window)
    
    return window
}

-- Show a notification
function NebulaUI:Notify(title, content, options)
    -- Get Notification module
    local Notification = self:GetModule("Notification")
    
    -- Show notification
    return Notification.Show({
        Title = title,
        Content = content,
        Type = options and options.Type or Notification.Types.Default,
        Duration = options and options.Duration,
        Callback = options and options.Callback,
        CustomTheme = options and options.CustomTheme
    })
}

-- Show success notification
function NebulaUI:NotifySuccess(title, content, options)
    -- Get Notification module
    local Notification = self:GetModule("Notification")
    
    -- Show success notification
    return Notification.Success(title, content, options)
}

-- Show error notification
function NebulaUI:NotifyError(title, content, options)
    -- Get Notification module
    local Notification = self:GetModule("Notification")
    
    -- Show error notification
    return Notification.Error(title, content, options)
}

-- Show a prompt
function NebulaUI:Prompt(title, message, options)
    -- Get Prompt module
    local Prompt = self:GetModule("Prompt")
    
    -- Show prompt
    return Prompt.Show({
        Title = title,
        Message = message,
        Type = options and options.Type or Prompt.Types.Confirm,
        Callback = options and options.Callback,
        CancelCallback = options and options.CancelCallback,
        YesText = options and options.YesText,
        NoText = options and options.NoText,
        OkText = options and options.OkText,
        CancelText = options and options.CancelText,
        InputPlaceholder = options and options.InputPlaceholder,
        DefaultValue = options and options.DefaultValue,
        Cancelable = options and options.Cancelable,
        CustomTheme = options and options.CustomTheme
    })
}

-- Create a theme
function NebulaUI:CreateTheme(name, baseTheme)
    -- Get ThemeManager module
    local ThemeManager = self:GetModule("ThemeManager")
    
    -- Create theme
    return ThemeManager:CreateTheme(name, baseTheme)
}

-- Set active theme
function NebulaUI:SetTheme(themeName)
    -- Get ThemeManager module
    local ThemeManager = self:GetModule("ThemeManager")
    
    -- Set theme
    return ThemeManager:SetTheme(themeName)
}

-- Get the current theme
function NebulaUI:GetTheme()
    -- Get ThemeManager module
    local ThemeManager = self:GetModule("ThemeManager")
    
    -- Get theme
    return ThemeManager:GetTheme()
}

-- Save configuration
function NebulaUI:SaveConfig(configName)
    -- Get SaveSystem module
    local SaveSystem = self:GetModule("SaveSystem")
    
    -- Gather configuration data
    local data = self:GatherConfigData()
    
    -- Save config
    return SaveSystem.SaveConfig(configName, data)
}

-- Load configuration
function NebulaUI:LoadConfig(configName)
    -- Get SaveSystem module
    local SaveSystem = self:GetModule("SaveSystem")
    
    -- Load config
    return SaveSystem.LoadConfig(configName)
}

-- Gather configuration data
function NebulaUI:GatherConfigData()
    -- Get theme information
    local ThemeManager = self:GetModule("ThemeManager")
    local currentTheme = ThemeManager:GetTheme().Name
    
    -- Configuration data
    local data = {
        Theme = currentTheme,
        Windows = {},
        SavedAt = os.time()
    }
    
    -- Gather data from all windows
    for _, window in ipairs(self.Windows) do
        if window.GatherConfigData then
            table.insert(data.Windows, window:GatherConfigData())
        end
    end
    
    return data
}

-- Apply configuration data
function NebulaUI:ApplyConfigData(data)
    -- Set theme
    if data.Theme then
        self:SetTheme(data.Theme)
    end
    
    -- Apply to windows
    if data.Windows then
        for i, windowData in ipairs(data.Windows) do
            if self.Windows[i] and self.Windows[i].ApplyConfigData then
                self.Windows[i]:ApplyConfigData(windowData)
            end
        end
    end
}

-- Destroy all windows and clean up
function NebulaUI:Destroy()
    -- Destroy all windows
    for _, window in ipairs(self.Windows) do
        window:Destroy()
    end
    
    -- Clear windows
    table.clear(self.Windows)
    
    -- Close all notifications
    local Notification = self:GetModule("Notification")
    Notification.ClearAll()
    
    -- Close all prompts
    local Prompt = self:GetModule("Prompt")
    Prompt.CloseAll()
    
    -- Clean up SaveSystem
    local SaveSystem = self:GetModule("SaveSystem")
    SaveSystem.Destroy()
    
    -- Clear modules cache
    table.clear(self.Modules)
}

return NebulaUI
