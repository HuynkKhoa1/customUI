-- SmoothFluent UI v2.0 - Full Source (Restructured)
-- Created by Grok (xAI) on April 06, 2025
-- Restructured to ensure proper functionality

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local TextService = game:GetService("TextService")

-- Utility Functions
local function deepCopy(t)
    local copy = {}
    for k, v in pairs(t) do
        if type(v) == "table" then
            copy[k] = deepCopy(v)
        else
            copy[k] = v
        end
    end
    return copy
end

local function clamp(value, min, max)
    return math.max(min, math.min(max, value))
end

local function createInstance(className, properties)
    local instance = Instance.new(className)
    for prop, value in pairs(properties or {}) do
        instance[prop] = value
    end
    return instance
end

-- Constants
local DEFAULT_THEME = "SmoothDream"
local MAX_LOG_SIZE = 500
local DEFAULT_WINDOW_SIZE = UDim2.new(0, 600, 0, 400)
local MIN_WINDOW_SIZE = UDim2.new(0, 200, 0, 30)

-- Theme Definitions
local Themes = {
    SmoothDream = {
        Primary = Color3.fromRGB(255, 215, 0),
        Background = Color3.fromRGB(10, 10, 20),
        Secondary = Color3.fromRGB(30, 30, 40),
        Accent = Color3.fromRGB(50, 50, 60),
        Text = Color3.fromRGB(255, 255, 255),
        Transparency = 0.9,
        Gradient = {Color3.fromRGB(255, 215, 0), Color3.fromRGB(200, 150, 0)}
    },
    DarkMode = {
        Primary = Color3.fromRGB(100, 100, 100),
        Background = Color3.fromRGB(20, 20, 20),
        Secondary = Color3.fromRGB(40, 40, 40),
        Accent = Color3.fromRGB(60, 60, 60),
        Text = Color3.fromRGB(200, 200, 200),
        Transparency = 0.8,
        Gradient = {Color3.fromRGB(100, 100, 100), Color3.fromRGB(50, 50, 50)}
    },
    Neon = {
        Primary = Color3.fromRGB(0, 255, 255),
        Background = Color3.fromRGB(0, 0, 30),
        Secondary = Color3.fromRGB(20, 20, 50),
        Accent = Color3.fromRGB(40, 40, 70),
        Text = Color3.fromRGB(255, 255, 255),
        Transparency = 0.85,
        Gradient = {Color3.fromRGB(0, 255, 255), Color3.fromRGB(0, 150, 255)}
    }
}

-- Spring Animation Class
local Spring = {}
Spring.__index = Spring

function Spring.new(target, options)
    options = options or {}
    local self = setmetatable({
        target = target,
        position = target,
        velocity = 0,
        frequency = options.frequency or 4,
        damping = options.damping or 1,
        stiffness = options.stiffness or 100,
        mass = options.mass or 1
    }, Spring)
    return self
end

function Spring:step(dt)
    local f = self.frequency * 2 * math.pi
    local g = self.damping
    local k = self.stiffness
    local m = self.mass
    local p0 = self.position
    local v0 = self.velocity
    local t = self.target
    
    local offset = p0 - t
    local decay = math.exp(-g * dt)
    
    local accel = -k * offset / m - g * v0
    self.velocity = v0 + accel * dt
    self.position = p0 + self.velocity * dt
    
    if math.abs(self.velocity) < 0.01 and math.abs(offset) < 0.01 then
        self.position = t
        self.velocity = 0
    end
    
    return self.position
end

function Spring:animate(property, instance, target, options)
    local spring = Spring.new(instance[property], options)
    spring.target = target
    
    local connection
    connection = RunService.RenderStepped:Connect(function(dt)
        local newValue = spring:step(dt)
        instance[property] = newValue
        
        if spring.velocity == 0 and spring.position == target then
            connection:Disconnect()
        end
    end)
    
    return connection
end

-- Animation Utility Functions
local AnimationUtils = {}

function AnimationUtils.springTo(instance, property, target, options)
    return Spring:animate(property, instance, target, options)
end

function AnimationUtils.createRipple(parent, position)
    local ripple = Instance.new("Frame")
    ripple.Size = UDim2.new(0, 0, 0, 0)
    ripple.Position = position
    ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ripple.BackgroundTransparency = 0.7
    ripple.ZIndex = 2
    ripple.Parent = parent
    
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(ripple, tweenInfo, {
        Size = UDim2.new(0, 100, 0, 100),
        BackgroundTransparency = 1
    }):Play()
    
    delay(0.5, function()
        ripple:Destroy()
    end)
end

function AnimationUtils.fadeIn(instance, duration)
    instance.Visible = true
    local tweenInfo = TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(instance, tweenInfo, {BackgroundTransparency = 0, TextTransparency = 0, ImageTransparency = 0}):Play()
end

function AnimationUtils.fadeOut(instance, duration)
    local tweenInfo = TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(instance, tweenInfo, {BackgroundTransparency = 1, TextTransparency = 1, ImageTransparency = 1}):Play()
    delay(duration or 0.3, function()
        instance.Visible = false
    end)
end

-- Particle System
local ParticleSystem = {}
ParticleSystem.__index = ParticleSystem

function ParticleSystem.new(parent, options)
    options = options or {}
    local self = setmetatable({
        parent = parent,
        particles = {},
        maxParticles = options.maxParticles or 50,
        spawnRate = options.spawnRate or 0.1,
        lifetime = options.lifetime or 1,
        size = options.size or UDim2.new(0, 10, 0, 10),
        color = options.color or Color3.fromRGB(255, 215, 0),
        speed = options.speed or 50,
        spread = options.spread or math.pi / 4,
        active = false
    }, ParticleSystem)
    
    self:Initialize()
    return self
end

function ParticleSystem:Initialize()
    self.spawnConnection = RunService.Heartbeat:Connect(function(dt)
        if self.active and #self.particles < self.maxParticles then
            self:SpawnParticle()
        end
        
        for i = #self.particles, 1, -1 do
            local particle = self.particles[i]
            particle.time = particle.time + dt
            
            if particle.time >= self.lifetime then
                particle.instance:Destroy()
                table.remove(self.particles, i)
            else
                local angle = particle.angle
                local speed = self.speed * dt
                particle.position = particle.position + Vector2.new(math.cos(angle) * speed, math.sin(angle) * speed)
                particle.instance.Position = UDim2.new(0, particle.position.X, 0, particle.position.Y)
                
                local alpha = 1 - (particle.time / self.lifetime)
                particle.instance.ImageTransparency = 1 - alpha
            end
        end
    end)
end

function ParticleSystem:SpawnParticle()
    local particle = Instance.new("ImageLabel")
    particle.Size = self.size
    particle.BackgroundTransparency = 1
    particle.Image = "rbxassetid://6065775281"
    particle.ImageColor3 = self.color
    particle.Parent = self.parent
    
    local angle = math.random() * 2 * math.pi
    local spreadAngle = math.random(-self.spread, self.spread)
    local spawnPos = Vector2.new(self.parent.AbsoluteSize.X / 2, self.parent.AbsoluteSize.Y / 2)
    
    table.insert(self.particles, {
        instance = particle,
        position = spawnPos,
        angle = angle + spreadAngle,
        time = 0
    })
    
    particle.Position = UDim2.new(0, spawnPos.X, 0, spawnPos.Y)
end

function ParticleSystem:Start()
    self.active = true
end

function ParticleSystem:Stop()
    self.active = false
end

function ParticleSystem:Destroy()
    self:Stop()
    if self.spawnConnection then
        self.spawnConnection:Disconnect()
    end
    for _, particle in pairs(self.particles) do
        particle.instance:Destroy()
    end
    self.particles = {}
end

-- Theme Manager
local ThemeManager = {}
ThemeManager.__index = ThemeManager

function ThemeManager.new()
    local self = setmetatable({
        currentTheme = "SmoothDream",
        instances = {}
    }, ThemeManager)
    return self
end

function ThemeManager:RegisterInstance(instance, properties)
    self.instances[instance] = properties
    self:ApplyThemeToInstance(instance)
end

function ThemeManager:UnregisterInstance(instance)
    self.instances[instance] = nil
end

function ThemeManager:SetTheme(themeName)
    if not Themes[themeName] then
        warn("Theme '" .. themeName .. "' does not exist!")
        return
    end
    self.currentTheme = themeName
    self:ApplyTheme()
end

function ThemeManager:GetTheme()
    return deepCopy(Themes[self.currentTheme])
end

function ThemeManager:ApplyTheme()
    for instance, properties in pairs(self.instances) do
        self:ApplyThemeToInstance(instance)
    end
end

function ThemeManager:ApplyThemeToInstance(instance)
    local theme = Themes[self.currentTheme]
    for prop, value in pairs(self.instances[instance]) do
        if prop == "Gradient" and theme.Gradient then
            self:ApplyGradient(instance, theme.Gradient)
        elseif theme[value] then
            instance[prop] = theme[value]
        end
    end
end

function ThemeManager:ApplyGradient(instance, colors)
    local gradient = instance:FindFirstChild("UIGradient") or Instance.new("UIGradient")
    gradient.Color = ColorSequence.new(colors[1], colors[2])
    gradient.Rotation = 45
    gradient.Parent = instance
end

function ThemeManager:CreateAcrylicEffect(instance)
    local acrylic = Instance.new("Frame")
    acrylic.Size = UDim2.new(1, 0, 1, 0)
    acrylic.BackgroundTransparency = 0.95
    acrylic.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    acrylic.ZIndex = instance.ZIndex - 1
    acrylic.Parent = instance
    
    local blur = Instance.new("BlurEffect")
    blur.Size = 10
    blur.Parent = acrylic
end

-- Component Base Class
local Component = {}
Component.__index = Component

function Component.new(type, parent, options)
    local self = setmetatable({}, Component)
    self.Type = type
    self.Parent = parent
    self.Options = options or {}
    self.Instance = nil
    self.Connections = {}
    return self
end

function Component:Destroy()
    for _, conn in pairs(self.Connections) do
        conn:Disconnect()
    end
    if self.Instance then
        self.Instance:Destroy()
    end
end

-- Button Component
local Button = setmetatable({}, {__index = Component})
Button.__index = Button

function Button.new(parent, options)
    local self = Component.new("Button", parent, options)
    
    self.Instance = Instance.new("TextButton")
    self.Instance.Size = options.Size or UDim2.new(0, 100, 0, 30)
    self.Instance.Text = options.Text or "Button"
    self.Instance.Font = Enum.Font.SourceSans
    self.Instance.TextSize = 14
    self.Instance.Parent = parent
    self.Instance.ZIndex = options.ZIndex or 1
    
    self.Callback = options.Callback or function() end
    self.Description = options.Description or function() return "A simple button" end
    
    self:Initialize()
    return self
end

function Button:Initialize()
    self.Parent.ThemeManager:RegisterInstance(self.Instance, {BackgroundColor3 = "Primary", TextColor3 = "Text"})
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseEnter:Connect(function()
        AnimationUtils.springTo(self.Instance, "TextSize", 16, {frequency = 5, damping = 0.8})
        self.Parent.TooltipText.Text = self.Description()
        self.Parent.Tooltip.Visible = true
        local size = TextService:GetTextSize(self.Parent.TooltipText.Text, 14, Enum.Font.SourceSans, Vector2.new(200, math.huge))
        self.Parent.Tooltip.Size = UDim2.new(0, size.X + 4, 0, size.Y + 4)
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseLeave:Connect(function()
        AnimationUtils.springTo(self.Instance, "TextSize", 14, {frequency = 5, damping = 0.8})
        self.Parent.Tooltip.Visible = false
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseButton1Click:Connect(function()
        local mousePos = UserInputService:GetMouseLocation()
        AnimationUtils.createRipple(self.Instance, UDim2.new(0, mousePos.X - self.Instance.AbsolutePosition.X, 0, mousePos.Y - self.Instance.AbsolutePosition.Y))
        self.Callback()
    end)
end

-- Toggle Component
local Toggle = setmetatable({}, {__index = Component})
Toggle.__index = Toggle

function Toggle.new(parent, options)
    local self = Component.new("Toggle", parent, options)
    
    self.Instance = Instance.new("Frame")
    self.Instance.Size = options.Size or UDim2.new(0, 50, 0, 25)
    self.Instance.Parent = parent
    self.Instance.ZIndex = options.ZIndex or 1
    
    self.Knob = Instance.new("Frame")
    self.Knob.Size = UDim2.new(0, 20, 0, 20)
    self.Knob.Position = UDim2.new(0, 2, 0, 2)
    self.Knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.Knob.Parent = self.Instance
    
    self.State = options.Default or false
    self.Callback = options.Callback or function(state) end
    self.Description = options.Description or function() return "A toggle switch" end
    
    self:Initialize()
    return self
end

function Toggle:Initialize()
    self.Parent.ThemeManager:RegisterInstance(self.Instance, {BackgroundColor3 = "Secondary"})
    
    self:UpdateState()
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseEnter:Connect(function()
        self.Parent.TooltipText.Text = self.Description()
        self.Parent.Tooltip.Visible = true
        local size = TextService:GetTextSize(self.Parent.TooltipText.Text, 14, Enum.Font.SourceSans, Vector2.new(200, math.huge))
        self.Parent.Tooltip.Size = UDim2.new(0, size.X + 4, 0, size.Y + 4)
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseLeave:Connect(function()
        self.Parent.Tooltip.Visible = false
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self:Toggle()
        end
    end)
end

function Toggle:Toggle()
    self.State = not self.State
    self:UpdateState()
    self.Callback(self.State)
end

function Toggle:UpdateState()
    local targetPos = self.State and UDim2.new(1, -22, 0, 2) or UDim2.new(0, 2, 0, 2)
    AnimationUtils.springTo(self.Knob, "Position", targetPos, {frequency = 6, damping = 0.9})
end

-- Dropdown Component
local Dropdown = setmetatable({}, {__index = Component})
Dropdown.__index = Dropdown

function Dropdown.new(parent, options)
    local self = Component.new("Dropdown", parent, options)
    
    self.Instance = Instance.new("TextButton")
    self.Instance.Size = options.Size or UDim2.new(0, 150, 0, 30)
    self.Instance.Text = options.Default or "Select"
    self.Instance.Font = Enum.Font.SourceSans
    self.Instance.TextSize = 14
    self.Instance.Parent = parent
    self.Instance.ZIndex = options.ZIndex or 1
    
    self.ListFrame = Instance.new("ScrollingFrame")
    self.ListFrame.Size = UDim2.new(1, 0, 0, 100)
    self.ListFrame.Position = UDim2.new(0, 0, 1, 0)
    self.ListFrame.BackgroundTransparency = 0.1
    self.ListFrame.ScrollBarThickness = 4
    self.ListFrame.Visible = false
    self.ListFrame.ZIndex = 2
    self.ListFrame.Parent = self.Instance
    
    self.ListLayout = Instance.new("UIListLayout")
    self.ListLayout.Parent = self.ListFrame
    
    self.Items = options.Items or {}
    self.Selected = options.Default
    self.Callback = options.Callback or function(selected) end
    self.Description = options.Description or function() return "A dropdown menu" end
    
    self:Initialize()
    return self
end

function Dropdown:Initialize()
    self.Parent.ThemeManager:RegisterInstance(self.Instance, {BackgroundColor3 = "Secondary", TextColor3 = "Text"})
    self.Parent.ThemeManager:RegisterInstance(self.ListFrame, {BackgroundColor3 = "Accent"})
    
    self:PopulateItems()
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseEnter:Connect(function()
        self.Parent.TooltipText.Text = self.Description()
        self.Parent.Tooltip.Visible = true
        local size = TextService:GetTextSize(self.Parent.TooltipText.Text, 14, Enum.Font.SourceSans, Vector2.new(200, math.huge))
        self.Parent.Tooltip.Size = UDim2.new(0, size.X + 4, 0, size.Y + 4)
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseLeave:Connect(function()
        self.Parent.Tooltip.Visible = false
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseButton1Click:Connect(function()
        self:ToggleList()
    end)
end

function Dropdown:PopulateItems()
    for _, item in pairs(self.Items) do
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(1, 0, 0, 25)
        button.Text = item
        button.Font = Enum.Font.SourceSans
        button.TextSize = 14
        button.Parent = self.ListFrame
        self.Parent.ThemeManager:RegisterInstance(button, {BackgroundColor3 = "Secondary", TextColor3 = "Text"})
        
        button.MouseButton1Click:Connect(function()
            self:Select(item)
            self:ToggleList()
        end)
    end
    self.ListFrame.CanvasSize = UDim2.new(0, 0, 0, self.ListLayout.AbsoluteContentSize.Y)
end

function Dropdown:ToggleList()
    self.ListFrame.Visible = not self.ListFrame.Visible
    if self.ListFrame.Visible then
        AnimationUtils.fadeIn(self.ListFrame)
    else
        AnimationUtils.fadeOut(self.ListFrame)
    end
end

function Dropdown:Select(item)
    self.Selected = item
    self.Instance.Text = item
    self.Callback(item)
end

-- Slider Component
local Slider = setmetatable({}, {__index = Component})
Slider.__index = Slider

function Slider.new(parent, options)
    local self = Component.new("Slider", parent, options)
    
    self.Instance = Instance.new("Frame")
    self.Instance.Size = options.Size or UDim2.new(0, 200, 0, 20)
    self.Instance.Parent = parent
    self.Instance.ZIndex = options.ZIndex or 1
    
    self.Bar = Instance.new("Frame")
    self.Bar.Size = UDim2.new(1, 0, 0, 4)
    self.Bar.Position = UDim2.new(0, 0, 0.5, -2)
    self.Bar.Parent = self.Instance
    
    self.Knob = Instance.new("Frame")
    self.Knob.Size = UDim2.new(0, 12, 0, 12)
    self.Knob.Position = UDim2.new(0, 0, 0.5, -6)
    self.Knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.Knob.Parent = self.Instance
    
    self.Min = options.Min or 0
    self.Max = options.Max or 100
    self.Value = options.Default or 0
    self.Step = options.Step or 1
    self.Callback = options.Callback or function(value) end
    self.Description = options.Description or function() return "A slider: " .. self.Value end
    
    self:Initialize()
    return self
end

function Slider:Initialize()
    self.Parent.ThemeManager:RegisterInstance(self.Instance, {BackgroundColor3 = "Secondary"})
    self.Parent.ThemeManager:RegisterInstance(self.Bar, {BackgroundColor3 = "Accent"})
    
    self:UpdateKnob()
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseEnter:Connect(function()
        self.Parent.TooltipText.Text = self.Description()
        self.Parent.Tooltip.Visible = true
        local size = TextService:GetTextSize(self.Parent.TooltipText.Text, 14, Enum.Font.SourceSans, Vector2.new(200, math.huge))
        self.Parent.Tooltip.Size = UDim2.new(0, size.X + 4, 0, size.Y + 4)
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.MouseLeave:Connect(function()
        self.Parent.Tooltip.Visible = false
    end)
    
    self.Connections[#self.Connections + 1] = self.Instance.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self:StartDragging()
        end
    end)
end

function Slider:StartDragging()
    local dragging = true
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not dragging then
            connection:Disconnect()
            return
        end
        local mousePos = UserInputService:GetMouseLocation()
        local relativeX = mousePos.X - self.Instance.AbsolutePosition.X
        local clampedX = clamp(relativeX, 0, self.Instance.AbsoluteSize.X)
        local value = self.Min + (clampedX / self.Instance.AbsoluteSize.X) * (self.Max - self.Min)
        self.Value = math.floor(value / self.Step) * self.Step
        self:UpdateKnob()
        self.Callback(self.Value)
        self.Parent.TooltipText.Text = self.Description()
    end)
    
    self.Connections[#self.Connections + 1] = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
end

function Slider:UpdateKnob()
    local ratio = (self.Value - self.Min) / (self.Max - self.Min)
    local posX = (self.Instance.AbsoluteSize.X - self.Knob.AbsoluteSize.X) * ratio
    AnimationUtils.springTo(self.Knob, "Position", UDim2.new(0, posX, 0.5, -6), {frequency = 5, damping = 0.8})
end

-- Notification System
local NotificationSystem = {}
NotificationSystem.__index = NotificationSystem

function NotificationSystem.new(parent)
    local self = setmetatable({
        Parent = parent,
        Notifications = {},
        Container = Instance.new("Frame"),
    }, NotificationSystem)
    
    self.Container.Size = UDim2.new(0, 300, 1, 0)
    self.Container.Position = UDim2.new(1, -310, 0, 0)
    self.Container.BackgroundTransparency = 1
    self.Container.Parent = parent.ScreenGui
    
    self.Layout = Instance.new("UIListLayout")
    self.Layout.SortOrder = Enum.SortOrder.LayoutOrder
    self.Layout.Padding = UDim.new(0, 10)
    self.Layout.Parent = self.Container
    
    return self
end

function NotificationSystem:Notify(options)
    local notification = Instance.new("Frame")
    notification.Size = UDim2.new(1, 0, 0, 50)
    notification.BackgroundTransparency = 0.1
    notification.Parent = self.Container
    self.Parent.ThemeManager:RegisterInstance(notification, {BackgroundColor3 = "Secondary"})
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -10, 0, 20)
    title.Position = UDim2.new(0, 5, 0, 5)
    title.Text = options.Title or "Notification"
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 16
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.BackgroundTransparency = 1
    title.Parent = notification
    
    local message = Instance.new("TextLabel")
    message.Size = UDim2.new(1, -10, 0, 20)
    message.Position = UDim2.new(0, 5, 0, 25)
    message.Text = options.Message or "This is a message"
    message.Font = Enum.Font.SourceSans
    message.TextSize = 14
    message.TextColor3 = Color3.fromRGB(200, 200, 200)
    message.BackgroundTransparency = 1
    message.Parent = notification
    
    table.insert(self.Notifications, notification)
    
    AnimationUtils.fadeIn(notification)
    delay(options.Duration or 3, function()
        AnimationUtils.fadeOut(notification)
        delay(0.3, function()
            notification:Destroy()
            for i, v in pairs(self.Notifications) do
                if v == notification then
                    table.remove(self.Notifications, i)
                    break
                end
            end
        end)
    end)
    
    self.Container.CanvasSize = UDim2.new(0, 0, 0, self.Layout.AbsoluteContentSize.Y)
end

-- Debug Console
local DebugConsole = {}
DebugConsole.__index = DebugConsole

function DebugConsole.new(fluent)
    local self = setmetatable({
        Fluent = fluent,
        Logs = {},
        MaxLogs = 100,
        Frame = nil,
        TextBox = nil,
        Connections = {}
    }, DebugConsole)
    
    self:Initialize()
    return self
end

function DebugConsole:Initialize()
    self.Frame = Instance.new("Frame")
    self.Frame.Size = UDim2.new(0, 300, 0, 200)
    self.Frame.Position = UDim2.new(1, -310, 0, 310)
    self.Frame.BackgroundTransparency = 0.1
    self.Frame.Parent = self.Fluent.ScreenGui
    self.Fluent.ThemeManager:RegisterInstance(self.Frame, {BackgroundColor3 = "Secondary"})
    
    self.TextBox = Instance.new("TextBox")
    self.TextBox.Size = UDim2.new(1, -10, 1, -10)
    self.TextBox.Position = UDim2.new(0, 5, 0, 5)
    self.TextBox.BackgroundTransparency = 1
    self.TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.TextBox.Font = Enum.Font.Code
    self.TextBox.TextSize = 14
    self.TextBox.MultiLine = true
    self.TextBox.TextWrapped = true
    self.TextBox.Text = "Debug Console\n"
    self.TextBox.Parent = self.Frame
    
    self.Connections[#self.Connections + 1] = self.TextBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local success, err = pcall(function()
                local func = loadstring("return " .. self.TextBox.Text:match(">(.*)"))
                if func then
                    local result = func()
                    self:Log(tostring(result))
                end
            end)
            if not success then
                self:Log("Error: " .. err)
            end
            self.TextBox.Text = "Debug Console\n" .. table.concat(self.Logs, "\n")
        end
    end)
end

function DebugConsole:Log(message)
    table.insert(self.Logs, "> " .. message)
    if #self.Logs > self.MaxLogs then
        table.remove(self.Logs, 1)
    end
    self.TextBox.Text = "Debug Console\n" .. table.concat(self.Logs, "\n")
end

-- Performance Monitor
local PerformanceMonitor = {}
PerformanceMonitor.__index = PerformanceMonitor

function PerformanceMonitor.new(fluent)
    local self = setmetatable({
        Fluent = fluent,
        FrameTimes = {},
        MemoryUsage = {},
        MaxSamples = 60,
        Connections = {}
    }, PerformanceMonitor)
    
    self:Initialize()
    return self
end

function PerformanceMonitor:Initialize()
    self.Connections[#self.Connections + 1] = RunService.Heartbeat:Connect(function(dt)
        table.insert(self.FrameTimes, dt)
        if #self.FrameTimes > self.MaxSamples then
            table.remove(self.FrameTimes, 1)
        end
        
        local memory = collectgarbage("count") / 1024 -- MB
        table.insert(self.MemoryUsage, memory)
        if #self.MemoryUsage > self.MaxSamples then
            table.remove(self.MemoryUsage, 1)
        end
    end)
end

function PerformanceMonitor:GetFPS()
    local totalDt = 0
    for _, dt in pairs(self.FrameTimes) do
        totalDt = totalDt + dt
    end
    return #self.FrameTimes / totalDt
end

function PerformanceMonitor:GetMemoryUsage()
    local totalMem = 0
    for _, mem in pairs(self.MemoryUsage) do
        totalMem = totalMem + mem
    end
    return totalMem / #self.MemoryUsage
end

-- Optimization Functions
local Optimization = {}

function Optimization.GarbageCollect()
    collectgarbage("collect")
end

function Optimization.BatchUpdate(instances, properties)
    for instance, props in pairs(instances) do
        for prop, value in pairs(props) do
            instance[prop] = value
        end
    end
end

-- Remote Spy Class
local RemoteSpy = {}
RemoteSpy.__index = RemoteSpy

function RemoteSpy.new(fluent)
    local self = setmetatable({
        Fluent = fluent,
        Hooks = {},
        Excluded = {},
        Blocked = {},
        Logs = {},
        Connections = {},
        Serializer = {}
    }, RemoteSpy)
    
    self:Initialize()
    return self
end

-- Serializer for complex data
function RemoteSpy:Serialize(value, depth)
    depth = depth or 0
    if depth > 10 then return "..." end -- Prevent infinite recursion
    
    local t = typeof(value)
    if t == "string" then
        return string.format("%q", value)
    elseif t == "number" or t == "boolean" or t == "nil" then
        return tostring(value)
    elseif t == "table" then
        if self.Serializer[value] then
            return "CyclicTable"
        end
        self.Serializer[value] = true
        local result = "{\n"
        for k, v in pairs(value) do
            local keyStr = self:Serialize(k, depth + 1)
            local valStr = self:Serialize(v, depth + 1)
            result = result .. string.rep("  ", depth + 1) .. "[" .. keyStr .. "] = " .. valStr .. ",\n"
        end
        self.Serializer[value] = nil
        return result .. string.rep("  ", depth) .. "}"
    elseif t == "Instance" then
        return value:GetFullName()
    else
        return "<" .. t .. ">"
    end
end

-- Hook Remote Functions
function RemoteSpy:HookRemote(remote, method)
    local oldFunc = remote[method]
    remote[method] = function(...)
        if self.Excluded[remote] then return oldFunc(...) end
        if self.Blocked[remote] then return end
        
        local args = {...}
        local caller = getcallingscript() or "Unknown"
        local logData = {
            Name = remote.Name,
            Path = remote:GetFullName(),
            Method = method,
            Args = args,
            Caller = caller,
            Timestamp = os.time(),
            Script = self:GenerateScript(remote, method, args)
        }
        
        table.insert(self.Logs, logData)
        self.Fluent:AddLog(logData)
        
        return oldFunc(...)
    end
    self.Hooks[remote] = oldFunc
end

-- Generate Executable Script
function RemoteSpy:GenerateScript(remote, method, args)
    local script = "local remote = game." .. remote:GetFullName() .. "\n"
    script = script .. "remote:" .. method .. "("
    for i, arg in pairs(args) do
        script = script .. self:Serialize(arg)
        if i < #args then script = script .. ", " end
    end
    script = script .. ")"
    return script
end

-- Initialize Remote Spy
function RemoteSpy:Initialize()
    -- Hook existing remotes
    for _, remote in pairs(game:GetDescendants()) do
        if remote:IsA("RemoteEvent") then
            self:HookRemote(remote, "FireServer")
        elseif remote:IsA("RemoteFunction") then
            self:HookRemote(remote, "InvokeServer")
        end
    end
    
    -- Hook new remotes
    self.Connections[#self.Connections + 1] = game.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("RemoteEvent") then
            self:HookRemote(descendant, "FireServer")
        elseif descendant:IsA("RemoteFunction") then
            self:HookRemote(descendant, "InvokeServer")
        end
    end)
    
    -- Clean up logs periodically
    self.Connections[#self.Connections + 1] = RunService.Heartbeat:Connect(function()
        if #self.Logs > 1000 then
            table.remove(self.Logs, 1)
        end
    end)
end

-- Exclude Remote
function RemoteSpy:Exclude(remote)
    self.Excluded[remote] = true
end

-- Block Remote
function RemoteSpy:Block(remote)
    self.Blocked[remote] = true
end

-- Unhook Remote
function RemoteSpy:Unhook(remote)
    if self.Hooks[remote] then
        if remote:IsA("RemoteEvent") then
            remote.FireServer = self.Hooks[remote]
        elseif remote:IsA("RemoteFunction") then
            remote.InvokeServer = self.Hooks[remote]
        end
        self.Hooks[remote] = nil
        self.Excluded[remote] = nil
        self.Blocked[remote] = nil
    end
end

-- Config Manager Class
local ConfigManager = {}
ConfigManager.__index = ConfigManager

function ConfigManager.new(fluent)
    local self = setmetatable({
        Fluent = fluent,
        FileName = "SmoothFluentUI_Config.json",
        DefaultConfig = {
            Theme = "SmoothDream",
            MaximizeKey = "LeftControl",
            MobileSupport = true,
            Acrylic = true,
            WindowPosition = {X = 0.5, Y = 0.5, XOffset = -300, YOffset = -200},
            ExcludedRemotes = {},
            BlockedRemotes = {}
        },
        CurrentConfig = {}
    }, ConfigManager)
    
    self:Initialize()
    return self
end

-- Initialize Config
function ConfigManager:Initialize()
    self.CurrentConfig = deepCopy(self.DefaultConfig)
    if isfile(self.FileName) then
        self:LoadConfig()
    else
        self:SaveConfig()
    end
end

-- Save Config to File
function ConfigManager:SaveConfig()
    local success, err = pcall(function()
        local json = HttpService:JSONEncode(self.CurrentConfig)
        writefile(self.FileName, json)
    end)
    if not success then
        warn("Failed to save config: " .. err)
        self.Fluent.NotificationSystem:Notify({
            Title = "Save Error",
            Message = "Failed to save config: " .. err,
            Duration = 3
        })
    else
        self.Fluent.NotificationSystem:Notify({
            Title = "Saved",
            Message = "Configuration saved successfully!",
            Duration = 2
        })
    end
end

-- Load Config from File
function ConfigManager:LoadConfig()
    local success, result = pcall(function()
        local json = readfile(self.FileName)
        return HttpService:JSONDecode(json)
    end)
    if success then
        self.CurrentConfig = deepCopy(result)
        self:ApplyConfig()
    else
        warn("Failed to load config: " .. result)
        self.Fluent.NotificationSystem:Notify({
            Title = "Load Error",
            Message = "Failed to load config: " .. result,
            Duration = 3
        })
        self.CurrentConfig = deepCopy(self.DefaultConfig)
        self:SaveConfig()
    end
end

-- Apply Config to UI
function ConfigManager:ApplyConfig()
    self.Fluent.Config = {
        Theme = self.CurrentConfig.Theme,
        MaximizeKey = Enum.KeyCode[self.CurrentConfig.MaximizeKey],
        MobileSupport = self.CurrentConfig.MobileSupport,
        Acrylic = self.CurrentConfig.Acrylic
    }
    
    self.Fluent.MainFrame.Position = UDim2.new(
        self.CurrentConfig.WindowPosition.X,
        self.CurrentConfig.WindowPosition.XOffset,
        self.CurrentConfig.WindowPosition.Y,
        self.CurrentConfig.WindowPosition.YOffset
    )
    
    self.Fluent:UpdateTheme(self.CurrentConfig.Theme)
    
    for _, remotePath in pairs(self.CurrentConfig.ExcludedRemotes) do
        local remote = game:FindFirstChild(remotePath, true)
        if remote then
            self.Fluent.RemoteSpy:Exclude(remote)
        end
    end
    
    for _, remotePath in pairs(self.CurrentConfig.BlockedRemotes) do
        local remote = game:FindFirstChild(remotePath, true)
        if remote then
            self.Fluent.RemoteSpy:Block(remote)
        end
    end
end

-- Update Config
function ConfigManager:UpdateConfig(key, value)
    self.CurrentConfig[key] = value
    self:ApplyConfig()
    self:SaveConfig()
end

-- Fluent Class (Main UI)
local Fluent = {}
Fluent.__index = Fluent

-- Create new Fluent UI instance
function Fluent.new(options)
    options = options or {}
    local self = setmetatable({}, Fluent)
    
    -- Configuration
    self.Config = {
        Theme = options.Theme or DEFAULT_THEME,
        Acrylic = options.Acrylic or true,
        MaximizeKey = options.MaximizeKey or Enum.KeyCode.LeftControl,
        MobileSupport = options.MobileSupport or true,
        Title = options.Title or "SmoothFluent UI v2.0"
    }
    
    -- State
    self.Logs = {}
    self.SelectedLog = nil
    self.IsMinimized = false
    self.IsDragging = false
    self.Connections = {}
    self.MouseInGui = false
    
    -- Main Container
    self.ScreenGui = createInstance("ScreenGui", {
        ResetOnSpawn = false,
        Parent = CoreGui,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    })
    
    self.MainFrame = createInstance("Frame", {
        Size = DEFAULT_WINDOW_SIZE,
        Position = UDim2.new(0.5, -300, 0.5, -200),
        BackgroundTransparency = 0.9,
        BackgroundColor3 = Color3.fromRGB(10, 10, 20),
        BorderSizePixel = 0,
        Parent = self.ScreenGui
    })
    
    -- Top Bar
    self.TopBar = createInstance("Frame", {
        Size = UDim2.new(1, 0, 0, 30),
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        BorderSizePixel = 0,
        Parent = self.MainFrame
    })
    
    self.Title = createInstance("TextLabel", {
        Size = UDim2.new(0.5, 0, 1, 0),
        Text = self.Config.Title,
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.SourceSansBold,
        TextSize = 18,
        BackgroundTransparency = 1,
        Parent = self.TopBar
    })
    
    self.CloseButton = createInstance("TextButton", {
        Size = UDim2.new(0, 30, 0, 30),
        Position = UDim2.new(1, -30, 0, 0),
        BackgroundColor3 = Color3.fromRGB(255, 60, 60),
        Text = "X",
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.SourceSans,
        TextSize = 14,
        Parent = self.TopBar
    })
    
    self.MinimizeButton = createInstance("TextButton", {
        Size = UDim2.new(0, 30, 0, 30),
        Position = UDim2.new(1, -60, 0, 0),
        BackgroundColor3 = Color3.fromRGB(50, 50, 60),
        Text = "-",
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.SourceSans,
        TextSize = 14,
        Parent = self.TopBar
    })
    
    -- Left Panel (Remote Logs)
    self.LeftPanel = createInstance("Frame", {
        Size = UDim2.new(0, 200, 1, -30),
        Position = UDim2.new(0, 0, 0, 30),
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        BorderSizePixel = 0,
        Parent = self.MainFrame
    })
    
    self.LogList = createInstance("ScrollingFrame", {
        Size = UDim2.new(1, 0, 1, -10),
        Position = UDim2.new(0, 0, 0, 5),
        BackgroundTransparency = 1,
        ScrollBarThickness = 4,
        CanvasSize = UDim2.new(0, 0, 0, 0),
        Parent = self.LeftPanel
    })
    
    self.LogLayout = createInstance("UIListLayout", {
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 5),
        Parent = self.LogList
    })
    
    -- Right Panel (Details)
    self.RightPanel = createInstance("Frame", {
        Size = UDim2.new(1, -200, 1, -30),
        Position = UDim2.new(0, 200, 0, 30),
        BackgroundColor3 = Color3.fromRGB(50, 50, 60),
        BorderSizePixel = 0,
        Parent = self.MainFrame
    })
    
    self.CodeBox = createInstance("TextBox", {
        Size = UDim2.new(1, 0, 0.5, 0),
        BackgroundColor3 = Color3.fromRGB(20, 20, 25),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.Code,
        TextSize = 14,
        MultiLine = true,
        ClearTextOnFocus = false,
        Text = "",
        Parent = self.RightPanel
    })
    
    self.ButtonFrame = createInstance("ScrollingFrame", {
        Size = UDim2.new(1, 0, 0.5, -10),
        Position = UDim2.new(0, 0, 0.5, 5),
        BackgroundTransparency = 1,
        ScrollBarThickness = 4,
        CanvasSize = UDim2.new(0, 0, 0, 0),
        Parent = self.RightPanel
    })
    
    self.ButtonLayout = createInstance("UIGridLayout", {
        CellSize = UDim2.new(0, 100, 0, 30),
        CellPadding = UDim2.new(0, 5, 0, 5),
        SortOrder = Enum.SortOrder.LayoutOrder,
        Parent = self.ButtonFrame
    })
    
    -- Tooltip
    self.Tooltip = createInstance("Frame", {
        Size = UDim2.new(0, 200, 0, 50),
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        BackgroundTransparency = 0.1,
        Visible = false,
        ZIndex = 10,
        BorderSizePixel = 0,
        Parent = self.ScreenGui
    })
    
    self.TooltipText = createInstance("TextLabel", {
        Size = UDim2.new(1, -4, 1, -4),
        Position = UDim2.new(0, 2, 0, 2),
        BackgroundTransparency = 1,
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.SourceSans,
        TextSize = 14,
        TextWrapped = true,
        Text = "",
        Parent = self.Tooltip
    })
    
    -- Custom Cursor
    self.CustomCursor = createInstance("ImageLabel", {
        Size = UDim2.new(0, 20, 0, 20),
        BackgroundTransparency = 1,
        Visible = false,
        ZIndex = 11,
        Image = "rbxassetid://6065775281",
        Parent = self.ScreenGui
    })
    
    -- Initialize all modules
    self:Initialize()
    self:InitializeThemeManager()
    self:InitializeComponents()
    self:InitializeRemoteSpy()
    self:InitializeConfigManager()
    self:InitializeOptimizationAndDebugging()
    
    return self
end

-- Initialize UI
function Fluent:Initialize()
    -- Dragging
    self.TopBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.IsDragging = true
            local startPos = input.Position
            local startFramePos = self.MainFrame.Position
            
            local dragConnection
            dragConnection = RunService.RenderStepped:Connect(function()
                if not self.IsDragging then
                    dragConnection:Disconnect()
                    return
                end
                local newPos = UserInputService:GetMouseLocation()
                local delta = newPos - startPos
                local newX = clamp(startFramePos.X.Offset + delta.X, 0, workspace.CurrentCamera.ViewportSize.X - self.MainFrame.Size.X.Offset)
                local newY = clamp(startFramePos.Y.Offset + delta.Y, 0, workspace.CurrentCamera.ViewportSize.Y - self.MainFrame.Size.Y.Offset)
                self.MainFrame.Position = UDim2.new(0, newX, 0, newY)
            end)
            
            self.Connections[#self.Connections + 1] = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    self.IsDragging = false
                end
            end)
        end
    end)
    
    -- Minimize
    self.MinimizeButton.MouseButton1Click:Connect(function()
        self:ToggleMinimize()
    end)
    
    -- Close
    self.CloseButton.MouseButton1Click:Connect(function()
        self:Destroy()
    end)
    
    -- Tooltip and Cursor Handling
    self.Connections[#self.Connections + 1] = RunService.RenderStepped:Connect(function()
        local mousePos = UserInputService:GetMouseLocation()
        if self.Tooltip.Visible then
            self.Tooltip.Position = UDim2.new(0, mousePos.X + 10, 0, mousePos.Y + 10)
        end
        
        local inGui = self:IsMouseInGui(mousePos)
        self.MouseInGui = inGui
        UserInputService.MouseIconEnabled = not inGui
        self.CustomCursor.Visible = inGui
        if inGui then
            self.CustomCursor.Position = UDim2.new(0, mousePos.X - 10, 0, mousePos.Y - 10)
        end
    end)
    
    -- Hover Effects
    self.CloseButton.MouseEnter:Connect(function()
        TweenService:Create(self.CloseButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(255, 100, 100)}):Play()
    end)
    self.CloseButton.MouseLeave:Connect(function()
        TweenService:Create(self.CloseButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(255, 60, 60)}):Play()
    end)
    
    self.MinimizeButton.MouseEnter:Connect(function()
        TweenService:Create(self.MinimizeButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(70, 70, 80)}):Play()
    end)
    self.MinimizeButton.MouseLeave:Connect(function()
        TweenService:Create(self.MinimizeButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(50, 50, 60)}):Play()
    end)
end

-- Toggle Minimize
function Fluent:ToggleMinimize()
    self.IsMinimized = not self.IsMinimized
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    if self.IsMinimized then
        TweenService:Create(self.MainFrame, tweenInfo, {Size = MIN_WINDOW_SIZE}):Play()
        self.LeftPanel.Visible = false
        self.RightPanel.Visible = false
    else
        TweenService:Create(self.MainFrame, tweenInfo, {Size = DEFAULT_WINDOW_SIZE}):Play()
        self.LeftPanel.Visible = true
        self.RightPanel.Visible = true
    end
end

-- Check if Mouse is in GUI
function Fluent:IsMouseInGui(mousePos)
    local pos = self.MainFrame.AbsolutePosition
    local size = self.MainFrame.AbsoluteSize
    return mousePos.X >= pos.X and mousePos.X <= pos.X + size.X and
           mousePos.Y >= pos.Y and mousePos.Y <= pos.Y + size.Y
end

-- Create Button
function Fluent:CreateButton(name, description, callback)
    local button = createInstance("TextButton", {
        Size = UDim2.new(0, 100, 0, 30),
        BackgroundColor3 = Color3.fromRGB(255, 215, 0),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.SourceSans,
        TextSize = 14,
        Text = name,
        Parent = self.ButtonFrame
    })
    
    button.MouseEnter:Connect(function()
        self.TooltipText.Text = description()
        self.Tooltip.Visible = true
        local size = TextService:GetTextSize(self.TooltipText.Text, 14, Enum.Font.SourceSans, Vector2.new(200, math.huge))
        self.Tooltip.Size = UDim2.new(0, size.X + 4, 0, size.Y + 4)
    end)
    
    button.MouseLeave:Connect(function()
        self.Tooltip.Visible = false
    end)
    
    button.MouseButton1Click:Connect(callback)
    self.ButtonLayout:ApplyLayout()
    self.ButtonFrame.CanvasSize = UDim2.new(0, 0, 0, self.ButtonLayout.AbsoluteContentSize.Y)
end

-- Add Log
function Fluent:AddLog(data)
    if #self.Logs >= MAX_LOG_SIZE then
        table.remove(self.Logs, 1)
        self.LogList:GetChildren()[2]:Destroy()
    end
    
    local logFrame = createInstance("Frame", {
        Size = UDim2.new(1, -10, 0, 30),
        BackgroundTransparency = 1,
        Parent = self.LogList
    })
    
    local logButton = createInstance("TextButton", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.SourceSans,
        TextSize = 14,
        Text = data.Name,
        Parent = logFrame
    })
    
    local logData = {
        Log = logFrame,
        Button = logButton,
        Data = data
    }
    table.insert(self.Logs, logData)
    
    logButton.MouseButton1Click:Connect(function()
        self:SelectLog(logData)
    end)
    
    self.LogLayout:ApplyLayout()
    self.LogList.CanvasSize = UDim2.new(0, 0, 0, self.LogLayout.AbsoluteContentSize.Y)
end

-- Select Log
function Fluent:SelectLog(log)
    if self.SelectedLog then
        self.SelectedLog.Button.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    end
    self.SelectedLog = log
    log.Button.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
    self.CodeBox.Text = log.Data.Script or "No script available"
end

-- Destroy UI
function Fluent:Destroy()
    for _, conn in pairs(self.Connections) do
        conn:Disconnect()
    end
    self.ScreenGui:Destroy()
end

-- Initialize Theme Manager
function Fluent:InitializeThemeManager()
    self.ThemeManager = ThemeManager.new()
    
    -- Register core UI elements
    self.ThemeManager:RegisterInstance(self.MainFrame, {BackgroundColor3 = "Background", BackgroundTransparency = "Transparency"})
    self.ThemeManager:RegisterInstance(self.TopBar, {BackgroundColor3 = "Secondary"})
    self.ThemeManager:RegisterInstance(self.Title, {TextColor3 = "Text"})
    self.ThemeManager:RegisterInstance(self.CloseButton, {TextColor3 = "Text"})
    self.ThemeManager:RegisterInstance(self.MinimizeButton, {BackgroundColor3 = "Accent", TextColor3 = "Text"})
    self.ThemeManager:RegisterInstance(self.LeftPanel, {BackgroundColor3 = "Secondary"})
    self.ThemeManager:RegisterInstance(self.RightPanel, {BackgroundColor3 = "Accent"})
    self.ThemeManager:RegisterInstance(self.CodeBox, {TextColor3 = "Text"})
    self.ThemeManager:RegisterInstance(self.Tooltip, {BackgroundColor3 = "Secondary", BackgroundTransparency = "Transparency"})
    self.ThemeManager:RegisterInstance(self.TooltipText, {TextColor3 = "Text"})
    
    -- Apply initial theme
    self.ThemeManager:SetTheme(self.Config.Theme)
    
    -- Add acrylic effect if enabled
    if self.Config.Acrylic then
        self.ThemeManager:CreateAcrylicEffect(self.MainFrame)
    end
end

function Fluent:UpdateTheme(themeName)
    self.Config.Theme = themeName
    self.ThemeManager:SetTheme(themeName)
    
    -- Update particle system color if exists
    if self.ParticleEffect then
        self.ParticleEffect.color = Themes[themeName].Primary
    end
end

-- Initialize Components
function Fluent:InitializeComponents()
    self.NotificationSystem = NotificationSystem.new(self)
    
    -- Replace CreateButton with Component version
    self.CreateButton = function(self, name, description, callback)
        local button = Button.new(self, {
            Parent = self.ButtonFrame,
            Text = name,
            Description = description,
            Callback = callback
        })
        self.ButtonLayout:ApplyLayout()
        self.ButtonFrame.CanvasSize = UDim2.new(0, 0, 0, self.ButtonLayout.AbsoluteContentSize.Y)
        return button
    end
end

-- Initialize Remote Spy
function Fluent:InitializeRemoteSpy()
    self.RemoteSpy = RemoteSpy.new(self)
    
    -- Add Remote Spy buttons
    self:CreateButton("Copy Code", function()
        return "Copy the selected remote call script to clipboard"
    end, function()
        if self.SelectedLog then
            setclipboard(self.SelectedLog.Data.Script)
            self.NotificationSystem:Notify({
                Title = "Copied",
                Message = "Script copied to clipboard!",
                Duration = 2
            })
        end
    end)
    
    self:CreateButton("Run Code", function()
        return "Execute the selected remote call script"
    end, function()
        if self.SelectedLog then
            local success, err = pcall(function()
                loadstring(self.SelectedLog.Data.Script)()
            end)
            if not success then
                self.NotificationSystem:Notify({
                    Title = "Error",
                    Message = "Failed to run script: " .. err,
                    Duration = 3
                })
            else
                self.NotificationSystem:Notify({
                    Title = "Success",
                    Message = "Script executed successfully!",
                    Duration = 2
                })
            end
        end
    end)
    
    self:CreateButton("Exclude", function()
        return "Exclude this remote from logging"
    end, function()
        if self.SelectedLog then
            local remote = game:FindFirstChild(self.SelectedLog.Data.Path, true)
            if remote then
                self.RemoteSpy:Exclude(remote)
                table.insert(self.ConfigManager.CurrentConfig.ExcludedRemotes, remote:GetFullName())
                self.ConfigManager:SaveConfig()
                self.NotificationSystem:Notify({
                    Title = "Excluded",
                    Message = self.SelectedLog.Data.Name .. " excluded from logging",
                    Duration = 2
                })
            end
        end
    end)
    
    self:CreateButton("Block", function()
        return "Block this remote from firing"
    end, function()
        if self.SelectedLog then
            local remote = game:FindFirstChild(self.SelectedLog.Data.Path, true)
            if remote then
                self.RemoteSpy:Block(remote)
                table.insert(self.ConfigManager.CurrentConfig.BlockedRemotes, remote:GetFullName())
                self.ConfigManager:SaveConfig()
                self.NotificationSystem:Notify({
                    Title = "Blocked",
                    Message = self.SelectedLog.Data.Name .. " blocked",
                    Duration = 2
                })
            end
        end
    end)
    
    self:CreateButton("Clear Logs", function()
        return "Clear all logged remote calls"
    end, function()
        for _, log in pairs(self.Logs) do
            log.Log:Destroy()
        end
        self.Logs = {}
        self.RemoteSpy.Logs = {}
        self.SelectedLog = nil
        self.CodeBox.Text = ""
        self.NotificationSystem:Notify({
            Title = "Cleared",
            Message = "All logs cleared",
            Duration = 2
        })
    end)
end

-- Initialize Config Manager
function Fluent:InitializeConfigManager()
    self.ConfigManager = ConfigManager.new(self)
    
    -- Update config when UI state changes
    self.Connections[#self.Connections + 1] = self.MainFrame:GetPropertyChangedSignal("Position"):Connect(function()
        self.ConfigManager.CurrentConfig.WindowPosition = {
            X = self.MainFrame.Position.X.Scale,
            Y = self.MainFrame.Position.Y.Scale,
            XOffset = self.MainFrame.Position.X.Offset,
            YOffset = self.MainFrame.Position.Y.Offset
        }
        self.ConfigManager:SaveConfig()
    end)
    
    -- Add config buttons
    self:CreateButton("Save Config", function()
        return "Save current UI configuration"
    end, function()
        self.ConfigManager:SaveConfig()
    end)
    
    self:CreateButton("Load Config", function()
        return "Load saved UI configuration"
    end, function()
        self.ConfigManager:LoadConfig()
    end)
    
    self:CreateButton("Reset Config", function()
        return "Reset to default configuration"
    end, function()
        self.ConfigManager.CurrentConfig = deepCopy(self.ConfigManager.DefaultConfig)
        self.ConfigManager:ApplyConfig()
        self.ConfigManager:SaveConfig()
        self.NotificationSystem:Notify({
            Title = "Reset",
            Message = "Configuration reset to default",
            Duration = 2
        })
    end)
end

-- Initialize Optimization and Debugging
function Fluent:InitializeOptimizationAndDebugging()
    self.PerformanceMonitor = PerformanceMonitor.new(self)
    self.DebugConsole = DebugConsole.new(self)
    
    -- Add debug buttons
    self:CreateButton("Show FPS", function()
        return "Display current FPS"
    end, function()
        local fps = self.PerformanceMonitor:GetFPS()
        self.NotificationSystem:Notify({
            Title = "FPS",
            Message = "Current FPS: " .. string.format("%.2f", fps),
            Duration = 2
        })
    end)
    
    self:CreateButton("Show Memory", function()
        return "Display current memory usage"
    end, function()
        local mem = self.PerformanceMonitor:GetMemoryUsage()
        self.NotificationSystem:Notify({
            Title = "Memory",
            Message = "Memory Usage: " .. string.format("%.2f MB", mem),
            Duration = 2
        })
    end)
    
    self:CreateButton("Force GC", function()
        return "Force garbage collection"
    end, function()
        Optimization.GarbageCollect()
        self.NotificationSystem:Notify({
            Title = "GC",
            Message = "Garbage collection forced",
            Duration = 2
        })
    end)
    
    self:CreateButton("Toggle Debug", function()
        return "Show/hide debug console"
    end, function()
        self.DebugConsole.Frame.Visible = not self.DebugConsole.Frame.Visible
    end)
end

-- Modified SelectLog to include more details
function Fluent:SelectLog(log)
    if self.SelectedLog then
        self.SelectedLog.Button.BackgroundColor3 = Themes[self.Config.Theme].Secondary
    end
    self.SelectedLog = log
    log.Button.BackgroundColor3 = Themes[self.Config.Theme].Primary
    
    local detailedText = "-- Remote Call Details\n"
    detailedText = detailedText .. "Name: " .. log.Data.Name .. "\n"
    detailedText = detailedText .. "Path: " .. log.Data.Path .. "\n"
    detailedText = detailedText .. "Method: " .. log.Data.Method .. "\n"
    detailedText = detailedText .. "Caller: " .. tostring(log.Data.Caller) .. "\n"
    detailedText = detailedText .. "Timestamp: " .. os.date("%c", log.Data.Timestamp) .. "\n"
    detailedText = detailedText .. "Arguments:\n" .. self.RemoteSpy:Serialize(log.Data.Args) .. "\n\n"
    detailedText = detailedText .. "-- Generated Script\n" .. log.Data.Script
    self.CodeBox.Text = detailedText
end

-- Return the Fluent class
return Fluent
